<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://q456qq520.github.io</id>
    <title>LIKE CAT</title>
    <updated>2021-07-12T03:00:11.536Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://q456qq520.github.io"/>
    <link rel="self" href="https://q456qq520.github.io/atom.xml"/>
    <subtitle>一条小咸鱼</subtitle>
    <logo>https://q456qq520.github.io/images/avatar.png</logo>
    <icon>https://q456qq520.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, LIKE CAT</rights>
    <entry>
        <title type="html"><![CDATA[单例模式]]></title>
        <id>https://q456qq520.github.io/post/Singleton/</id>
        <link href="https://q456qq520.github.io/post/Singleton/">
        </link>
        <updated>2021-07-09T09:18:24.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-什么是单例模式">一、什么是单例模式</h3>
<h5 id="1-只能保证类只有一个实例">1. 只能保证类只有一个实例。</h5>
<p><em>普通构造函数无法实现上述行为， 因为构造函数的设计决定了它必须总是返回一个新对象。</em></p>
<h5 id="2-为该实例提供一个全局访问节点">2.  为该实例提供一个全局访问节点。</h5>
<p><em>也就是对外部提供一个统一的获取实例的入口</em></p>
<h3 id="二-怎么实现单例模式">二、怎么实现单例模式</h3>
<h5 id="1-将默认构造函数设为私有-防止其他对象使用单例类的-new运算符">1. 将默认构造函数设为私有， 防止其他对象使用单例类的 new运算符。</h5>
<h5 id="2-新建一个静态构建方法作-该方法用来调用私有构造函数来创建对象-并将其保存在一个静态成员变量中-此后所有对于该函数的调用都将返回这一缓存对象">2. 新建一个静态构建方法作。该方法用来调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。</h5>
<p>下图是我从网上“偷”来的一张单例模式类图，从图中很明显的可以看出单例模式的结构模式<br>
<img src="https://q456qq520.github.io/post-images/1625823739270.png" alt="" loading="lazy"></p>
<h3 id="三-适用场景">三、适用场景</h3>
<h5 id="1-对于程序中的某个类全局共用一个实例">1. 对于程序中的某个类全局共用一个实例</h5>
<p>单例模式并不等同于全局变量，因为它只保证类存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。</p>
<h3 id="四-伪代码">四、伪代码</h3>
<h5 id="1-eager-initialization">1. Eager initialization</h5>
<p>这种模式下单例类的实例是在类加载时创建的，这是创建单例类的最简单方法，但它有一个缺点，即即使客户端应用程序可能不会使用它，也会创建实例。</p>
<pre><code class="language-Eager">public class EagerInitialization {
    public static final EagerInitialization eagerInitialization= new EagerInitialization();

    private EagerInitialization() {
    }

    public static EagerInitialization getInstance(){
        return eagerInitialization;
    }
}
</code></pre>
<h5 id="2-static-block-initialization">2. Static block initialization</h5>
<p>静态块初始化实现类似于预先初始化，不同之处在于类的实例是在静态块中创建的，</p>
<pre><code class="language-Static">public class StaticBlockSingleton {
    private static StaticBlockSingleton staticBlockSingleton;

    private StaticBlockSingleton() {
    }

    static{
        try{
            staticBlockSingleton = new StaticBlockSingleton();
        }catch(Exception e){
            throw new RuntimeException(&quot;creating singleton instance exception&quot;);
        }
    }

    public static StaticBlockSingleton getInstance(){
        return staticBlockSingleton;
    }
}
</code></pre>
<h5 id="3-lazy-initialization懒汉式">3. Lazy Initialization（懒汉式）</h5>
<p>实现单例模式的延迟初始化方法在全局访问方法中创建实例。并不会类加载时就创建实例，而时在客户端第一次访问时才会初始化。</p>
<pre><code class="language-Lazy">public class LazyInitializedSingleton {
    public static LazyInitializedSingleton lazyInitializedSingleton;

    private LazyInitializedSingleton() {
    }

    public static LazyInitializedSingleton getInstance(){
        if(lazyInitializedSingleton == null){
            lazyInitializedSingleton =  new LazyInitializedSingleton();
        }
        return lazyInitializedSingleton;
    }
}
</code></pre>
<p>在多线程环境下，上述生成单例模式是不安全的，下面会讲述几种线程安全的创建方式。</p>
<h5 id="4-thread-safe-singleton">4. Thread Safe Singleton</h5>
<p>最简单的是使全局访问方法同步，以便一次只有一个线程可以执行此方法。</p>
<pre><code class="language-Thread">public class ThreadSafeSingleton {
    public static ThreadSafeSingleton threadSafeSingleton;

    private ThreadSafeSingleton() {
    }

    public static synchronized ThreadSafeSingleton getInstance(){
        if(threadSafeSingleton == null){
            threadSafeSingleton =  new ThreadSafeSingleton();
        }
        return threadSafeSingleton;
    }
}
</code></pre>
<p>其实并不需要每次获取实例都进行锁，为了每次都避免这种额外的开销，还可以使用下面都双重校验锁都方式</p>
<pre><code class="language-UsingDoubleLocking">public static ThreadSafeSingleton getInstanceUsingDoubleLocking(){
    if(threadSafeSingleton == null){
        synchronized (ThreadSafeSingleton.class) {
             if(threadSafeSingleton == null){
                 threadSafeSingleton = new ThreadSafeSingleton();
             }
         }
    }
    return threadSafeSingleton;
 }
</code></pre>
<h5 id="5-bill-pugh-singleton-implementation静态内部类">5. Bill Pugh Singleton Implementation（静态内部类）</h5>
<p>当加载单例类时，<em>SingletonHelper</em>类不会加载到内存中，只有当有人调用getInstance方法时，才会加载这个类并创建单例类实例。</p>
<pre><code class="language-Bill">public class BillPughSingleton {

    private BillPughSingleton() {
    }

    private static class SingletonHelper{
        private static final BillPughSingleton INSTANCE = new BillPughSingleton();
    }

    public static BillPughSingleton getInstance(){
        return SingletonHelper.INSTANCE;
    }
}
</code></pre>
<h5 id="6-using-reflection-to-destroy-singleton-pattern反射">6. Using Reflection to destroy Singleton Pattern（反射）</h5>
<p>反射会破坏单例模式，下面例子生成的hashcode是不同的，感兴趣的可以试试。</p>
<pre><code class="language-Using"> public static void main(String[] args) {
        EagerInitialization instanceOne = EagerInitialization.getInstance();
        EagerInitialization instanceTwo = null;
        try {
            Constructor[] constructors = EagerInitialization.class.getDeclaredConstructors();
            for (Constructor constructor : constructors) {
                constructor.setAccessible(true);
                instanceTwo = (EagerInitialization) constructor.newInstance();
                break;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(instanceOne.hashCode());
        System.out.println(instanceTwo.hashCode());
    }
</code></pre>
<h5 id="7-enum-singleton枚举">7. Enum Singleton（枚举）</h5>
<p>Java 确保任何枚举值在 Java 程序中仅被实例化一次。由于Java 枚举值是全局可访问的，因此单例也是如此。缺点是枚举类型有点不灵活；例如，它不允许延迟初始化。</p>
<pre><code class="language-Enum">public enum EnumSingleton {
    INSTANCE;

    public static void doSomething(){
        //do something
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RocketMq消息及其应用]]></title>
        <id>https://q456qq520.github.io/post/rocketmq/</id>
        <link href="https://q456qq520.github.io/post/rocketmq/">
        </link>
        <updated>2021-07-09T04:42:00.000Z</updated>
        <content type="html"><![CDATA[<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">一</mi><mi mathvariant="normal">、</mi><mi mathvariant="normal">延</mi><mi mathvariant="normal">迟</mi><mi mathvariant="normal">消</mi><mi mathvariant="normal">息</mi></mrow><annotation encoding="application/x-tex">一、延迟消息</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">、</span><span class="mord cjk_fallback">延</span><span class="mord cjk_fallback">迟</span><span class="mord cjk_fallback">消</span><span class="mord cjk_fallback">息</span></span></span></span><br>
定时消息（延迟队列）是指消息发送到broker后，不会立即被消费，等待特定时间投递给真正的topic。</p>
<p>broker有配置项messageDelayLevel，默认值为“<s>1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</s>”，18个level。<br>
配置自定义messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 10m 15m 20m 30m 1h 3h 6h 12h 24h</p>
<p>注意，messageDelayLevel是broker的属性，不属于某个topic。<br>
发消息时，设置delayLevel等级即可。level有以下三种情况：</p>
<ul>
<li>level == 0，消息为非延迟消息</li>
<li>1&lt;=level&lt;=maxLevel，消息延迟特定时间，例如level==1，延迟1s</li>
<li>level &gt; maxLevel，则level== maxLevel，例如level==20，延迟24h</li>
</ul>
<p>定时消息会暂存在名为SCHEDULE_TOPIC_XXXX的topic中，并根据delayTimeLevel存入特定的queue，queueId = delayTimeLevel – 1，即一个queue只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。broker会调度地消费SCHEDULE_TOPIC_XXXX，将消息写入真实的topic。</p>
<p>需要注意的是，定时消息会在第一次写入和调度写入真实topic时都会计数，因此发送数量、tps都会变高。</p>
<pre><code class="language-java">/**
   * 重试次数--延迟级别对应关系
   */
    static ConcurrentHashMap&lt;Integer,Integer&gt; retryTimeDelayLevelMap = new ConcurrentHashMap&lt;&gt;();
    static{
        retryTimeDelayLevelMap.put(1,5);//1min
        retryTimeDelayLevelMap.put(4,14);//1h
        retryTimeDelayLevelMap.put(2,7);//3min
        retryTimeDelayLevelMap.put(3,10);//10min
    }
//发送延迟消息
public void sendDelayNotify(VideoStateChangeEvent event) {
        try{
            if(event.getRetryTimes()&gt;4 || event.getRetryTimes()&lt;1){
                LOG.warn(&quot;仅仅支持重发4次 retryTimes:{}&quot;,event.getRetryTimes());
                return;
            }
            org.springframework.messaging.Message mmm = MessageBuilder.withPayload(event).build();
            ResultDTO r = rocketMQTemplate.syncSendDelay(mediaCallbackTopic + &quot;:&quot; + event.getEventType(), mmm, retryTimeDelayLevelMap.get(event.getRetryTimes()));
        }catch(Exception e){
            //dosomething
        }
    }
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">二</mi><mi mathvariant="normal">、</mi><mi mathvariant="normal">重</mi><mi mathvariant="normal">试</mi><mi mathvariant="normal">消</mi><mi mathvariant="normal">息</mi></mrow><annotation encoding="application/x-tex">二、重试消息</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">、</span><span class="mord cjk_fallback">重</span><span class="mord cjk_fallback">试</span><span class="mord cjk_fallback">消</span><span class="mord cjk_fallback">息</span></span></span></span><br>
Consumer消费消息失败后，要提供一种重试机制，令消息再消费一次。Consumer消费消息失败通常可以认为有以下几种情况：</p>
<p>由于消息本身的原因，例如反序列化失败，消息数据本身无法处理（例如话费充值，当前消息的手机号被注销，无法充值）等。这种错误通常需要跳过这条消息，再消费其它消息，而这条失败的消息即使立刻重试消费，99%也不成功，所以最好提供一种定时重试机制，即过10秒后再重试。<br>
由于依赖的下游应用服务不可用，例如db连接不可用，外系统网络不可达等。遇到这种错误，即使跳过当前失败的消息，消费其他消息同样也会报错。这种情况建议应用sleep 30s，再消费下一条消息，这样可以减轻Broker重试消息的压力。<br>
RocketMQ会为每个消费组都设置一个Topic名称为“%RETRY%+consumerGroup”的重试队列（这里需要注意的是，这个Topic的重试队列是针对消费组，而不是针对每个Topic设置的），用于暂时保存因为各种异常而导致Consumer端无法消费的消息。考虑到异常恢复起来需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有与之对应的重新投递延时，重试次数越多投递延时就越大。RocketMQ对于重试消息的处理是先保存至Topic名称为“SCHEDULE_TOPIC_XXXX”的延迟队列中，后台定时任务按照对应的时间进行Delay后重新保存至“%RETRY%+consumerGroup”的重试队列中。</p>
<pre><code class="language-java">/**
 * 消费者
 */
@Service
@RocketMQMessageListener(
        consumerGroup = &quot;${consumer}&quot;,
        topic = &quot;${topic}&quot;,
        selectorExpression = &quot;*&quot;)
public class CallbackTopicConsumer implements RocketMQListener&lt;MessageExt&gt;{(CallbackTopicConsumer.class);
    @Override
    public void onMessage(MessageExt msg) {
        try {
            byte[] bytes = msg.getBody();
            //dosomething
        }catch (MediaStorePlatformException e1){
            //对于特定异常类型，如果异常被catch后，没有往外抛，client认为消息已经被消费。
            //此时，消息会丢弃
          //dosomething
        }catch (Exception e) {
            //dosomething
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git冲突相关解决方案]]></title>
        <id>https://q456qq520.github.io/post/git/</id>
        <link href="https://q456qq520.github.io/post/git/">
        </link>
        <updated>2021-07-07T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>拉取远程分支失败，如果是git未忽略文件，可以cd至该工程目录下使用   <code>git rm --cached xxx.iml</code>删除完后再次尝试拉取。</p>
]]></content>
    </entry>
</feed>