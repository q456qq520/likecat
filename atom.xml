<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://q456qq520.github.io</id>
    <title>LIKE CAT</title>
    <updated>2022-03-09T09:03:29.824Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://q456qq520.github.io"/>
    <link rel="self" href="https://q456qq520.github.io/atom.xml"/>
    <subtitle>一条小咸鱼</subtitle>
    <logo>https://q456qq520.github.io/images/avatar.png</logo>
    <icon>https://q456qq520.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, LIKE CAT</rights>
    <entry>
        <title type="html"><![CDATA[分布式共识:存异求同]]></title>
        <id>https://q456qq520.github.io/post/fen-bu-shi-gong-shi-cun-yi-qiu-tong/</id>
        <link href="https://q456qq520.github.io/post/fen-bu-shi-gong-shi-cun-yi-qiu-tong/">
        </link>
        <updated>2022-03-08T01:54:54.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分布式事务Allornothing]]></title>
        <id>https://q456qq520.github.io/post/fen-bu-shi-shi-wu-allornothing/</id>
        <link href="https://q456qq520.github.io/post/fen-bu-shi-shi-wu-allornothing/">
        </link>
        <updated>2022-03-08T01:54:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="all-or-nothing">All or nothing</h1>
<h1 id="什么是分布式事务">什么是分布式事务？</h1>
<p>要想理解分布式事务，我们首先来看一下什么是事务。</p>
<p>事务，其实是包含一系列操作的、一个有边界的工作序列，有明确的开始和结束标志，且要么被完全执行，要么完全失败，即 all or nothing。通常情况下，我们所说的事务指的都是本地事务，也就是在单机上的事务。</p>
<p>而分布式事务，就是在分布式系统中运行的事务，由多个本地事务组合而成。在分布式场景下，对事务的处理操作可能来自不同的机器，甚至是来自不同的操作系统。</p>
<p>要深入理解分布式事务，我们首先需要了解它的特征。分布式事务是多个事务的组合，那么事务的特征 ACID，也是分布式事务的基本特征，其中 ACID 具体含义如下：</p>
<pre><code>1. 原子性（Atomicity），即事务最终的状态只有两种，全部执行成功和全部不执行。若处理事务的任何一项操作不成功，就会导致整个事务失败。一旦操作失败，所有操作都会被取消（即回滚），使得事务仿佛没有被执行过一样。

2. 一致性（Consistency），是指事务操作前和操作后，数据的完整性保持一致或满足完整性约束。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加200 元 ; 一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况 (该情况，用户 A 和 B 均为 600 元，总共 1200 元)。

3. 隔离性（Isolation），是指当系统内有多个事务并发执行时，多个事务不会相互干扰，
</code></pre>
<p>即一个事务内部的操作及使用的数据，对其他并发事务是隔离的。</p>
<pre><code>4. 持久性（Durability），也被称为永久性，是指一个事务完成了，那么它对数据库所做的更新就被永久保存下来了。即使发生系统崩溃或宕机等故障，只要数据库能够重新被访问，那么一定能够将其恢复到事务完成时的状态。
</code></pre>
<p>分布式事务基本能够满足 ACID，其中的 C 是强一致性，也就是所有操作均执行成功，才提交最终结果，以保证数据一致性或完整性。但随着分布式系统规模不断扩大，复杂度急剧上升，达成强一致性所需时间周期较长，限定了复杂业务的处理。为了适应复杂业务，出现了BASE 理论，该理论的一个关键点就是采用最终一致性代替强一致性。</p>
<h1 id="如何实现分布式事务">如何实现分布式事务？</h1>
<p>分布式事务主要是解决在分布式环境下，组合事务的一致性问题。实现分布式事务有以下 3 种基本方法：</p>
<pre><code>- 基于 XA 协议的二阶段提交协议方法；
- 三阶段提交协议方法；
- 基于消息的最终一致性方法。
</code></pre>
<p>其中，基于 XA 协议的二阶段提交协议方法和三阶段提交协议方法，采用了强一致性，遵从ACID，基于消息的最终一致性方法，采用了最终一致性，遵从 BASE 理论。</p>
<h1 id="什么是-base-理论">什么是 BASE 理论</h1>
<p>刚性事务，遵循 ACID 原则，具有强一致性。比如，数据库事务。</p>
<p>柔性事务，其实就是根据不同的业务场景使用不同的方法实现最终一致性，也就是说我们可以根据业务的特性做部分取舍，容忍一定时间内的数据不一致。</p>
<p>总结来讲，与刚性事务不同，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致。而柔性事务的最终一致性，遵循的是 BASE 理论。</p>
<p>BASE 理论包括基本可用（Basically Available）、柔性状态（Soft State）和最终一致性（Eventual Consistency）。</p>
<ol>
<li>基本可用：分布式系统出现故障的时候，允许损失一部分功能的可用性。</li>
<li>柔性状态：在柔性事务中，允许系统存在中间状态，且这个中间状态不会影响系统整体可用性。比如，数据库读写分离，写库同步到读库（主库同步到从库）会有一个延时，其实就是一种柔性状态。</li>
<li>最终一致性：事务在操作过程中可能会由于同步延迟等问题导致不一致，但最终状态下，数据都是一致的。</li>
</ol>
<p>BASE 理论为了支持大型分布式系统，通过牺牲强一致性，保证最终一致性，来获得高可用性，是对 ACID 原则的弱化。</p>
<h1 id="基于-xa-协议的二阶段提交方法">基于 XA 协议的二阶段提交方法</h1>
<p>XA 是一个分布式事务协议，规定了事务管理器和资源管理器接口。因此，XA 协议可以分为两部分，即事务管理器和本地资源管理器。</p>
<p>XA 实现分布式事务的原理，事务管理器作为协调者，负责各个本地资源的提交和回滚；而资源管理器就是分布式事务的参与者，通常由数据库实现。</p>
<p>基于 XA 协议的二阶段提交方法中，<strong>二阶段提交协议（The two-phase commit protocol，2PC）</strong>，用于保证分布式系统中事务提交时的数据一致性，是 XA 在全局事务中用于协调多个资源的机制。</p>
<p>那么，两阶段提交协议如何保证分布在不同节点上的分布式事务的一致性呢？为了保证它们的一致性，我们需要引入一个协调者来管理所有的节点，并确保这些节点正确提交操作结果，若提交失败则放弃事务。接下来，我们看看两阶段提交协议的具体过程。两阶段提交协议的执行过程，分为投票（voting）和提交（commit）两个阶段。</p>
<p><strong>投票</strong>为第一阶段，协调者（Coordinator，即事务管理器）会向事务的参与者（Cohort，即本地资源管理器）发起执行操作的 CanCommit 请求，并等待参与者的响应。参与者接收到请求后，会执行请求中的事务操作，记录日志信息但不提交，待参与者执行成功，则向协调者发送“Yes”消息，表示同意操作；若不成功，则发送“No”消息，表示终止操作。</p>
<p>当所有的参与者都返回了操作结果（Yes 或 No 消息）后，系统进入了提交阶段。在提交阶段，协调者会根据所有参与者返回的信息向参与者发送 DoCommit 或 DoAbort 指令：</p>
<p>若协调者收到的都是“Yes”消息，则向参与者发送“DoCommit”消息，参与者会完成剩余的操作并释放资源，然后向协调者返回“HaveCommitted”消息；</p>
<p>如果协调者收到的消息中包含“No”消息，则向所有参与者发送“DoAbort”消息，此时发送“Yes”的参与者则会根据之前执行操作时的回滚日志对操作进行回滚，然后所有参与者会向协调者发送“HaveCommitted”消息；<br>
协调者接收到“HaveCommitted”消息，就意味着整个事务结束了。</p>
<p>二阶段提交的算法思路可以概括为：<strong>协调者下发请求事务操作，参与者将操作结果通知协调者，协调者根据所有参与者的反馈结果决定各参与者是要提交操作还是撤销操作。</strong></p>
<p>虽然基于 XA 的二阶段提交算法基本满足了事务的 ACID 特性，但依然有些不足。</p>
<pre><code>1. 同步阻塞问题：二阶段提交算法在执行过程中，所有参与节点都是事务阻塞型的。也就是说，当本地资源管理器占有临界资源时，其他资源管理器如果要访问同一临界资源，会处于阻塞状态。

2. 单点故障问题：基于 XA 的二阶段提交算法类似于集中式算法，一旦事务管理器发生故障，整个系统都处于停滞状态。尤其是在提交阶段，一旦事务管理器发生故障，资源管理器会由于等待管理器的消息，而一直锁定事务资源，导致整个系统被阻塞。

3. 数据不一致问题：在提交阶段，当协调者向参与者发送 DoCommit 请求之后，如果发生了局部网络异常，或者在发送提交请求的过程中协调者发生了故障，就会导致只有一部分参与者接收到了提交请求并执行提交操作，但其他未接到提交请求的那部分参与者则无法执行事务提交。于是整个分布式系统便出现了数据不一致的问题。
</code></pre>
<h1 id="三阶段提交方法">三阶段提交方法</h1>
<p>三阶段提交协议（Three-phase commit protocol，3PC），是对二阶段提交（2PC）的改进。为了解决两阶段提交的同步阻塞和数据不一致问题，三阶段提交引入了<strong>超时机制</strong>和<strong>准备阶段</strong>。</p>
<p>同时在协调者和参与者中引入超时机制。<strong>如果协调者或参与者在规定的时间内没有接收到来自其他节点的响应，就会根据当前的状态选择提交或者终止整个事务</strong>。</p>
<p><strong>在第一阶段和第二阶段中间引入了一个准备阶段</strong>，也就是在提交阶段之前，加入了一个预提交阶段。在预提交阶段排除一些不一致的情况，保证在最后提交之前各参与节点的状态是一致的。</p>
<p>也就是说，除了引入超时机制之外，3PC 把 2PC 的提交阶段一分为二，这样三阶段提交协议就有 CanCommit、PreCommit、DoCommit 三个阶段。</p>
<h2 id="第一cancommit-阶段">第一，CanCommit 阶段。</h2>
<p>CanCommit 阶段与 2PC 的投票阶段类似：协调者向参与者发送请求操作（CanCommit请求），询问参与者是否可以执行事务提交操作，然后等待参与者的响应；参与者收到CanCommit 请求之后，回复 Yes，表示可以顺利执行事务；否则回复 No。</p>
<p>CanCommit 阶段不同节点之间的事务请求成功和失败的流程，如下所示。</p>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1646725943605.png" alt="3pc第一阶段" loading="lazy"></figure>
<h2 id="第二precommit-阶段">第二，PreCommit 阶段。</h2>
<p>协调者根据参与者的回复情况，来决定是否可以进行 PreCommit 操作</p>
<p>如果所有参与者回复的都是“Yes”，那么协调者就会执行事务的预执行：</p>
<pre><code>- 发送预提交请求。协调者向参与者发送 PreCommit 请求，进入预提交阶段。
- 事务预提交。参与者接收到 PreCommit 请求后执行事务操作，并将 Undo 和 Redo信息记录到事务日志中。
- 响应反馈。如果参与者成功执行了事务操作，则返回 ACK 响应，同时开始等待最终指令。
</code></pre>
<p>假如任何一个参与者向协调者发送了“No”消息，或者等待超时之后，协调者都没有收到参与者的响应，就执行中断事务的操作：</p>
<pre><code> - 发送中断请求。协调者向所有参与者发送“Abort”消息。
 - 终断事务。参与者收到“Abort”消息之后，或超时后仍未收到协调者的消息，执行事务的终断操作。
</code></pre>
<p>预执行阶段，不同节点上事务执行成功和失败的流程，如下所示。</p>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1646726217417.png" alt="3pc2阶段" loading="lazy"></figure>
<h2 id="第三docommit-阶段">第三，DoCommit 阶段。</h2>
<p>DoCmmit 阶段进行真正的事务提交，根据 PreCommit 阶段协调者发送的消息，进入执行提交阶段或事务中断阶段。</p>
<ul>
<li>
<p><strong>执行提交阶段</strong>：</p>
<ul>
<li>发送提交请求。协调者接收到所有参与者发送的 Ack 响应，从预提交状态进入到提交状态，并向所有参与者发送 DoCommit 消息。</li>
<li>事务提交。参与者接收到 DoCommit 消息之后，正式提交事务。完成事务提交之后，释放所有锁住的资源。</li>
<li>响应反馈。参与者提交完事务之后，向协调者发送 Ack 响应。</li>
<li>完成事务。协调者接收到所有参与者的 Ack 响应之后，完成事务。</li>
</ul>
</li>
<li>
<p><strong>事务中断阶段</strong>：</p>
<ul>
<li>发送中断请求。协调者向所有参与者发送 Abort 请求。</li>
<li>事务回滚。参与者接收到 Abort 消息之后，利用其在 PreCommit 阶段记录的 Undo信息执行事务的回滚操作，并释放所有锁住的资源。</li>
<li>反馈结果。参与者完成事务回滚之后，向协调者发送 Ack 消息。</li>
<li>终断事务。协调者接收到参与者反馈的 Ack 消息之后，执行事务的终断，并结束事务。</li>
</ul>
</li>
</ul>
<p>执行阶段不同节点上事务执行成功和失败 (事务终断) 的流程，如下所示。</p>
<figure data-type="image" tabindex="3"><img src="https://q456qq520.github.io/post-images/1646729143957.png" alt="3pc3阶段" loading="lazy"></figure>
<p>在 DoCommit 阶段，当参与者向协调者发送 Ack 消息后，如果长时间没有得到协调者的响应，在默认情况下，参与者会自动将超时的事务进行提交，不会像两阶段提交那样被阻塞住。</p>
<h1 id="基于分布式消息的最终一致性方案">基于分布式消息的最终一致性方案</h1>
<p>2PC 和 3PC 这两种方法，有两个共同的缺点，一是都需要锁定资源，降低系统性能；二是，没有解决数据不一致的问题。因此，便有了通过分布式消息来确保事务最终一致性的方案。</p>
<p>在 eBay 的分布式系统架构中，架构师解决一致性问题的核心思想就是：将需要分布式处理的事务通过消息或者日志的方式异步执行，消息或日志可以存到本地文件、数据库或消息队列中，再通过业务规则进行失败重试。这个案例，就是使用基于<strong>分布式消息的最终一致性方案</strong>解决了分布式事务的问题。</p>
<p>基于分布式消息的最终一致性方案的事务处理，引入了一个消息中间件（MessageQueue，MQ），用于在多个应用之间进行消息传递。</p>
<p>基于消息中间件协商多个节点分布式事务执行操作的示意图，如下所示。</p>
<figure data-type="image" tabindex="4"><img src="https://q456qq520.github.io/post-images/1646813542498.png" alt="最终一致性示意图" loading="lazy"></figure>
<p>以网上购物为例。假设用户 A 在某电商平台下了一个订单，需要支付 50 元，发现自己的账户余额共 150 元，就使用余额支付，支付成功之后，订单状态修改为支付成功，然后通知仓库发货。</p>
<p>在该事件中，涉及到了订单系统、支付系统、仓库系统，这三个系统是相互独立的应用，通过远程服务进行调用。</p>
<figure data-type="image" tabindex="5"><img src="https://q456qq520.github.io/post-images/1646813778051.png" alt="最终一致性时序图" loading="lazy"></figure>
<p>根据基于分布式消息的最终一致性方案，用户 A 通过终端手机首先在订单系统上操作，然后整个购物的流程如下所示。</p>
<figure data-type="image" tabindex="6"><img src="https://q456qq520.github.io/post-images/1646813800623.png" alt="最终一致性流程图" loading="lazy"></figure>
<ol>
<li>订单系统把订单消息发给消息中间件，消息状态标记为“待确认”。</li>
<li>消息中间件收到消息后，进行消息持久化操作，即在消息存储系统中新增一条状态为“待发送”的消息。</li>
<li>消息中间件返回消息持久化结果（成功 / 失败），订单系统根据返回结果判断如何进行业务操作。失败，放弃订单，结束（必要时向上层返回失败结果）；成功，则创建订单。</li>
<li>订单操作完成后，把操作结果（成功 / 失败）发送给消息中间件。</li>
<li>消息中间件收到业务操作结果后，根据结果进行处理：失败，删除消息存储中的消息，结束；成功，则更新消息存储中的消息状态为“待发送（可发送）”，并执行消息投递。</li>
<li>如果消息状态为“可发送”，则 MQ 会将消息发送给支付系统，表示已经创建好订单，需要对订单进行支付。支付系统也按照上述方式进行订单支付操作。</li>
<li>订单系统支付完成后，会将支付消息返回给消息中间件，中间件将消息传送给订单系统。订单系统再调用库存系统，进行出货操作。</li>
</ol>
<p>分布式事务中，当且仅当所有的事务均成功时整个流程才成功。所以，<strong>分布式事务的一致性是实现分布式事务的关键问题，目前来看还没有一种很简单、完美的方案可以应对所有场景</strong>。</p>
<h1 id="三种实现方式对比">三种实现方式对比</h1>
<figure data-type="image" tabindex="7"><img src="https://q456qq520.github.io/post-images/1646813912330.png" alt="分布式事务对比图" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分布式锁]]></title>
        <id>https://q456qq520.github.io/post/fen-bu-shi-shi-wu/</id>
        <link href="https://q456qq520.github.io/post/fen-bu-shi-shi-wu/">
        </link>
        <updated>2022-03-08T01:54:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="为什么要使用分布锁">为什么要使用分布锁？</h1>
<h2 id="什么是锁">什么是锁</h2>
<p>在单机多线程环境中，我们经常遇到多个线程访问同一个共享资源（这里需要注意的是：在很多地方，这种资源会称为临界资源，也称之为共享资源）的情况。为了维护数据的一致性，我们需要某种机制来保证只有满足某个条件的线程才能访问资源，不满足条件的线程只能等待，在下一轮竞争中重新满足条件时才能访问资源。</p>
<p>这个机制指的是，为了实现分布式互斥，在某个地方做个标记，这个标记每个线程都能看到，到标记不存在时可以设置该标记，当标记被设置后，其他线程只能等待拥有该标记的线程执行完成，并释放该标记后，才能去设置该标记和访问共享资源。这里的标记，就是我们常说的锁。</p>
<p>也就是说，<strong>锁是实现多线程同时访问同一共享资源，保证同一时刻只有一个线程可访问共享资源所做的一种标记</strong>。</p>
<p>与普通锁不同的是，<strong>分布式锁</strong>是指分布式环境下，系统部署在多个机器中，实现多进程分布式互斥的一种锁。为了保证多个进程能看到锁，锁被存在公共存储（比如 Redis、Memcache、数据库等三方存储中），以实现多个进程并发访问同一个临界资源，同一时刻只有一个进程可访问共享资源，确保数据的一致性。</p>
<h1 id="分布式锁的三种实现方法及对比">分布式锁的三种实现方法及对比</h1>
<p>接下来，我带你看看实现分布式锁的 3 种主流方法，即：</p>
<pre><code>1. 基于数据库实现分布式锁，这里的数据库指的是关系型数据库；

2. 基于缓存实现分布式锁；

3. 基于 ZooKeeper 实现分布式锁。
</code></pre>
<h2 id="基于数据库实现分布式锁">基于数据库实现分布式锁</h2>
<p>要实现分布式锁，最简单的方式就是创建一张锁表，然后通过操作该表中的数据来实现。</p>
<p>当我们要锁住某个资源时，就在该表中增加一条记录，想要释放锁的时候就删除这条记录。数据库对共享资源做了唯一性约束，如果有多个请求被同时提交到数据库的话，数据库会保证只有一个操作可以成功，操作成功的那个线程就获得了访问共享资源的锁，可以进行操作。</p>
<p>基于数据库实现的分布式锁，是最容易理解的。但是，因为数据库需要落到硬盘上，频繁读取数据库会导致 IO 开销大，因此这种分布式锁适用于并发量低，对性能要求低的场景。对于双 11、双 12 等需求量激增场景，数据库锁是无法满足其性能要求的。而在平日的购物中，我们可以在局部场景中使用数据库锁实现对资源的互斥访问。</p>
<p>以电商售卖吹风机的场景为例。吹风机库存是 2 个，有 5 个来自不同地区的用户{A,B,C,D,E}想要购买，其中用户 A 想买 1 个，用户 B 想买 2 个，用户 C 想买 1个。</p>
<p>用户 A 和用户 B 几乎同时下单，但用户 A 的下单请求最先到达服务器。因此，该商家的产品数据库中增加了一条关于用户 A 的记录，用户 A 获得了锁，他的订单请求被处理，服务器修改吹风机库存数，减去 1 后还剩下 1 个。</p>
<p>当用户 A 的订单请求处理完成后，有关用户 A 的记录被删除，服务器开始处理用户 B 的订单请求。这时，库存只有 1 个了，无法满足用户 B 的订单需求，因此用户 B 购买失败。从数据库中，删除用户 B 的记录，服务器开始处理用户 C 的订单请求，库存中 1 个吹风机满足用户 C 的订单需求。所以，数据库中增加了一条关于用户 C 的记录，用户 C 获得了锁，他的订单请求被处理，服务器修改吹风机数量，减去 1 后还剩下 0 个。</p>
<p><strong>基于数据库实现分布式锁比较简单，主要在于创建一张锁表，为申请者在锁表里建立一条记录，记录建立成功则获得锁，消除记录则释放锁</strong>。该方法依赖于数据库，主要有两个缺点：</p>
<pre><code>1. 单点故障问题。一旦数据库不可用，会导致整个系统崩溃。

2. 死锁问题。数据库锁没有失效时间，未获得锁的进程只能一直等待已获得锁的进程主动释放锁。一旦已获得锁的进程挂掉或者解锁操作失败，会导致锁记录一直存在数据库中，其他进程无法获得锁。
</code></pre>
<h2 id="基于缓存实现分布式锁">基于缓存实现分布式锁</h2>
<p>基于缓存实现分布式锁的方式。所谓基于缓存，也就是说把数据存放在计算机内存中，不需要写入磁盘，减少了 IO 读写。</p>
<p>Redis 通常可以使用 setnx(key, value) 函数来实现分布式锁。key 和 value 就是基于缓存的分布式锁的两个属性，其中 key 表示锁 id，value = currentTime + timeOut，表示当前时间 + 超时时间。也就是说，某个进程获得 key 这把锁后，如果在 value 的时间内未释放锁，系统就会主动释放锁。</p>
<p>setnx 函数的返回值有 0 和 1：</p>
<p>返回 1，说明该服务器获得锁，setnx 将 key 对应的 value 设置为当前时间 + 锁的有效时间。</p>
<p>返回 0，说明其他服务器已经获得了锁，进程不能进入临界区。该服务器可以不断尝试setnx 操作，以获得锁。</p>
<p>以电商售卖吹风机的场景为例，和你说明基于缓存实现的分布式锁，假设现在库存数量是足够的。</p>
<p>用户 A 的请求因为网速快，最先到达 Server2，setnx 操作返回 1，并获取到购买吹风机的锁；用户 B 和用户 C 的请求，几乎同时到达了 Server1 和 Server3，但因为这时 Server2获取到了吹风机数据的锁，所以只能加入等待队列。</p>
<p>Server2 获取到锁后，负责管理吹风机的服务器执行业务逻辑，只用了 1s 就完成了订单。订单请求完成后，删除锁的 key，从而释放锁。此时，排在第二顺位的 Server1 获得了锁，可以访问吹风机的数据资源。但不巧的是，Server1 在完成订单后发生了故障，无法主动释放锁。</p>
<p>于是，排在第三顺位的 Server3 只能等设定的有效时间（比如 30 分钟）到期，锁自动释放后，才能访问吹风机的数据资源，也就是说用户 C 只能到 00:30:01 以后才能继续抢购。</p>
<p>Redis 通过队列来维持进程访问共享资源的先后顺序。Redis 锁主要基于 setnx函数实现分布式锁，当进程通过 setnx&lt;key,value&gt; 函数返回 1 时，表示已经获得锁。排在后面的进程只能等待前面的进程主动释放锁，或者等到时间超时才能获得锁。</p>
<p>相对于基于数据库实现分布式锁的方案来说，基于缓存实现的分布式锁的优势表现在以下几个方面：</p>
<pre><code>1. 性能更好。数据被存放在内存，而不是磁盘，避免了频繁的 IO 操作。

2. 很多缓存可以跨集群部署，避免了单点故障问题。

3. 很多缓存服务都提供了可以用来实现分布式锁的方法，比如 Redis 的 setnx 方法等。可以直接设置超时时间来控制锁的释放，因为这些缓存服务器一般支持自动删除过期数据。
</code></pre>
<p>这个方案的不足是，通过超时时间来控制锁的失效时间，并不是十分靠谱，因为一个进程执行时间可能比较长，或受系统进程做内存回收等影响，导致时间超时，从而不正确地释放了锁。</p>
<h2 id="基于-zookeeper-实现分布式锁">基于 ZooKeeper 实现分布式锁</h2>
<p>ZooKeeper 基于树形数据存储结构实现分布式锁，来解决多个进程同时访问同一临界资源时，数据的一致性问题。ZooKeeper 的树形数据存储结构主要由 4 种节点构成：</p>
<pre><code>1. 持久节点。这是默认的节点类型，一直存在于 ZooKeeper 中。

2. 持久顺序节点。也就是说，在创建节点时，ZooKeeper 根据节点创建的时间顺序对节点进行编号。

3. 临时节点。与持久节点不同，当客户端与 ZooKeeper 断开连接后，该进程创建的临时节点就会被删除。

4. 临时顺序节点，就是按时间顺序编号的临时节点。
</code></pre>
<p>根据它们的特征，ZooKeeper 基于临时顺序节点实现了分布锁。</p>
<p>还是以电商售卖吹风机的场景为例。假设用户 A、B、C 同时在 11 月 11 日的零点整提交了购买吹风机的请求，ZooKeeper 会采用如下方法来实现分布式锁：</p>
<ol>
<li>
<p>在与该方法对应的持久节点 shared_lock 的目录下，为每个进程创建一个临时顺序节点。吹风机就是一个拥有 shared_lock 的目录，当有人买吹风机时，会为他创建一个临时顺序节点。</p>
</li>
<li>
<p>每个进程获取 shared_lock 目录下的所有临时节点列表，注册子节点变更的Watcher，并监听节点。</p>
</li>
<li>
<p>每个节点确定自己的编号是否是 shared_lock 下所有子节点中最小的，若最小，则获得锁。例如，用户 A 的订单最先到服务器，因此创建了编号为 1 的临时顺序节点LockNode1。该节点的编号是持久节点目录下最小的，因此获取到分布式锁，可以访问临界资源，从而可以购买吹风机。</p>
</li>
<li>
<p>若本进程对应的临时节点编号不是最小的，则分为两种情况：</p>
<p>a. 本进程为读请求，如果比自己序号小的节点中有写请求，则等待；</p>
<p>b. 本进程为写请求，如果比自己序号小的节点中有读请求，则等待。</p>
</li>
</ol>
<p>例如，用户 B 也想要买吹风机，但在他之前，用户 C 想看看吹风机的库存量。因此，用户B 只能等用户 A 买完吹风机、用户 C 查询完库存量后，才能购买吹风机。</p>
<p>使用 ZooKeeper 可以完美解决设计分布式锁时遇到的各种问题，比如单点故障、不可重入、死锁等问题。虽然 ZooKeeper 实现的分布式锁，几乎能涵盖所有分布式锁的特性，且易于实现，但需要频繁地添加和删除节点，所以性能不如基于缓存实现的分布式锁。</p>
<table>
<thead>
<tr>
<th>特征</th>
<th style="text-align:center">对比</th>
</tr>
</thead>
<tbody>
<tr>
<td>理解的容易程度</td>
<td style="text-align:center">数据库&gt;缓存&gt;zk</td>
</tr>
<tr>
<td>实现复杂性</td>
<td style="text-align:center">zk&gt;=缓存&gt;数据库</td>
</tr>
<tr>
<td>性能</td>
<td style="text-align:center">缓存&gt;zk&gt;=数据库</td>
</tr>
<tr>
<td>可靠性</td>
<td style="text-align:center">zk&gt;缓存&gt;数据库</td>
</tr>
</tbody>
</table>
<p>ZooKeeper 分布式锁的可靠性最高，有封装好的框架，很容易实现分布式锁的功能，并且几乎解决了数据库锁和缓存式锁的不足，因此是实现分布式锁的首选方法。</p>
<p>为了确保分布式锁的可用性，我们在设计时应考虑到以下几点：</p>
<pre><code>1. 互斥性，即在分布式系统环境下，分布式锁应该能保证一个资源或一个方法在同一时间只能被一个机器的一个线程或进程操作。

2. 具备锁失效机制，防止死锁。即使有一个进程在持有锁的期间因为崩溃而没有主动解锁，也能保证后续其他进程可以获得锁。

3. 可重入性，即进程未释放锁时，可以多次访问临界资源。

4. 有高可用的获取锁和释放锁的功能，且性能要好。
</code></pre>
<h1 id="如何解决分布式锁的羊群效应问题">如何解决分布式锁的羊群效应问题？</h1>
<p>在分布式锁问题中，会经常遇到羊群效应。所谓羊群效应，就是在整个分布式锁的竞争过程中，大量的“Watcher 通知”和“子节点列表的获取”操作重复运行，并且大多数节点的运行结果都是判断出自己当前并不是编号最小的节点，继续等待下一次通知，而不是执行业务逻辑。</p>
<p>这，就会对 ZooKeeper 服务器造成巨大的性能影响和网络冲击。更甚的是，如果同一时间多个节点对应的客户端完成事务或事务中断引起节点消失，ZooKeeper 服务器就会在短时间内向其他客户端发送大量的事件通知。</p>
<p>那如何解决这个问题呢？具体方法可以分为以下三步。</p>
<ol>
<li>
<p>在与该方法对应的持久节点的目录下，为每个进程创建一个临时顺序节点。</p>
</li>
<li>
<p>每个进程获取所有临时节点列表，对比自己的编号是否最小，若最小，则获得锁。</p>
</li>
<li>
<p>若本进程对应的临时节点编号不是最小的，则继续判断：</p>
<p>a. 若本进程为读请求，则向比自己序号小的最后一个写请求节点注册 watch 监听，当监听到该节点释放锁后，则获取锁；</p>
<p>b. 若本进程为写请求，则向比自己序号小的最后一个读请求节点注册 watch 监听，当监听到该节点释放锁后，获取锁。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 分布式选举]]></title>
        <id>https://q456qq520.github.io/post/fen-bu-shi-xuan-ju/</id>
        <link href="https://q456qq520.github.io/post/fen-bu-shi-xuan-ju/">
        </link>
        <updated>2022-03-07T11:24:59.000Z</updated>
        <content type="html"><![CDATA[<h1 id="为什么要有分布式选举">为什么要有分布式选举？</h1>
<p>主节点，在一个分布式集群中负责对其他节点的协调和管理，也就是说，其他节点都必须听从主节点的安排。</p>
<p>主节点的存在，就可以保证其他节点的有序运行，以及数据库集群中的写入数据在每个节点上的一致性。这里的一致性是指，数据在每个集群节点中都是一样的，不存在不同的情况。当然，如果主故障了，集群就会天下大乱，就好比一个国家的皇帝驾崩了，国家大乱一样。比如，数据库集群中主节点故障后，可能导致每个节点上的数据会不一致。</p>
<p>这，就应了那句话“国不可一日无君”，对应到分布式系统中就是“集群不可一刻无主”。总结来说，选举的作用就是选出一个主节点，由它来协调和管理其他节点，以保证集群有序运行和节点间数据的一致性。</p>
<h1 id="分布式选举的算法">分布式选举的算法</h1>
<p>目前常见的选主方法有基于序号选举的算法（ 比如，Bully 算法）、多数派算法（比如，Raft 算法、ZAB 算法）等。</p>
<h1 id="bully-算法">Bully 算法</h1>
<p>Bully 算法是一种集群选主算法，因为它的选举原则是“长者”为大，即在所有活着的节点中，选取 ID 最大的节点作为主节点。</p>
<p>在 Bully 算法中，节点的角色有两种：普通节点和主节点。初始化时，所有节点都是平等的，都是普通节点，并且都有成为主的权利。但是，当选主成功后，有且仅有一个节点成为主节点，其他所有节点都是普通节点。当且仅当主节点故障或与其他节点失去联系后，才会重新选主。</p>
<p>Bully 算法在选举过程中，需要用到以下 3 种消息：</p>
<pre><code>1. Election 消息，用于发起选举；
2. Alive 消息，对 Election 消息的应答；
3. Victory 消息，竞选成功的主节点向其他节点发送的宣誓主权的消息。
</code></pre>
<p>Bully 算法选举的原则是“长者为大”，意味着它的假设条件是，集群中每个节点均知道其他节点的 ID。在此前提下，其具体的选举过程是：</p>
<ol>
<li>集群中每个节点判断自己的 ID 是否为当前活着的节点中 ID 最大的，如果是，则直接向其他节点发送 Victory 消息，宣誓自己的主权；</li>
<li>如果自己不是当前活着的节点中 ID 最大的，则向比自己 ID 大的所有节点发送Election 消息，并等待其他节点的回复；</li>
<li>若在给定的时间范围内，本节点没有收到其他节点回复的 Alive 消息，则认为自己成为主节点，并向其他节点发送 Victory 消息，宣誓自己成为主节点；若接收到来自比自己ID 大的节点的 Alive 消息，则等待其他节点发送 Victory 消息；</li>
<li>若本节点收到比自己 ID 小的节点发送的 Election 消息，则回复一个 Alive 消息，告知其他节点，我比你大，重新选举。</li>
</ol>
<p>目前已经有很多开源软件采用了 Bully 算法进行选主，比如 MongoDB 的副本集故障转移功能。MongoDB 的分布式选举中，采用节点的最后操作时间戳来表示 ID，时间戳最新的节点其 ID 最大，也就是说时间戳最新的、活着的节点是主节点。</p>
<p>小结一下。Bully 算法的选择特别霸道和简单，谁活着且谁的 ID 最大谁就是主节点，其他节点必须无条件服从。这种算法的优点是，选举速度快、算法复杂度低、简单易实现。</p>
<p>但这种算法的缺点在于，需要每个节点有全局的节点信息，因此额外信息存储较多；其次，任意一个比当前主节点 ID 大的新节点或节点故障后恢复加入集群的时候，都可能会触发重新选举，成为新的主节点，如果该节点频繁退出、加入集群，就会导致频繁切主。</p>
<h1 id="raft-算法">Raft 算法</h1>
<p>Raft 算法是典型的多数派投票选举算法，其选举机制与我们日常生活中的民主投票机制类似，核心思想是“<strong>少数服从多数</strong>”。也就是说，Raft 算法中，获得投票最多的节点成为主。</p>
<p>采用 Raft 算法选举，集群节点的角色有 3 种：</p>
<pre><code>- **Leader**，即主节点，同一时刻只有一个 Leader，负责协调和管理其他节点；

- **Candidate**，即候选者，每一个节点都可以成为 Candidate，节点在该角色下才可以被

    选为新的 Leader；

- **Follower**，Leader 的跟随者，不可以发起选举。
</code></pre>
<p>Raft 选举的流程，可以分为以下几步：</p>
<ol>
<li>初始化时，所有节点均为 Follower 状态。</li>
<li>开始选主时，所有节点的状态由 Follower 转化为 Candidate，并向其他节点发送选举请求。</li>
<li>其他节点根据接收到的选举请求的先后顺序，回复是否同意成为主。这里需要注意的<br>
是，在每一轮选举中，一个节点只能投出一张票。</li>
<li>若发起选举请求的节点获得超过一半的投票，则成为主节点，其状态转化为 Leader，<br>
其他节点的状态则由 Candidate 降为 Follower。Leader 节点与 Follower 节点之间会<br>
定期发送心跳包，以检测主节点是否活着。</li>
<li>当 Leader 节点的任期到了，即发现其他服务器开始下一轮选主周期时，Leader 节点<br>
的状态由 Leader 降级为 Follower，进入新一轮选主。</li>
</ol>
<p><strong>每一轮选举，每个节点只能投一次票。</strong></p>
<p>小结一下。Raft 算法具有选举速度快、算法复杂度低、易于实现的优点；缺点是，它要求系统内每个节点都可以相互通信，且需要获得过半的投票数才能选主成功，因此通信量大。该算法选举稳定性比 Bully 算法好，这是因为当有新节点加入或节点故障恢复后，会触发选主，但不一定会真正切主，除非新节点或故障后恢复的节点获得投票数过半，才会导致切主。</p>
<h2 id="扩展">扩展</h2>
<p>两主的情况出现在集群因为网络原因，被划分了两部分局部可通信的区域。下面的链接详细讲解了Raft算法，及双主出现后集群是如何恢复的。<br>
https://www.infoq.cn/article/coreos-analyse-etcd/</p>
<p>还有一个Raft算法动画链接<br>
http://thesecretlivesofdata.com/raft/#election</p>
<p>一文搞懂Raft算法<br>
https://www.cnblogs.com/xybaby/p/10124083.html</p>
<h1 id="具有优先级的民主投票zab-算法">具有优先级的民主投票：ZAB 算法</h1>
<p>ZAB（ZooKeeper Atomic Broadcast）选举算法是为 ZooKeeper 实现分布式协调功能而设计的。相较于 Raft 算法的投票机制，ZAB 算法增加了通过节点 ID 和数据 ID 作为参考进行选主，节点 ID 和数据 ID 越大，表示数据越新，优先成为主。相比较于 Raft 算法，ZAB 算法尽可能保证数据的最新性。所以，ZAB 算法可以说是对 Raft 算法的改进。</p>
<p>使用 ZAB 算法选举时，集群中每个节点拥有 3 种角色：</p>
<pre><code>- ** Leader**，主节点；
- **Follower**，跟随者节点；
- **Observer**，观察者，无投票权。
</code></pre>
<p>选举过程中，集群中的节点拥有 4 个状态：</p>
<pre><code>- **Looking**状态，即选举状态。当节点处于该状态时，它会认为当前集群中没有 Leader，因此自己进入选举状态。
- **Leading**状态，即领导者状态，表示已经选出主，且当前节点为 Leader。
- **Following**状态，即跟随者状态，集群中已经选出主后，其他非主节点状态更新为Following，表示对 Leader 的追随。
- **Observing**状态，即观察者状态，表示当前节点为 Observer，持观望态度，没有投票权和选举权。
</code></pre>
<p>投票过程中，每个节点都有一个唯一的三元组 (server_id, server_zxID, epoch)，其中server_id 表示本节点的唯一 ID；server_zxID 表示本节点存放的数据 ID，数据 ID 越大表示数据越新，选举权重越大；epoch 表示当前选取轮数，一般用逻辑时钟表示。</p>
<p>ZAB 选举算法的核心是“少数服从多数，ID 大的节点优先成为主”，因此选举过程中通过(vote_id, vote_zxID) 来表明投票给哪个节点，其中 vote_id 表示被投票节点的 ID，vote_zxID 表示被投票节点的服务器 zxID。ZAB 算法选主的原则是：<strong>server_zxID 最大者成为 Leader；若 server_zxID 相同，则 server_id 最大者成为 Leader。</strong></p>
<p>接下来，我以 3 个 Server 的集群为例，此处每个 Server 代表一个节点，与你介绍 ZAB 选主的过程。</p>
<p>第一步：当系统刚启动时，3 个服务器当前投票均为第一轮投票，即 epoch=1，且 zxID均为 0。此时每个服务器都推选自己，并将选票信息 &lt;epoch, vote_id, vote_zxID&gt; 广播出去。</p>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1646703805954.png" alt="zab1" loading="lazy"></figure>
<p>第二步：根据判断规则，由于 3 个 Server 的 epoch、zxID 都相同，因此比较 server_id，较大者即为推选对象，因此 Server 1 和 Server 2 将 vote_id 改为 3，更新自己的投票箱并重新广播自己的投票。</p>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1646703819106.png" alt="zab2" loading="lazy"></figure>
<p>第三步：此时系统内所有服务器都推选了 Server 3，因此 Server 3 当选 Leader，处于Leading 状态，向其他服务器发送心跳包并维护连接；Server1 和 Server2 处于Following 状态。</p>
<figure data-type="image" tabindex="3"><img src="https://q456qq520.github.io/post-images/1646703831617.png" alt="zab3" loading="lazy"></figure>
<p>小结一下。ZAB 算法性能高，对系统无特殊要求，采用广播方式发送信息，若节点中有 n个节点，每个节点同时广播，则集群中信息量为 n*(n-1) 个消息，容易出现广播风暴；且除了投票，还增加了对比节点 ID 和数据 ID，这就意味着还需要知道所有节点的 ID 和数据ID，所以选举时间相对较长。但该算法选举稳定性比较好，当有新节点加入或节点故障恢复后，会触发选主，但不一定会真正切主，除非新节点或故障后恢复的节点数据 ID 和节点ID 最大，且获得投票数过半，才会导致切主。</p>
<p>#三种选举算法的对比分析</p>
<figure data-type="image" tabindex="4"><img src="https://q456qq520.github.io/post-images/1646703947766.png" alt="算法对比1" loading="lazy"></figure>
<h1 id="为什么多数派选主算法通常采用奇数节点而不是偶数节点呢">为什么“多数派”选主算法通常采用奇数节点，而不是偶数节点呢？</h1>
<p>多数派选主算法的核心是少数服从多数，获得投票多的节点胜出。想象一下，如果现在采用偶数节点集群，当两个节点均获得一半投票时，到底应该选谁为主呢？</p>
<p>答案是，在这种情况下，无法选出主，必须重新投票选举。但即使重新投票选举，两个节点拥有相同投票数的概率也会很大。因此，多数派选主算法通常采用奇数节点。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分布式互斥]]></title>
        <id>https://q456qq520.github.io/post/fen-bu-shi-hu-chi/</id>
        <link href="https://q456qq520.github.io/post/fen-bu-shi-hu-chi/">
        </link>
        <updated>2022-03-07T06:49:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="有你没我有我没你">有你没我，有我没你</h1>
<h2 id="什么是分布式互斥">什么是分布式互斥?</h2>
<p>在分布式系统里，排他性的资源访问方式，叫作分布式互斥(Distributed Mutual Exclusion)，而被互斥访问的共享资源就叫作临界资源(Critical Resource)。</p>
<p>举个例子</p>
<p>想象一下，你正在一家餐厅使用自助咖啡机泡制咖啡，突然有个人过来挪走了你的杯子，开始泡制他自己的咖啡。你耐着性子等他操作完，继续泡制自己的咖啡。结果你开始没多久，他又回来中断了你泡制咖啡的过程。相信要不了几个回合，你和他就会上演一场“有你没我，有我没你”的格斗了。这样现实的问题也同样存在于分布式世界。就像我们使用自助咖啡机时不希望被打扰一样，对于同一共享资源，一个程序正在使用的时候也不希望被其他程序打扰。这，就要求同一时刻只能有一个程序能够访问这种资源。</p>
<h2 id="集中式算法">集中式算法</h2>
<p>对于前面提到的咖啡机问题，我们首先想到的就是，增加一个“协调者”来约束大家使用自助咖啡机，解决强行插入打断别人的问题。</p>
<p>类似地，我们引入一个协调者程序，得到一个分布式互斥算法。每个程序在需要访问临界资源时，先给协调发送一个请求。如果当前没有程序使用这个资源，协调者直接授权请求程序访问;否则，按照先来后到的顺序请求程序“排一个号”。如果有程序使用完资源，则通知协调者，协调者从“排号”的队列里取出排在最前面的请求，并给它发送授权消息。拿到授权消息的程序，可以直接去访问临界资源。</p>
<p>这个互斥算法，就是我们所说的集中式算法，也可以叫做中央服务器算法。之所以这么称 呼，是因为协调者代表着集中程序或中央服务器。</p>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1646640649977.png" alt="分布式集中式算法示意图" loading="lazy"></figure>
<p>如图所示，程序 1、2、3、4 为普通运行程序，另一个程序为协调者。当程序 2 和程序 4<br>
需要使用临界资源时，它们会向协调者发起申请，请求协调者授权。不巧的是，程序 3 正在使用临界资源。这时，协调者根据程序 2 和 4 的申请时间顺序，依次将它们放入等待队列。在这个案例里，程序 4 的申请时间早于程序 2，因此排在程序 2的前面。程序 3 使用完临界资源后，通知协调者释放授权。此时，协调者从等待队列中取出程序4，并给它发放授权。这时，程序 4 就可以使用临界资源了。</p>
<p>从上述流程可以看出，<strong>一个程序完成一次临界资源访问，需要如下几个流程和消息交互</strong>：</p>
<ol>
<li>向协调者发送请求授权信息，1 次消息交互；</li>
<li>协调者向程序发放授权信息，1 次消息交互；</li>
<li>程序使用完临界资源后，向协调者发送释放授权，1 次消息交互。</li>
</ol>
<p>因此，每个程序完成一次临界资源访问，需要进行 3 次消息交互。</p>
<p>不难看出，集中式算法的优点在于直观、简单、信息交互量少、易于实现，并且所有程序只需和协调者通信，程序之间无需通信。但是，这个算法的问题也出在了协调者身上。</p>
<p>一方面，协调者会成为系统的性能瓶颈。想象一下，如果有 100 个程序要访问临界资源，那么协调者要处理 100*3=300 条消息。也就是说，协调者处理的消息数量会随着需要访问临界资源的程序数量线性增加。另一方面，容易引发单点故障问题。协调者故障，会导致所有的程序均无法访问临界资源，导致整个系统不可用。</p>
<p>因此，在使用集中式算法的时候，一定要选择性能好、可靠性高的服务器来运行协调者。</p>
<p>小结一下：集中式算法具有简单、易于实现的特点，但可用性、性能易受协调者影响。在可靠性和性能有一定保障的情况下，比如中央服务器计算能力强、性能高、故障率低，或者中央服务器进行了主备备份，主故障后备可以立马升为主，且数据可恢复的情况下，集中式算法可以适用于比较广泛的应用场景。</p>
<h2 id="民主协商分布式算法">民主协商：分布式算法</h2>
<p>既然引入协调者会带来一些问题，这时你可能就会想，不用协调者是否可以实现对临界资源的互斥访问呢？想象一下，当你需要使用自助咖啡机的时候，是不是可以先去征求其他人的意见，在确认其他人都没在使用也暂时不会使用咖啡机时，你就可以放心大胆地去泡制自己的咖啡了呢？</p>
<p>同理，我们可以把这套算法用于分布式系统。当一个程序要访问临界资源时，先向系统中的其他程序发送一条请求消息，在接收到所有程序返回的同意消息后，才可以访问临界资源。其中，请求消息需要包含所请求的资源、请求者的 ID，以及发起请求的时间</p>
<p>这，就是<strong>民主协商法。在分布式领域中，我们称之为分布式算法</strong>，或者使用组播和逻辑时钟的算法。</p>
<p>如图所示，程序 1、2、3 需要访问共享资源 A。在时间戳为 8 的时刻，程序 1 想要使用资源 A，于是向程序 2 和 3 发起使用资源 A 的申请，希望得到它们的同意。在时间戳为 12的时刻，程序 3 想要使用资源 A，于是向程序 1 和 2 发起访问资源 A 的请求。</p>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1646642012370.png" alt="分布式算法1" loading="lazy"></figure>
<p>如图所示，此时程序 2 暂时不访问资源 A，因此同意了程序 1 和 3 的资源访问请求。对于程序 3 来说，由于程序 1 提出请求的时间更早，因此同意程序 1 先使用资源，并等待程序1 返回同意消息。</p>
<figure data-type="image" tabindex="3"><img src="https://q456qq520.github.io/post-images/1646642063633.png" alt="分布式算法2" loading="lazy"></figure>
<p>如图所示，程序 1 接收到其他所有程序的同意消息之后，开始使用资源 A。当程序 1 使用完资源 A 后，释放使用权限，向请求队列中需要使用资源 A 的程序 3 发送同意使用资源的消息，并将程序 3 从请求队列中删除。此时，程序 3 收到了其他所有程序的同意消息，获得了使用资源 A 的权限，开始使用临界资源 A 的旅程。</p>
<figure data-type="image" tabindex="4"><img src="https://q456qq520.github.io/post-images/1646642086375.png" alt="分布式算法3" loading="lazy"></figure>
<p>从上述流程可以看出，一个程序完成一次临界资源的访问，需要进行如下的信息交互：</p>
<ol>
<li>向其他 n-1 个程序发送访问临界资源的请求，总共需要 n-1 次消息交互；</li>
<li>需要接收到其他 n-1 个程序回复的同意消息，方可访问资源，总共需要 n-1 次消息交互。</li>
</ol>
<p>可以看出，一个程序要成功访问临界资源，至少需要 2*(n-1) 次消息交互。假设，现在系统中的 n 个程序都要访问临界资源，则会同时产生 2n(n-1) 条消息。总结来说，在大型系统中使用分布式算法，消息数量会随着需要访问临界资源的程序数量呈指数级增加，容易导致高昂的“沟通成本”。</p>
<p>从上述分析不难看出，分布式算法根据“先到先得”以及“投票全票通过”的机制，让每个程序按时间顺序公平地访问资源，简单粗暴、易于实现。但，这个算法可用性很低，主要包括两个方面的原因：</p>
<pre><code>当系统内需要访问临界资源的程序增多时，容易产生“信令风暴”，也就是程序收到的请求完全超过了自己的处理能力，而导致自己正常的业务无法开展。

一旦某一程序发生故障，无法发送同意消息，那么其他程序均处在等待回复的状态中，使得整个系统处于停滞状态，导致整个系统不可用。所以，相对于集中式算法的协调者故障，分布式算法的可用性更低。
</code></pre>
<p>针对可用性低的一种改进办法是，如果检测到一个程序故障，则直接忽略这个程序，无需再等待它的同意消息。这就好比在自助餐厅，一个人离开餐厅了，那你在使用咖啡机前，也无需征得他的同意。但这样的话，每个程序都需要对其他程序进行故障检测，这无疑带来了更大的复杂性。</p>
<p>因此，分布式算法适合节点数目少且变动不频繁的系统，且由于每个程序均需通信交互，因此适合 P2P 结构的系统。比如，运行在局域网中的分布式文件系统，具有 P2P 结构的系统等。</p>
<h2 id="轮值-ceo令牌环算法">轮值 CEO：令牌环算法</h2>
<p>程序访问临界资源问题也可按照轮值 CEO 的思路实现。 如下图所示，所有程序构成一个环结构，令牌按照顺时针（或逆时针）方向在程序之间传递，收到令牌的程序有权访问临界资源，访问完成后将令牌传送到下一个程序；若该程序不需要访问临界资源，则直接把令牌传送给下一个程序。</p>
<p>在分布式领域，这个算法叫作令牌环算法，也可以叫作基于环的算法。</p>
<figure data-type="image" tabindex="5"><img src="https://q456qq520.github.io/post-images/1646651760528.png" alt="" loading="lazy"></figure>
<p>因为在使用临界资源前，不需要像分布式算法那样挨个征求其他程序的意见了，所以相对而言，在令牌环算法里单个程序具有更高的通信效率。同时，在一个周期内，每个程序都能访问到临界资源，因此令牌环算法的公平性很好。</p>
<p>但是，不管环中的程序是否想要访问资源，都需要接收并传递令牌，所以也会带来一些无效通信。假设系统中有 100 个程序，那么程序 1 访问完资源后，即使其它 99 个程序不需要访问，也必须要等令牌在其他 99 个程序传递完后，才能重新访问资源，这就降低了系统的实时性。</p>
<p>综上，令牌环算法非常适合通信模式为令牌环方式的分布式系统，例如移动自组织网络系统。一个典型的应用场景就是无人机通信。</p>
<p>小结一下：令牌环算法的公平性高，在改进单点故障后，稳定性也很高，适用于系统规模较小，并且系统中每个程序使用临界资源的频率高且使用时间比较短的场景。</p>
<h2 id="知识扩展有适合大规模系统中的分布式互斥算法吗">知识扩展：有适合大规模系统中的分布式互斥算法吗？</h2>
<p>可以看到，上面提到的集中式、分布式和令牌环 3 个互斥算法，都不适用于规模过大、节点数量过多的系统。那么，什么样的互斥算法适用于大规模系统呢？</p>
<p>由于大规模系统的复杂性，我们很自然地想到要用一个相对复杂的互斥算法。时下有一个很流行的互斥算法，两层结构的分布式令牌环算法，把整个广域网系统中的节点组织成两层结构，可以用于节点数量较多的系统，或者是广域网系统。</p>
<p>我们知道，广域网由多个局域网组成，因此在该算法中，局域网是较低的层次，广域网是较高的层次。每个局域网中包含若干个局部进程和一个协调进程。局部进程在逻辑上组成一个环形结构，在每个环形结构上有一个局部令牌 T 在局部进程间传递。局域网与局域网之间通过各自的协调进程进行通信，这些协调进程同样组成一个环结构，这个环就是广域网中的全局环。在这个全局环上，有一个全局令牌在多个协调进程间传递。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql中的MDL]]></title>
        <id>https://q456qq520.github.io/post/mysql-zhong-de-mdl/</id>
        <link href="https://q456qq520.github.io/post/mysql-zhong-de-mdl/">
        </link>
        <updated>2022-03-07T03:54:23.000Z</updated>
        <content type="html"><![CDATA[<p>首先简单了解一下 mysql 的 sql 类型：</p>
<p>1、数据定义语言 DDL：Create、Drop、Alter 操作。用于定义库和表结构的。</p>
<p>2、数据查询语言 DQL：select。用于查询数据的。</p>
<p>3、数据操纵语言 DML：insert、update、delete。对行记录进行增删改操作。</p>
<p>4、数据控制语言 DCL：grant、revoke、commit、rollback。控制数据库的权限和事务。</p>
<h2 id="mdl">MDL</h2>
<p>MDL（MetaData Lock）就是针对于 DDL 与 DML、DQL 操作加锁，执行 DDL 自动添加写锁，执行 DML、DQL 自动添加读锁，也就是说 DML 语句可以同时执行（不考虑其他锁），而 DDL 间则会相互阻塞。</p>
<h4 id="为什么在执行-ddl-时会添加写锁">为什么在执行 DDL 时会添加写锁</h4>
<p>DDL 在执行会先创建一个临时表，先将表的数据全部移到这个临时表中，然后再将临时表替换当前表。在这个过程中如果出现读写操作就会影响最终结果出错。这个过程耗时主要在将原表的数据移到临时表的过程。</p>
<h2 id="执行">执行</h2>
<p>不同事务的执行是按队列顺序进行的，如果两个事务所执行的 MDL 添加的分别是读、写锁，那么就会互斥，后面的事务只有等到前面事务提交释放锁后才能执行。</p>
<p>例子：假设有四个会话：session1、session2、session3、session4 ，首先先依次开启事务，然后session1，session2 先执行查询操作（为了避免可能是可串行化级别导致加的写锁冲突，所以就使用查询操作），session1，session2 中的操作可以正常执行，session3执行 Alter 修改表结构，此时 session3 的操作就会阻塞（因为 MDL 的读写锁冲突），session4 再执行增删改查也会被阻塞，因为是在队列中，它位于 session3 后面，所以只有等到 session3 提交后其才能继续执行。</p>
<h2 id="online-ddl">Online DDL</h2>
<p>可以看到执行和显示顺序是图中标注的从1开始递增按顺序执行的。可以看到 session4 在 session2 提交后就立刻会执行，并且在 session4 提交后 session3 才能执行成功，这个和前面所说的理论就会冲突。这个原因是当前 mysql 版本是5.6，而在 mysql 5.6 支持 Online DDL。</p>
<p>Online DDL 是对 MDL 的一种优化，因为如果按照 MDL 的执行逻辑，像上面这种情况，一旦一些简单的读写操作比某一条 DDL 语句启动慢一些，就会陷入阻塞，如果 DDL 修改的是大表且是高频表，那么在这条语句执行时会阻塞所有的读写操作，很容易使数据库崩溃。而 Online DDL 优化思路就是在获取到锁之后先允许一段时间的读写操作，直到临时表的数据转移完成，再停止其他读写操作，而具体实现就主要分为下面几步，</p>
<ol>
<li>
<p>拿MDL写锁</p>
</li>
<li>
<p>降级成MDL读锁，接受读写操作，读操作直接正常返回，写操作会被记录下来，等待后面更新到临时表中。</p>
</li>
<li>
<p>真正做DDL，在 DDL 表记录向临时表转移完成并执行完记录的写操作后开始阻塞读写操作。</p>
</li>
<li>
<p>升级成MDL写锁，进行临时表的替换</p>
</li>
<li>
<p>释放MDL锁</p>
</li>
</ol>
<h4 id="注意点">注意点</h4>
<ol>
<li>Online DDL 整个过程是在 InnoDB 内部执行的，对于 Server 来说并没有什么操作，所以这个操作是 &quot;inplace&quot; 的，也就是说：</li>
</ol>
<p>Online 过程一定是 inplace 的，但 inplace 过程不一定是 Online 的。</p>
<ol start="2">
<li>5.6 开始因为支持 Online DDL，所以在向临时表迁移数据时可能会积攒一些写操作造成页分裂，同时在创建新表时每个数据页还会留 1/16 的空间用于更新操作，所以执行DDL后的表结构不一定是最 &quot;紧凑&quot; 的。</li>
<li>5 .6以后 ALGORITHM=INPLACE 这个参数不会表复制</li>
<li>例子：ALTER TABLE tbl_name ADD COLUMN column_name column_definition, ALGORITHM=INPLACE, LOCK=NONE;</li>
</ol>
<h2 id="mdl-引发的问题">MDL 引发的问题</h2>
<p>在上线项目中，如果需要对某个大表的字段进行删除，那么必然会阻塞该表的所有增删改查操作，如果该表存储了热点数据，那么就会阻塞大量的操作，最终导致数据库崩溃。</p>
<p><strong>解决</strong></p>
<p>1、查看当前是否存在长事务，如果存在，先尽快将其提交，防止长事务的MDL写锁阻塞<br>
2、为 DDL 的操作设置过期时间，如果时间内没有成功执行就取消。可以使用 Github 的开源工具 gh-ost。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-online-ddl.html">MDL</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[代理模式]]></title>
        <id>https://q456qq520.github.io/post/dai-li-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/dai-li-mo-shi/">
        </link>
        <updated>2022-03-07T01:37:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="意图">意图</h2>
<p><strong>代理模式</strong>是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。</p>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/content/proxy/proxy-2x.png" alt="likecat" loading="lazy"></figure>
<h2 id="问题">问题</h2>
<p>为什么要控制对于某个对象的访问呢？ 举个例子： 有这样一个消耗大量系统资源的巨型对象， 你只是偶尔需要使用它， 并非总是需要。</p>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/proxy/problem-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>你可以实现延迟初始化： 在实际有需要时再创建该对象。 对象的所有客户端都要执行延迟初始代码。 不幸的是， 这很可能会带来很多重复代码。</p>
<p>在理想情况下， 我们希望将代码直接放入对象的类中， 但这并非总是能实现： 比如类可能是第三方封闭库的一部分。</p>
<h2 id="解决方案">解决方案</h2>
<p>代理模式建议新建一个与原服务对象接口相同的代理类， 然后更新应用以将代理对象传递给所有原始对象客户端。 代理类接收到客户端请求后会创建实际的服务对象， 并将所有工作委派给它。</p>
<figure data-type="image" tabindex="3"><img src="https://refactoringguru.cn/images/patterns/diagrams/proxy/solution-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>这有什么好处呢？ 如果需要在类的主要业务逻辑前后执行一些工作， 你无需修改类就能完成这项工作。 由于代理实现的接口与原类相同， 因此你可将其传递给任何一个使用实际服务对象的客户端。</p>
<h2 id="代理模式结构">代理模式结构</h2>
<figure data-type="image" tabindex="4"><img src="https://refactoringguru.cn/images/patterns/diagrams/proxy/structure-2x.png" alt="likecat" loading="lazy"></figure>
<ol>
<li>
<p><strong>服务接口 （Service Interface）</strong> 声明了服务接口。 代理必须遵循该接口才能伪装成服务对象。</p>
</li>
<li>
<p><strong>服务 （Service）</strong> 类提供了一些实用的业务逻辑。</p>
</li>
<li>
<p><strong>代理 （Proxy）</strong> 类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。 通常情况下， 代理会对其服务对象的整个生命周期进行管理。</p>
</li>
<li>
<p>**客户端 （Client） **能通过同一接口与服务或代理进行交互， 所以你可在一切需要服务对象的代码中使用代理。</p>
</li>
</ol>
<h2 id="代理模式适合应用场景">代理模式适合应用场景</h2>
<ol>
<li>
<p>延迟初始化 （虚拟代理）。 如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。</p>
<p>你无需在程序启动时就创建该对象， 可将对象的初始化延迟到真正有需要的时候。</p>
</li>
<li>
<p>延迟初始化 （虚拟代理）。 如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。</p>
<p>你无需在程序启动时就创建该对象， 可将对象的初始化延迟到真正有需要的时候。</p>
</li>
<li>
<p>访问控制 （保护代理）。 如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。</p>
<p>代理可仅在客户端凭据满足要求时将请求传递给服务对象。</p>
</li>
<li>
<p>本地执行远程服务 （远程代理）。 适用于服务对象位于远程服务器上的情形。</p>
<p>在这种情形中， 代理通过网络传递客户端请求， 负责处理所有与网络相关的复杂细节。</p>
</li>
<li>
<p>记录日志请求 （日志记录代理）。 适用于当你需要保存对于服务对象的请求历史记录时。 代理可以在向服务传递请求前进行记录。</p>
<p>缓存请求结果 （缓存代理）。 适用于需要缓存客户请求结果并对缓存生命周期进行管理时， 特别是当返回结果的体积非常大时。</p>
<ul>
<li>代理可对重复请求所需的相同结果进行缓存， 还可使用请求参数作为索引缓存的键值。</li>
</ul>
</li>
<li>
<p>智能引用。 可在没有客户端使用某个重量级对象时立即销毁该对象。</p>
<p>代理会将所有获取了指向服务对象或其结果的客户端记录在案。 代理会时不时地遍历各个客户端， 检查它们是否仍在运行。 如果相应的客户端列表为空， 代理就会销毁该服务对象， 释放底层系统资源。</p>
<ul>
<li>代理还可以记录客户端是否修改了服务对象。 其他客户端还可以复用未修改的对象。</li>
</ul>
</li>
</ol>
<h2 id="实现方式">实现方式</h2>
<ol>
<li>
<p>如果没有现成的服务接口， 你就需要创建一个接口来实现代理和服务对象的可交换性。 从服务类中抽取接口并非总是可行的， 因为你需要对服务的所有客户端进行修改， 让它们使用接口。 备选计划是将代理作为服务类的子类， 这样代理就能继承服务的所有接口了。</p>
</li>
<li>
<p>创建代理类， 其中必须包含一个存储指向服务的引用的成员变量。 通常情况下， 代理负责创建服务并对其整个生命周期进行管理。 在一些特殊情况下， 客户端会通过构造函数将服务传递给代理。</p>
</li>
<li>
<p>根据需求实现代理方法。 在大部分情况下， 代理在完成一些任务后应将工作委派给服务对象。</p>
</li>
<li>
<p>可以考虑新建一个构建方法来判断客户端可获取的是代理还是实际服务。 你可以在代理类中创建一个简单的静态方法， 也可以创建一个完整的工厂方法。</p>
</li>
<li>
<p>可以考虑为服务对象实现延迟初始化。</p>
</li>
</ol>
<h2 id="代理模式优缺点">代理模式优缺点</h2>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>你可以在客户端毫无察觉的情况下控制服务对象。</td>
<td style="text-align:center">代码可能会变得复杂， 因为需要新建许多类。</td>
</tr>
<tr>
<td>如果客户端对服务对象的生命周期没有特殊要求， 你可以对生命周期进行管理。</td>
<td style="text-align:center">服务响应可能会延迟。</td>
</tr>
<tr>
<td>即使服务对象还未准备好或不存在， 代理也可以正常工作。</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>开闭原则。 你可以在不对服务或客户端做出修改的情况下创建新代理。</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h2 id="与其他模式的关系">与其他模式的关系</h2>
<ol>
<li>
<p><strong>适配器模式</strong>能为被封装对象提供不同的接口， <strong>代理模式</strong>能为对象提供相同的接口， 装饰模式则能为对象提供加强的接口。</p>
</li>
<li>
<p><strong>外观模式</strong>与<strong>代理</strong>的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。</p>
</li>
<li>
<p><strong>装饰</strong>和<strong>代理</strong>有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。</p>
</li>
</ol>
<h2 id="伪代码">伪代码</h2>
<h4 id="缓存代理">缓存代理</h4>
<p>在本例中， 代理模式有助于实现延迟初始化， 并对低效的第三方 YouTube 集成程序库进行缓存。</p>
<p>当你需要在无法修改代码的类上新增一些额外行为时， 代理模式的价值无可估量。</p>
<h6 id="视频文件">视频文件</h6>
<pre><code>package com.proxy;

/**
 * 视频文件
 * @author likecat
 * @version 1.0
 * @date 2022/3/7 11:35
 */
public class Video {
    public String id;
    public String title;
    public String data;

    Video(String id, String title) {
        this.id = id;
        this.title = title;
        this.data = &quot;Random video.&quot;;
    }
}

</code></pre>
<h6 id="远程服务接口">远程服务接口</h6>
<pre><code>package com.proxy;

import java.util.HashMap;

/**
 * 远程服务接口
 * @author likecat
 * @version 1.0
 * @date 2022/3/7 11:35
 */
public interface ThirdPartyYouTubeLib {
    HashMap&lt;String, Video&gt; popularVideos();

    Video getVideo(String videoId);
}


</code></pre>
<h6 id="远程服务实现">远程服务实现</h6>
<pre><code>package com.proxy;

import java.util.HashMap;

/**
 * 远程服务实现
 * @author likecat
 * @version 1.0
 * @date 2022/3/7 11:45
 */
public class ThirdPartyYouTubeClass implements ThirdPartyYouTubeLib{
    @Override
    public HashMap&lt;String, Video&gt; popularVideos() {
        connectToServer(&quot;http://www.youtube.com&quot;);
        return getRandomVideos();
    }

    @Override
    public Video getVideo(String videoId) {
        connectToServer(&quot;http://www.youtube.com/&quot; + videoId);
        return getSomeVideo(videoId);
    }

    // -----------------------------------------------------------------------
    // Fake methods to simulate network activity. They as slow as a real life.

    private int random(int min, int max) {
        return min + (int) (Math.random() * ((max - min) + 1));
    }

    private void experienceNetworkLatency() {
        int randomLatency = random(5, 10);
        for (int i = 0; i &lt; randomLatency; i++) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
        }
    }

    private void connectToServer(String server) {
        System.out.print(&quot;Connecting to &quot; + server + &quot;... &quot;);
        experienceNetworkLatency();
        System.out.print(&quot;Connected!&quot; + &quot;\n&quot;);
    }

    private HashMap&lt;String, Video&gt; getRandomVideos() {
        System.out.print(&quot;Downloading populars... &quot;);

        experienceNetworkLatency();
        HashMap&lt;String, Video&gt; hmap = new HashMap&lt;String, Video&gt;();
        hmap.put(&quot;catzzzzzzzzz&quot;, new Video(&quot;sadgahasgdas&quot;, &quot;Catzzzz.avi&quot;));
        hmap.put(&quot;mkafksangasj&quot;, new Video(&quot;mkafksangasj&quot;, &quot;Dog play with ball.mp4&quot;));
        hmap.put(&quot;dancesvideoo&quot;, new Video(&quot;asdfas3ffasd&quot;, &quot;Dancing video.mpq&quot;));
        hmap.put(&quot;dlsdk5jfslaf&quot;, new Video(&quot;dlsdk5jfslaf&quot;, &quot;Barcelona vs RealM.mov&quot;));
        hmap.put(&quot;3sdfgsd1j333&quot;, new Video(&quot;3sdfgsd1j333&quot;, &quot;Programing lesson#1.avi&quot;));

        System.out.print(&quot;Done!&quot; + &quot;\n&quot;);
        return hmap;
    }

    private Video getSomeVideo(String videoId) {
        System.out.print(&quot;Downloading video... &quot;);

        experienceNetworkLatency();
        Video video = new Video(videoId, &quot;Some video title&quot;);

        System.out.print(&quot;Done!&quot; + &quot;\n&quot;);
        return video;
    }

}

</code></pre>
<h6 id="缓存代理-2">缓存代理</h6>
<pre><code>package com.proxy;

import java.util.HashMap;

/**
 * 缓存代理
 * @author likecat
 * @version 1.0
 * @date 2022/3/7 11:47
 */
public class YouTubeCacheProxy implements ThirdPartyYouTubeLib{
    private ThirdPartyYouTubeLib youtubeService;
    private HashMap&lt;String, Video&gt; cachePopular = new HashMap&lt;String, Video&gt;();
    private HashMap&lt;String, Video&gt; cacheAll = new HashMap&lt;String, Video&gt;();

    public YouTubeCacheProxy() {
        this.youtubeService = new ThirdPartyYouTubeClass();
    }

    @Override
    public HashMap&lt;String, Video&gt; popularVideos() {
        if (cachePopular.isEmpty()) {
            cachePopular = youtubeService.popularVideos();
        } else {
            System.out.println(&quot;Retrieved list from cache.&quot;);
        }
        return cachePopular;
    }

    @Override
    public Video getVideo(String videoId) {
        Video video = cacheAll.get(videoId);
        if (video == null) {
            video = youtubeService.getVideo(videoId);
            cacheAll.put(videoId, video);
        } else {
            System.out.println(&quot;Retrieved video '&quot; + videoId + &quot;' from cache.&quot;);
        }
        return video;
    }

    public void reset() {
        cachePopular.clear();
        cacheAll.clear();
    }
}

</code></pre>
<h6 id="媒体下载应用">媒体下载应用</h6>
<pre><code>package com.proxy;

import java.util.HashMap;

/**
 * 媒体下载应用
 * @author likecat
 * @version 1.0
 * @date 2022/3/7 11:49
 */
public class YouTubeDownloader {
    private ThirdPartyYouTubeLib api;

    public YouTubeDownloader(ThirdPartyYouTubeLib api) {
        this.api = api;
    }

    public void renderVideoPage(String videoId) {
        Video video = api.getVideo(videoId);
        System.out.println(&quot;\n-------------------------------&quot;);
        System.out.println(&quot;Video page (imagine fancy HTML)&quot;);
        System.out.println(&quot;ID: &quot; + video.id);
        System.out.println(&quot;Title: &quot; + video.title);
        System.out.println(&quot;Video: &quot; + video.data);
        System.out.println(&quot;-------------------------------\n&quot;);
    }

    public void renderPopularVideos() {
        HashMap&lt;String, Video&gt; list = api.popularVideos();
        System.out.println(&quot;\n-------------------------------&quot;);
        System.out.println(&quot;Most popular videos on YouTube (imagine fancy HTML)&quot;);
        for (Video video : list.values()) {
            System.out.println(&quot;ID: &quot; + video.id + &quot; / Title: &quot; + video.title);
        }
        System.out.println(&quot;-------------------------------\n&quot;);
    }
}

</code></pre>
<p>######## 客户端代码</p>
<pre><code>package com.proxy;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/7 11:50
 */
public class Demo {
    public static void main(String[] args) {
        YouTubeDownloader naiveDownloader = new YouTubeDownloader(new ThirdPartyYouTubeClass());
        YouTubeDownloader smartDownloader = new YouTubeDownloader(new YouTubeCacheProxy());

        long naive = test(naiveDownloader);
        long smart = test(smartDownloader);
        System.out.print(&quot;Time saved by caching proxy: &quot; + (naive - smart) + &quot;ms&quot;);

    }

    private static long test(YouTubeDownloader downloader) {
        long startTime = System.currentTimeMillis();

        // User behavior in our app:
        downloader.renderPopularVideos();
        downloader.renderVideoPage(&quot;catzzzzzzzzz&quot;);
        downloader.renderPopularVideos();
        downloader.renderVideoPage(&quot;dancesvideoo&quot;);
        // Users might visit the same page quite often.
        downloader.renderVideoPage(&quot;catzzzzzzzzz&quot;);
        downloader.renderVideoPage(&quot;someothervid&quot;);

        long estimatedTime = System.currentTimeMillis() - startTime;
        System.out.print(&quot;Time elapsed: &quot; + estimatedTime + &quot;ms\n&quot;);
        return estimatedTime;
    }
}

</code></pre>
<h6 id="执行结果">执行结果</h6>
<pre><code>Connecting to http://www.youtube.com... Connected!
Downloading populars... Done!

-------------------------------
Most popular videos on YouTube (imagine fancy HTML)
ID: sadgahasgdas / Title: Catzzzz.avi
ID: asdfas3ffasd / Title: Dancing video.mpq
ID: 3sdfgsd1j333 / Title: Programing lesson#1.avi
ID: mkafksangasj / Title: Dog play with ball.mp4
ID: dlsdk5jfslaf / Title: Barcelona vs RealM.mov
-------------------------------

Connecting to http://www.youtube.com/catzzzzzzzzz... Connected!
Downloading video... Done!

-------------------------------
Video page (imagine fancy HTML)
ID: catzzzzzzzzz
Title: Some video title
Video: Random video.
-------------------------------

Connecting to http://www.youtube.com... Connected!
Downloading populars... Done!

-------------------------------
Most popular videos on YouTube (imagine fancy HTML)
ID: sadgahasgdas / Title: Catzzzz.avi
ID: asdfas3ffasd / Title: Dancing video.mpq
ID: 3sdfgsd1j333 / Title: Programing lesson#1.avi
ID: mkafksangasj / Title: Dog play with ball.mp4
ID: dlsdk5jfslaf / Title: Barcelona vs RealM.mov
-------------------------------

Connecting to http://www.youtube.com/dancesvideoo... Connected!
Downloading video... Done!

-------------------------------
Video page (imagine fancy HTML)
ID: dancesvideoo
Title: Some video title
Video: Random video.
-------------------------------

Connecting to http://www.youtube.com/catzzzzzzzzz... Connected!
Downloading video... Done!

-------------------------------
Video page (imagine fancy HTML)
ID: catzzzzzzzzz
Title: Some video title
Video: Random video.
-------------------------------

Connecting to http://www.youtube.com/someothervid... Connected!
Downloading video... Done!

-------------------------------
Video page (imagine fancy HTML)
ID: someothervid
Title: Some video title
Video: Random video.
-------------------------------

Time elapsed: 9354ms
Connecting to http://www.youtube.com... Connected!
Downloading populars... Done!

-------------------------------
Most popular videos on YouTube (imagine fancy HTML)
ID: sadgahasgdas / Title: Catzzzz.avi
ID: asdfas3ffasd / Title: Dancing video.mpq
ID: 3sdfgsd1j333 / Title: Programing lesson#1.avi
ID: mkafksangasj / Title: Dog play with ball.mp4
ID: dlsdk5jfslaf / Title: Barcelona vs RealM.mov
-------------------------------

Connecting to http://www.youtube.com/catzzzzzzzzz... Connected!
Downloading video... Done!

-------------------------------
Video page (imagine fancy HTML)
ID: catzzzzzzzzz
Title: Some video title
Video: Random video.
-------------------------------

Retrieved list from cache.

-------------------------------
Most popular videos on YouTube (imagine fancy HTML)
ID: sadgahasgdas / Title: Catzzzz.avi
ID: asdfas3ffasd / Title: Dancing video.mpq
ID: 3sdfgsd1j333 / Title: Programing lesson#1.avi
ID: mkafksangasj / Title: Dog play with ball.mp4
ID: dlsdk5jfslaf / Title: Barcelona vs RealM.mov
-------------------------------

Connecting to http://www.youtube.com/dancesvideoo... Connected!
Downloading video... Done!

-------------------------------
Video page (imagine fancy HTML)
ID: dancesvideoo
Title: Some video title
Video: Random video.
-------------------------------

Retrieved video 'catzzzzzzzzz' from cache.

-------------------------------
Video page (imagine fancy HTML)
ID: catzzzzzzzzz
Title: Some video title
Video: Random video.
-------------------------------

Connecting to http://www.youtube.com/someothervid... Connected!
Downloading video... Done!

-------------------------------
Video page (imagine fancy HTML)
ID: someothervid
Title: Some video title
Video: Random video.
-------------------------------

Time elapsed: 5875ms
Time saved by caching proxy: 3479ms
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[亨元模式]]></title>
        <id>https://q456qq520.github.io/post/heng-yuan-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/heng-yuan-mo-shi/">
        </link>
        <updated>2022-02-25T09:08:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="意图">意图</h2>
<p><strong>享元模式</strong>是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。</p>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/content/flyweight/flyweight-zh-2x.png" alt="likecat" loading="lazy"></figure>
<h2 id="问题">问题</h2>
<p>假如你希望在长时间工作后放松一下， 所以开发了一款简单的游戏： 玩家们在地图上移动并相互射击。 你决定实现一个真实的粒子系统， 并将其作为游戏的特色。 大量的子弹、 导弹和爆炸弹片会在整个地图上穿行， 为玩家提供紧张刺激的游戏体验。</p>
<p>开发完成后， 你推送提交了最新版本的程序， 并在编译游戏后将其发送给了一个朋友进行测试。 尽管该游戏在你的电脑上完美运行， 但是你的朋友却无法长时间进行游戏： 游戏总是会在他的电脑上运行几分钟后崩溃。 在研究了几个小时的调试消息记录后， 你发现导致游戏崩溃的原因是内存容量不足。 朋友的设备性能远比不上你的电脑， 因此游戏运行在他的电脑上时很快就会出现问题。</p>
<p>真正的问题与粒子系统有关。 每个粒子 （一颗子弹、 一枚导弹或一块弹片） 都由包含完整数据的独立对象来表示。 当玩家在游戏中鏖战进入高潮后的某一时刻， 游戏将无法在剩余内存中载入新建粒子， 于是程序就崩溃了。</p>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/flyweight/problem-zh-2x.png" alt="likecat" loading="lazy"></figure>
<h2 id="解决方案">解决方案</h2>
<p>仔细观察 粒子Particle类， 你可能会注意到颜色 （color） 和精灵图 （sprite）这两个成员变量所消耗的内存要比其他变量多得多。 更糟糕的是， 对于所有的粒子来说， 这两个成员变量所存储的数据几乎完全一样 （比如所有子弹的颜色和精灵图都一样）。</p>
<figure data-type="image" tabindex="3"><img src="https://refactoringguru.cn/images/patterns/diagrams/flyweight/solution1-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>每个粒子的另一些状态 （坐标、 移动矢量和速度） 则是不同的。 因为这些成员变量的数值会不断变化。 这些数据代表粒子在存续期间不断变化的情景， 但每个粒子的颜色和精灵图则会保持不变。</p>
<p>对象的常量数据通常被称为内在状态， 其位于对象中， 其他对象只能读取但不能修改其数值。 而对象的其他状态常常能被其他对象 “从外部” 改变， 因此被称为外在状态。</p>
<p>享元模式建议不在对象中存储外在状态， 而是将其传递给依赖于它的一个特殊方法。 程序只在对象中保存内在状态， 以方便在不同情景下重用。 这些对象的区别仅在于其内在状态 （与外在状态相比， 内在状态的变体要少很多）， 因此你所需的对象数量会大大削减。</p>
<figure data-type="image" tabindex="4"><img src="https://refactoringguru.cn/images/patterns/diagrams/flyweight/solution3-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>让我们回到游戏中。 假如能从粒子类中抽出外在状态， 那么我们只需三个不同的对象 （子弹、 导弹和弹片） 就能表示游戏中的所有粒子。 你现在很可能已经猜到了， 我们将这样一个仅存储内在状态的对象称为享元。</p>
<h4 id="外在状态存储">外在状态存储</h4>
<p>那么外在状态会被移动到什么地方呢？ 总得有类来存储它们， 对不对？ 在大部分情况中， 它们会被移动到容器对象中， 也就是我们应用享元模式前的聚合对象中。</p>
<p>在我们的例子中， 容器对象就是主要的 游戏Game对象， 其会将所有粒子存储在名为 粒子particles的成员变量中。 为了能将外在状态移动到这个类中， 你需要创建多个数组成员变量来存储每个粒子的坐标、 方向矢量和速度。 除此之外， 你还需要另一个数组来存储指向代表粒子的特定享元的引用。 这些数组必须保持同步， 这样你才能够使用同一索引来获取关于某个粒子的所有数据。</p>
<figure data-type="image" tabindex="5"><img src="https://refactoringguru.cn/images/patterns/diagrams/flyweight/solution2-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>更优雅的解决方案是创建独立的情景类来存储外在状态和对享元对象的引用。 在该方法中， 容器类只需包含一个数组。</p>
<p>稍等！ 这样的话情景对象数量不是会和不采用该模式时的对象数量一样多吗？ 的确如此， 但这些对象要比之前小很多。 消耗内存最多的成员变量已经被移动到很少的几个享元对象中了。 现在， 一个享元大对象会被上千个情境小对象复用， 因此无需再重复存储数千个大对象的数据。</p>
<h4 id="享元与不可变性">享元与不可变性</h4>
<p>由于享元对象可在不同的情景中使用， 你必须确保其状态不能被修改。 享元类的状态只能由构造函数的参数进行一次性初始化， 它不能对其他对象公开其设置器或公有成员变量。</p>
<h4 id="享元工厂">享元工厂</h4>
<p>为了能更方便地访问各种享元， 你可以创建一个工厂方法来管理已有享元对象的缓存池。 工厂方法从客户端处接收目标享元对象的内在状态作为参数， 如果它能在缓存池中找到所需享元， 则将其返回给客户端； 如果没有找到， 它就会新建一个享元， 并将其添加到缓存池中。</p>
<p>你可以选择在程序的不同地方放入该函数。 最简单的选择就是将其放置在享元容器中。 除此之外， 你还可以新建一个工厂类， 或者创建一个静态的工厂方法并将其放入实际的享元类中。</p>
<h2 id="享元模式结构">享元模式结构</h2>
<figure data-type="image" tabindex="6"><img src="https://refactoringguru.cn/images/patterns/diagrams/flyweight/structure-2x.png" alt="likecat" loading="lazy"></figure>
<ol>
<li>
<p>享元模式只是一种优化。 在应用该模式之前， 你要确定程序中存在与大量类似对象同时占用内存相关的内存消耗问题， 并且确保该问题无法使用其他更好的方式来解决。</p>
</li>
<li>
<p><strong>享元 （Flyweight</strong>） 类包含原始对象中部分能在多个对象中共享的状态。 同一享元对象可在许多不同情景中使用。 享元中存储的状态被称为 “内在状态”。 传递给享元方法的状态被称为 “外在状态”。</p>
</li>
<li>
<p>**情景 （Context） **类包含原始对象中各不相同的外在状态。 情景与享元对象组合在一起就能表示原始对象的全部状态。</p>
</li>
<li>
<p>通常情况下， 原始对象的行为会保留在享元类中。 因此调用享元方法必须提供部分外在状态作为参数。 但你也可将行为移动到情景类中， 然后将连入的享元作为单纯的数据对象。</p>
</li>
<li>
<p><strong>客户端 （Client）</strong> 负责计算或存储享元的外在状态。 在客户端看来， 享元是一种可在运行时进行配置的模板对象， 具体的配置方式为向其方法中传入一些情景数据参数。</p>
</li>
<li>
<p><strong>享元工厂 （Flyweight Factory）</strong> 会对已有享元的缓存池进行管理。 有了工厂后， 客户端就无需直接创建享元， 它们只需调用工厂并向其传递目标享元的一些内在状态即可。 工厂会根据参数在之前已创建的享元中进行查找， 如果找到满足条件的享元就将其返回； 如果没有找到就根据参数新建享元。</p>
</li>
</ol>
<h2 id="伪代码">伪代码</h2>
<h4 id="渲染一片森林">渲染一片森林</h4>
<p>本例中， 我们将渲染一片森林 （1,000,000 棵树）！ 每棵树都由包含一些状态的对象来表示 （坐标和纹理等）。 尽管程序能够完成其主要工作， 但很显然它需要消耗大量内存。</p>
<p>原因很简单： 太多树对象包含重复数据 （名称、 纹理和颜色）。 因此我们可用享元模式来将这些数值存储在单独的享元对象中 （ Tree­Type类）。 现在我们不再将相同数据存储在数千个 Tree对象中， 而是使用一组特殊的数值来引用其中一个享元对象。</p>
<p>客户端代码不会知道任何事情， 因为重用享元对象的复杂机制隐藏在了享元工厂中。</p>
<p>包含每棵树的独特状态</p>
<pre><code>package com.hengyuan;

import java.awt.*;

/**
 * 包含每棵树的独特状态
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 17:39
 */
public class Tree {
    private int x;
    private int y;
    private TreeType type;

    public Tree(int x, int y, TreeType type) {
        this.x = x;
        this.y = y;
        this.type = type;
    }

    public void draw(Graphics g) {
        type.draw(g, x, y);
    }
}

</code></pre>
<p>包含多棵树共享的状态</p>
<pre><code>package com.hengyuan;

import java.awt.*;

/**
 * 包含多棵树共享的状态
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 17:39
 */
public class TreeType {
    private String name;
    private Color color;
    private String otherTreeData;

    public TreeType(String name, Color color, String otherTreeData) {
        this.name = name;
        this.color = color;
        this.otherTreeData = otherTreeData;
    }

    public void draw(Graphics g, int x, int y) {
        g.setColor(Color.BLACK);
        g.fillRect(x - 1, y, 3, 5);
        g.setColor(color);
        g.fillOval(x - 5, y - 10, 10, 10);
    }
}


</code></pre>
<p>封装创建享元的复杂机制</p>
<pre><code>package com.hengyuan;

import java.awt.*;
import java.util.HashMap;
import java.util.Map;

/**
 * 封装创建享元的复杂机制
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 17:40
 */
public class TreeFactory {

    static Map&lt;String, TreeType&gt; treeTypes = new HashMap&lt;&gt;();

    public static TreeType getTreeType(String name, Color color, String otherTreeData) {
        TreeType result = treeTypes.get(name);
        if (result == null) {
            result = new TreeType(name, color, otherTreeData);
            treeTypes.put(name, result);
        }
        return result;
    }
}


</code></pre>
<p>我们绘制的森林</p>
<pre><code>package com.hengyuan;

import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;

/**
 * 我们绘制的森林
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 17:41
 */
public class Forest extends JFrame {
    private List&lt;Tree&gt; trees = new ArrayList&lt;&gt;();

    public void plantTree(int x, int y, String name, Color color, String otherTreeData) {
        TreeType type = TreeFactory.getTreeType(name, color, otherTreeData);
        Tree tree = new Tree(x, y, type);
        trees.add(tree);
    }

    @Override
    public void paint(Graphics graphics) {
        for (Tree tree : trees) {
            tree.draw(graphics);
        }
    }
}



</code></pre>
<p>客户端代码</p>
<pre><code>package com.hengyuan;

import java.awt.*;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 17:42
 */
public class Demo {
    static int CANVAS_SIZE = 500;
    static int TREES_TO_DRAW = 1000000;
    static int TREE_TYPES = 2;

    public static void main(String[] args) {
        Forest forest = new Forest();
        for (int i = 0; i &lt; Math.floor(TREES_TO_DRAW / TREE_TYPES); i++) {
            forest.plantTree(random(0, CANVAS_SIZE), random(0, CANVAS_SIZE),
                    &quot;Summer Oak&quot;, Color.GREEN, &quot;Oak texture stub&quot;);
            forest.plantTree(random(0, CANVAS_SIZE), random(0, CANVAS_SIZE),
                    &quot;Autumn Oak&quot;, Color.ORANGE, &quot;Autumn Oak texture stub&quot;);
        }
        forest.setSize(CANVAS_SIZE, CANVAS_SIZE);
        forest.setVisible(true);

        System.out.println(TREES_TO_DRAW + &quot; trees drawn&quot;);
        System.out.println(&quot;---------------------&quot;);
        System.out.println(&quot;Memory usage:&quot;);
        System.out.println(&quot;Tree size (8 bytes) * &quot; + TREES_TO_DRAW);
        System.out.println(&quot;+ TreeTypes size (~30 bytes) * &quot; + TREE_TYPES + &quot;&quot;);
        System.out.println(&quot;---------------------&quot;);
        System.out.println(&quot;Total: &quot; + ((TREES_TO_DRAW * 8 + TREE_TYPES * 30) / 1024 / 1024) +
                &quot;MB (instead of &quot; + ((TREES_TO_DRAW * 38) / 1024 / 1024) + &quot;MB)&quot;);
    }

    private static int random(int min, int max) {
        return min + (int) (Math.random() * ((max - min) + 1));
    }
}


</code></pre>
<p>执行结果<br>
<img src="https://refactoringguru.cn/images/patterns/examples/java/flyweight/OutputDemo.png%22%22" alt="likecat" loading="lazy"></p>
<p>内存使用统计</p>
<pre><code>1000000 trees drawn
---------------------
Memory usage:
Tree size (8 bytes) * 1000000
+ TreeTypes size (~30 bytes) * 2
---------------------
Total: 7MB (instead of 36MB)
</code></pre>
<h2 id="亨元模式适合应用场景">亨元模式适合应用场景</h2>
<ol>
<li>
<p>仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。</p>
<p>应用该模式所获的收益大小取决于使用它的方式和情景。 它在下列情况中最有效：</p>
<ul>
<li>程序需要生成数量巨大的相似对象</li>
<li>这将耗尽目标设备的所有内存</li>
<li>对象中包含可抽取且能在多个对象间共享的重复状态。</li>
</ul>
</li>
</ol>
<h2 id="实现方式">实现方式</h2>
<ol>
<li>
<p>将需要改写为享元的类成员变量拆分为两个部分：</p>
<ul>
<li>内在状态： 包含不变的、 可在许多对象中重复使用的数据的成员变量。</li>
<li>外在状态： 包含每个对象各自不同的情景数据的成员变量</li>
</ul>
</li>
<li>
<p>保留类中表示内在状态的成员变量， 并将其属性设置为不可修改。 这些变量仅可在构造函数中获得初始数值。</p>
</li>
<li>
<p>找到所有使用外在状态成员变量的方法， 为在方法中所用的每个成员变量新建一个参数， 并使用该参数代替成员变量。</p>
</li>
<li>
<p>你可以有选择地创建工厂类来管理享元缓存池， 它负责在新建享元时检查已有的享元。 如果选择使用工厂， 客户端就只能通过工厂来请求享元， 它们需要将享元的内在状态作为参数传递给工厂。</p>
</li>
<li>
<p>客户端必须存储和计算外在状态 （情景） 的数值， 因为只有这样才能调用享元对象的方法。 为了使用方便， 外在状态和引用享元的成员变量可以移动到单独的情景类中。</p>
</li>
</ol>
<h2 id="享元模式优缺点">享元模式优缺点</h2>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>如果程序中有很多相似对象， 那么你将可以节省大量内存。</td>
<td style="text-align:center">你可能需要牺牲执行速度来换取内存， 因为他人每次调用享元方法时都需要重新计算部分情景数据。</td>
</tr>
<tr>
<td>-</td>
<td style="text-align:center">代码会变得更加复杂。 团队中的新成员总是会问： ​ “为什么要像这样拆分一个实体的状态？”。</td>
</tr>
</tbody>
</table>
<h2 id="与其他模式的关系">与其他模式的关系</h2>
<ol>
<li>
<p>你可以使用<strong>享元模式</strong>实现<strong>组合模式</strong>树的共享叶节点以节省内存。</p>
</li>
<li>
<p><strong>享元</strong>展示了如何生成大量的小型对象， 外观模式则展示了如何用一个对象来代表整个子系统。</p>
</li>
<li>
<p>如果你能将对象的所有共享状态简化为一个享元对象， 那么<strong>享元</strong>就和<strong>单例模式</strong>类似了。 但这两个模式有两个根本性的不同。</p>
<p>只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。</p>
<p>单例对象可以是可变的。 享元对象是不可变的。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[外观模式]]></title>
        <id>https://q456qq520.github.io/post/wai-guan-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/wai-guan-mo-shi/">
        </link>
        <updated>2022-02-25T07:49:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="意图">意图</h2>
<p><strong>外观模式</strong>是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。</p>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/content/facade/facade-2x.png" alt="likecat" loading="lazy"></figure>
<h2 id="问题">问题</h2>
<p>假设你必须在代码中使用某个复杂的库或框架中的众多对象。 正常情况下， 你需要负责所有对象的初始化工作、 管理其依赖关系并按正确的顺序执行方法等。</p>
<p>最终， 程序中类的业务逻辑将与第三方类的实现细节紧密耦合， 使得理解和维护代码的工作很难进行。</p>
<h2 id="解决方案">解决方案</h2>
<p>外观类为包含许多活动部件的复杂子系统提供一个简单的接口。 与直接调用子系统相比， 外观提供的功能可能比较有限， 但它却包含了客户端真正关心的功能。</p>
<p>如果你的程序需要与包含几十种功能的复杂库整合， 但只需使用其中非常少的功能， 那么使用外观模式会非常方便，</p>
<p>例如， 上传猫咪搞笑短视频到社交媒体网站的应用可能会用到专业的视频转换库， 但它只需使用一个包含 encode­(filename, format)方法 （以文件名与文件格式为参数进行编码的方法） 的类即可。 在创建这个类并将其连接到视频转换库后， 你就拥有了自己的第一个外观。</p>
<h2 id="外观模式结构">外观模式结构</h2>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/facade/structure-2x.png" alt="likecat" loading="lazy"></figure>
<ol>
<li>
<p><strong>外观 （Facade）</strong> 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。</p>
</li>
<li>
<p>创建<strong>附加外观 （Additional Facade）</strong> 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。</p>
</li>
<li>
<p><strong>复杂子系统 （Complex Subsystem）</strong> 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。</p>
<p>子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。</p>
</li>
<li>
<p><strong>客户端 （Client）</strong> 使用外观代替对子系统对象的直接调用</p>
</li>
</ol>
<h2 id="伪代码">伪代码</h2>
<p>复杂视频转换库的简单接口</p>
<p>在本例中， 外观简化了复杂视频转换框架所进行的沟通工作。</p>
<p>外观提供了仅包含一个方法的类， 可用于处理对框架中所需类的配置与以正确格式获取结果的复杂工作。</p>
<p>复杂视频转换程序库</p>
<p>VideoFile</p>
<pre><code>package com.exterior;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:03
 */
public class VideoFile {
    private String name;
    private String codecType;

    public VideoFile(String name) {
        this.name = name;
        this.codecType = name.substring(name.indexOf(&quot;.&quot;) + 1);
    }

    public String getCodecType() {
        return codecType;
    }

    public String getName() {
        return name;
    }
}

</code></pre>
<p>Codec</p>
<pre><code>package com.exterior;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:05
 */
public interface Codec {
}

</code></pre>
<p>MPEG4CompressionCodec</p>
<pre><code>package com.exterior;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:06
 */
public class MPEG4CompressionCodec implements Codec{
    public String type = &quot;mp4&quot;;
}

</code></pre>
<p>OggCompressionCodec</p>
<pre><code>package com.exterior;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:06
 */
public class OggCompressionCodec implements Codec{
    public String type = &quot;ogg&quot;;
}


</code></pre>
<p>CodecFactory</p>
<pre><code>package com.exterior;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:07
 */
public class CodecFactory {
    public static Codec extract(VideoFile file) {
        String type = file.getCodecType();
        if (type.equals(&quot;mp4&quot;)) {
            System.out.println(&quot;CodecFactory: extracting mpeg audio...&quot;);
            return new MPEG4CompressionCodec();
        }
        else {
            System.out.println(&quot;CodecFactory: extracting ogg audio...&quot;);
            return new OggCompressionCodec();
        }
    }
}


</code></pre>
<p>BitrateReader</p>
<pre><code>package com.exterior;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:08
 */
public class BitrateReader {
    public static VideoFile read(VideoFile file, Codec codec) {
        System.out.println(&quot;BitrateReader: reading file...&quot;);
        return file;
    }

    public static VideoFile convert(VideoFile buffer, Codec codec) {
        System.out.println(&quot;BitrateReader: writing file...&quot;);
        return buffer;
    }
}
   
</code></pre>
<p>AudioMixer</p>
<pre><code>package com.exterior;

import java.io.File;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:09
 */
public class AudioMixer {
    public File fix(VideoFile result){
        System.out.println(&quot;AudioMixer: fixing audio...&quot;);
        return new File(&quot;tmp&quot;);
    }
}

</code></pre>
<p>VideoConversionFacade.java: 外观提供了进行视频转换的简单接口</p>
<pre><code>package com.exterior;

import java.io.File;

/**
 * 外观提供了进行视频转换的简单接口
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:10
 */
public class VideoConversionFacade {
    public File convertVideo(String fileName, String format) {
        System.out.println(&quot;VideoConversionFacade: conversion started.&quot;);
        VideoFile file = new VideoFile(fileName);
        Codec sourceCodec = CodecFactory.extract(file);
        Codec destinationCodec;
        if (format.equals(&quot;mp4&quot;)) {
            destinationCodec = new MPEG4CompressionCodec();
        } else {
            destinationCodec = new OggCompressionCodec();
        }
        VideoFile buffer = BitrateReader.read(file, sourceCodec);
        VideoFile intermediateResult = BitrateReader.convert(buffer, destinationCodec);
        File result = (new AudioMixer()).fix(intermediateResult);
        System.out.println(&quot;VideoConversionFacade: conversion completed.&quot;);
        return result;
    }
}

</code></pre>
<p>客户端代码</p>
<pre><code>package com.exterior;

import java.io.File;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:11
 */
public class Demo {
    public static void main(String[] args) {
        VideoConversionFacade converter = new VideoConversionFacade();
        File mp4Video = converter.convertVideo(&quot;youtubevideo.ogg&quot;, &quot;mp4&quot;);
        // ...
    }
}

</code></pre>
<p>执行结果</p>
<pre><code>VideoConversionFacade: conversion started.
CodecFactory: extracting ogg audio...
BitrateReader: reading file...
BitrateReader: writing file...
AudioMixer: fixing audio...
VideoConversionFacade: conversion completed.
</code></pre>
<h2 id="外观模式适合应用场景">外观模式适合应用场景</h2>
<ol>
<li>
<p>如果你需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。<br>
子系统通常会随着时间的推进变得越来越复杂。 即便是应用了设计模式， 通常你也会创建更多的类。 尽管在多种情形中子系统可能是更灵活或易于复用的， 但其所需的配置和样板代码数量将会增长得更快。 为了解决这个问题， 外观将会提供指向子系统中最常用功能的快捷方式， 能够满足客户端的大部分需求。</p>
</li>
<li>
<p>如果需要将子系统组织为多层结构， 可以使用外观。<br>
创建外观来定义子系统中各层次的入口。 你可以要求子系统仅使用外观来进行交互， 以减少子系统之间的耦合。</p>
<p>让我们回到视频转换框架的例子。 该框架可以拆分为两个层次： 音频相关和视频相关。 你可以为每个层次创建一个外观， 然后要求各层的类必须通过这些外观进行交互。 这种方式看上去与<strong>中介者模式</strong>非常相似。</p>
</li>
</ol>
<h2 id="实现方式">实现方式</h2>
<ol>
<li>
<p>考虑能否在现有子系统的基础上提供一个更简单的接口。 如果该接口能让客户端代码独立于众多子系统类， 那么你的方向就是正确的。</p>
</li>
<li>
<p>在一个新的外观类中声明并实现该接口。 外观应将客户端代码的调用重定向到子系统中的相应对象处。 如果客户端代码没有对子系统进行初始化， 也没有对其后续生命周期进行管理， 那么外观必须完成此类工作。</p>
</li>
<li>
<p>如果要充分发挥这一模式的优势， 你必须确保所有客户端代码仅通过外观来与子系统进行交互。 此后客户端代码将不会受到任何由子系统代码修改而造成的影响， 比如子系统升级后， 你只需修改外观中的代码即可。</p>
</li>
<li>
<p>如果外观变得过于臃肿， 你可以考虑将其部分行为抽取为一个新的专用外观类。</p>
</li>
</ol>
<h2 id="外观模式优缺点">外观模式优缺点</h2>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>你可以让自己的代码独立于复杂子系统。</td>
<td style="text-align:center">外观可能成为与程序中所有类都耦合的上帝对象。</td>
</tr>
</tbody>
</table>
<h2 id="与其他模式的关系">与其他模式的关系</h2>
<ol>
<li>
<p><strong>外观模式</strong>为现有对象定义了一个新接口， <strong>适配器模式</strong>则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。</p>
</li>
<li>
<p>当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用<strong>抽象工厂模式</strong>来代替外观。</p>
</li>
<li>
<p><strong>享元模式</strong>展示了如何生成大量的小型对象， 外观则展示了如何用一个对象来代表整个子系统。</p>
</li>
<li>
<p><strong>外观</strong>和<strong>中介者模式</strong>的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。</p>
<p>外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。</p>
<p>中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。</p>
</li>
<li>
<p><strong>外观类</strong>通常可以转换为<strong>单例模式类</strong>， 因为在大部分情况下一个外观对象就足够了。</p>
</li>
<li>
<p><strong>外观</strong>与<strong>代理模式</strong>的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《人人都是产品经理》]]></title>
        <id>https://q456qq520.github.io/post/lesslessren-ren-du-shi-chan-pin-jing-li-greatergreater/</id>
        <link href="https://q456qq520.github.io/post/lesslessren-ren-du-shi-chan-pin-jing-li-greatergreater/">
        </link>
        <updated>2022-02-25T06:33:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="好产品能改变世界">好产品能改变世界</h1>
<h1 id="一-什么是产品经理">一 什么是产品经理</h1>
<p>1 什么是产品</p>
<p>百度百科：<br>
产品是一组将输入转化为输出的相互关联或相互作用的活动”的结果，即“过程”的结果。在经济领域中，通常也可理解为组织制造的任何制品或制品的组合。产品的狭义概念：被生产出的物品；产品的广义概念：可以满足人们需求的载体。</p>
<p>也即：产品是用来解决某个问题的具体物质</p>
<p>2 为什么要有产品经理</p>
<p>产品经理的出现是为了适应公司发展的需要。随着企业越来越大，产品越来越多，越来越复杂，原来按职能划分部门的组织结构已经无法适应，所以出现了产品管理的矩阵型组织。</p>
]]></content>
    </entry>
</feed>