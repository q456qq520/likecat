<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://q456qq520.github.io</id>
    <title>LIKE CAT</title>
    <updated>2022-06-27T03:01:50.235Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://q456qq520.github.io"/>
    <link rel="self" href="https://q456qq520.github.io/atom.xml"/>
    <subtitle>一条小咸鱼</subtitle>
    <logo>https://q456qq520.github.io/images/avatar.png</logo>
    <icon>https://q456qq520.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, LIKE CAT</rights>
    <entry>
        <title type="html"><![CDATA[策略模式]]></title>
        <id>https://q456qq520.github.io/post/ce-lue-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/ce-lue-mo-shi/">
        </link>
        <updated>2022-06-24T03:26:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="意图">意图</h2>
<p><strong>策略模式</strong>是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。</p>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/content/strategy/strategy-2x.png" alt="likecat" loading="lazy"></figure>
<h2 id="问题">问题</h2>
<p>一天， 你打算为游客们创建一款导游程序。 该程序的核心功能是提供美观的地图， 以帮助用户在任何城市中快速定位。</p>
<p>用户期待的程序新功能是自动路线规划： 他们希望输入地址后就能在地图上看到前往目的地的最快路线。</p>
<p>程序的首个版本只能规划公路路线。 驾车旅行的人们对此非常满意。 但很显然， 并非所有人都会在度假时开车。 因此你在下次更新时添加了规划步行路线的功能。 此后， 你又添加了规划公共交通路线的功能。</p>
<p>而这只是个开始。 不久后， 你又要为骑行者规划路线。 又过了一段时间， 你又要为游览城市中的所有景点规划路线。</p>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/strategy/problem-2x.png" alt="likecat" loading="lazy"></figure>
<p>导游代码将变得非常臃肿。</p>
<p>尽管从商业角度来看， 这款应用非常成功， 但其技术部分却让你非常头疼： 每次添加新的路线规划算法后， 导游应用中主要类的体积就会增加一倍。 终于在某个时候， 你觉得自己没法继续维护这堆代码了。</p>
<p>无论是修复简单缺陷还是微调街道权重， 对某个算法进行任何修改都会影响整个类， 从而增加在已有正常运行代码中引入错误的风险。</p>
<p>此外， 团队合作将变得低效。 如果你在应用成功发布后招募了团队成员， 他们会抱怨在合并冲突的工作上花费了太多时间。 在实现新功能的过程中， 你的团队需要修改同一个巨大的类， 这样他们所编写的代码相互之间就可能会出现冲突。</p>
<h2 id="解决方案">解决方案</h2>
<p>策略模式建议找出负责用许多不同方式完成特定任务的类， 然后将其中的算法抽取到一组被称为策略的独立类中。</p>
<p>名为上下文的原始类必须包含一个成员变量来存储对于每种策略的引用。 上下文并不执行任务， 而是将工作委派给已连接的策略对象。</p>
<p>上下文不负责选择符合任务需要的算法——客户端会将所需策略传递给上下文。 实际上， 上下文并不十分了解策略， 它会通过同样的通用接口与所有策略进行交互， 而该接口只需暴露一个方法来触发所选策略中封装的算法即可。</p>
<p>因此， 上下文可独立于具体策略。 这样你就可在不修改上下文代码或其他策略的情况下添加新算法或修改已有算法了。</p>
<figure data-type="image" tabindex="3"><img src="https://refactoringguru.cn/images/patterns/diagrams/strategy/solution-2x.png" alt="likecat" loading="lazy"></figure>
<p>在导游应用中， 每个路线规划算法都可被抽取到只有一个 build­Route生成路线方法的独立类中。 该方法接收起点和终点作为参数， 并返回路线中途点的集合。</p>
<p>即使传递给每个路径规划类的参数一模一样， 其所创建的路线也可能完全不同。 主要导游类的主要工作是在地图上渲染一系列中途点， 不会在意如何选择算法。 该类中还有一个用于切换当前路径规划策略的方法， 因此客户端 （例如用户界面中的按钮） 可用其他策略替换当前选择的路径规划行为。</p>
<h2 id="策略模式模式结构">策略模式模式结构</h2>
<figure data-type="image" tabindex="4"><img src="https://refactoringguru.cn/images/patterns/diagrams/strategy/structure-2x.png" alt="策略模式结构" loading="lazy"></figure>
<ol>
<li>
<p>**上下文 （Context） ** 维护指向具体策略的引用， 且仅通过策略接口与该对象进行交流。</p>
</li>
<li>
<p>**策略 （Strategy） ** 接口是所有具体策略的通用接口， 它声明了一个上下文用于执行策略的方法。</p>
</li>
<li>
<p>**具体策略 （Concrete Strategies） ** 实现了上下文所用算法的各种不同变体。</p>
</li>
<li>
<p>当上下文需要运行算法时， 它会在其已连接的策略对象上调用执行方法。 上下文不清楚其所涉及的策略类型与算法的执行方式。</p>
</li>
<li>
<p>**客户端 （Client） **会创建一个特定策略对象并将其传递给上下文。 上下文则会提供一个设置器以便客户端在运行时替换相关联的策略。</p>
</li>
</ol>
<h2 id="策略模式适合应用场景">策略模式适合应用场景</h2>
<ol>
<li>
<p>当你想使用对象中各种不同的算法变体， 并希望能在运行时切换算法时， 可使用策略模式。</p>
<p>策略模式让你能够将对象关联至可以不同方式执行特定子任务的不同子对象， 从而以间接方式在运行时更改对象行为。</p>
</li>
<li>
<p>当你有许多仅在执行某些行为时略有不同的相似类时， 可使用策略模式。</p>
<p>策略模式让你能将不同行为抽取到一个独立类层次结构中， 并将原始类组合成同一个， 从而减少重复代码。</p>
</li>
<li>
<p>如果算法在上下文的逻辑中不是特别重要， 使用该模式能将类的业务逻辑与其算法实现细节隔离开来。</p>
<p>策略模式让你能将各种算法的代码、 内部数据和依赖关系与其他代码隔离开来。 不同客户端可通过一个简单接口执行算法， 并能在运行时进行切换。</p>
</li>
<li>
<p>当类中使用了复杂条件运算符以在同一算法的不同变体中切换时， 可使用该模式。</p>
<p>策略模式将所有继承自同样接口的算法抽取到独立类中， 因此不再需要条件语句。 原始对象并不实现所有算法的变体， 而是将执行工作委派给其中的一个独立算法对象。</p>
</li>
</ol>
<h2 id="实现方式">实现方式</h2>
<ol>
<li>
<p>从上下文类中找出修改频率较高的算法 （也可能是用于在运行时选择某个算法变体的复杂条件运算符）。</p>
</li>
<li>
<p>声明该算法所有变体的通用策略接口。</p>
</li>
<li>
<p>将算法逐一抽取到各自的类中， 它们都必须实现策略接口。</p>
</li>
<li>
<p>在上下文类中添加一个成员变量用于保存对于策略对象的引用。 然后提供设置器以修改该成员变量。 上下文仅可通过策略接口同策略对象进行交互， 如有需要还可定义一个接口来让策略访问其数据。</p>
</li>
<li>
<p>客户端必须将上下文类与相应策略进行关联， 使上下文可以预期的方式完成其主要工作。</p>
</li>
</ol>
<h2 id="策略模式优缺点">策略模式优缺点</h2>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>你可以在运行时切换对象内的算法。</td>
<td style="text-align:center">如果你的算法极少发生改变， 那么没有任何理由引入新的类和接口。 使用该模式只会让程序过于复杂。</td>
</tr>
<tr>
<td>你可以将算法的实现和使用算法的代码隔离开来。</td>
<td style="text-align:center">客户端必须知晓策略间的不同——它需要选择合适的策略。</td>
</tr>
<tr>
<td>你可以使用组合来代替继承。</td>
<td style="text-align:center">许多现代编程语言支持函数类型功能， 允许你在一组匿名函数中实现不同版本的算法。 这样， 你使用这些函数的方式就和使用策略对象时完全相同， 无需借助额外的类和接口来保持代码简洁。</td>
</tr>
<tr>
<td>开闭原则。 你无需对上下文进行修改就能够引入新的策略。</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h2 id="与其他模式的关系">与其他模式的关系</h2>
<ol>
<li>
<p><strong>桥接模式</strong>、 <strong>状态模式</strong>和<strong>策略模式 <strong>（在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于</strong>组合模式</strong>——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p>
</li>
<li>
<p><strong>命令模式</strong>和<strong>策略</strong>看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。</p>
<p>你可以使用命令来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。</p>
<p>另一方面， 策略通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。</p>
</li>
<li>
<p><strong>装饰模式</strong>可让你更改对象的外表， 策略则让你能够改变其本质。</p>
</li>
<li>
<p><strong>模板方法</strong>模式基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。 策略基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 模板方法在类层次上运作， 因此它是静态的。 策略在对象层次上运作， 因此允许在运行时切换行为。</p>
</li>
<li>
<p>状态可被视为策略的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 策略使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。</p>
</li>
</ol>
<h2 id="伪代码">伪代码</h2>
<h4 id="电子商务应用中的支付方法">电子商务应用中的支付方法</h4>
<p>在本例中， 策略模式被用于在电子商务应用中实现各种支付方法。 客户选中希望购买的商品后需要选择一种支付方式： Paypal 或者信用卡。</p>
<p>具体策略不仅会完成实际的支付工作， 还会改变支付表单的行为， 并在表单中提供相应的字段来记录支付信息。</p>
<p>1、通用的支付方法接口</p>
<pre><code>package com.strategies;

/**
 * 通用的支付方法接口
 * @author likecat
 * @version 1.0
 * @date 2022/6/27 10:42
 */
public interface PayStrategy {
    boolean pay(int paymentAmount);

    void collectPaymentDetails();
}

</code></pre>
<p>2、使用 PayPal 支付</p>
<pre><code>package com.strategies;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Map;

/**
 * 使用 PayPal 支付
 * @author likecat
 * @version 1.0
 * @date 2022/6/27 10:43
 */
public class PayByPayPal implements PayStrategy {
    private static final Map&lt;String, String&gt; DATA_BASE = new HashMap&lt;&gt;();
    private final BufferedReader READER = new BufferedReader(new InputStreamReader(System.in));
    private String email;
    private String password;
    private boolean signedIn;

    static {
        DATA_BASE.put(&quot;amanda1985&quot;, &quot;amanda@ya.com&quot;);
        DATA_BASE.put(&quot;qwerty&quot;, &quot;john@amazon.eu&quot;);
    }

    /**
     * Collect customer's data.
     */
    @Override
    public void collectPaymentDetails() {
        try {
            while (!signedIn) {
                System.out.print(&quot;Enter the user's email: &quot;);
                email = READER.readLine();
                System.out.print(&quot;Enter the password: &quot;);
                password = READER.readLine();
                if (verify()) {
                    System.out.println(&quot;Data verification has been successful.&quot;);
                } else {
                    System.out.println(&quot;Wrong email or password!&quot;);
                }
            }
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private boolean verify() {
        setSignedIn(email.equals(DATA_BASE.get(password)));
        return signedIn;
    }

    /**
     * Save customer data for future shopping attempts.
     */
    @Override
    public boolean pay(int paymentAmount) {
        if (signedIn) {
            System.out.println(&quot;Paying &quot; + paymentAmount + &quot; using PayPal.&quot;);
            return true;
        } else {
            return false;
        }
    }

    private void setSignedIn(boolean signedIn) {
        this.signedIn = signedIn;
    }
}

</code></pre>
<p>3、使用信用卡支付</p>
<pre><code>package com.strategies;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * 使用信用卡支付
 * @author likecat
 * @version 1.0
 * @date 2022/6/27 10:46
 */
public class PayByCreditCard implements PayStrategy {
    private final BufferedReader READER = new BufferedReader(new InputStreamReader(System.in));

    private CreditCard card;

    /**
     * Collect credit card data.
     */
    @Override
    public void collectPaymentDetails() {
        try {
            System.out.print(&quot;Enter the card number: &quot;);
            String number = READER.readLine();
            System.out.print(&quot;Enter the card expiration date 'mm/yy': &quot;);
            String date = READER.readLine();
            System.out.print(&quot;Enter the CVV code: &quot;);
            String cvv = READER.readLine();
            card = new CreditCard(number, date, cvv);

            // Validate credit card number...

        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    /**
     * After card validation we can charge customer's credit card.
     */
    @Override
    public boolean pay(int paymentAmount) {
        if (cardIsPresent()) {
            System.out.println(&quot;Paying &quot; + paymentAmount + &quot; using Credit Card.&quot;);
            card.setAmount(card.getAmount() - paymentAmount);
            return true;
        } else {
            return false;
        }
    }

    private boolean cardIsPresent() {
        return card != null;
    }
}

</code></pre>
<p>4、信用卡类</p>
<pre><code>package com.strategies;

/**
 * 信用卡类
 * @author likecat
 * @version 1.0
 * @date 2022/6/27 10:47
 */
public class CreditCard {
    private int amount;
    private String number;
    private String date;
    private String cvv;

    CreditCard(String number, String date, String cvv) {
        this.amount = 100_000;
        this.number = number;
        this.date = date;
        this.cvv = cvv;
    }

    public void setAmount(int amount) {
        this.amount = amount;
    }

    public int getAmount() {
        return amount;
    }
}

</code></pre>
<p>5、订单类</p>
<pre><code>package com.strategies;

/**
 * 订单类
 * @author likecat
 * @version 1.0
 * @date 2022/6/27 10:48
 */
public class Order {
    private int totalCost = 0;
    private boolean isClosed = false;

    public void processOrder(PayStrategy strategy) {
        strategy.collectPaymentDetails();
        // Here we could collect and store payment data from the strategy.
    }

    public void setTotalCost(int cost) {
        this.totalCost += cost;
    }

    public int getTotalCost() {
        return totalCost;
    }

    public boolean isClosed() {
        return isClosed;
    }

    public void setClosed() {
        isClosed = true;
    }
}

</code></pre>
<p>6、客户端代码</p>
<pre><code>package com.strategies;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Map;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/6/27 10:49
 */
public class Demo {
    private static Map&lt;Integer, Integer&gt; priceOnProducts = new HashMap&lt;&gt;();
    private static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    private static Order order = new Order();
    private static PayStrategy strategy;

    static {
        priceOnProducts.put(1, 2200);
        priceOnProducts.put(2, 1850);
        priceOnProducts.put(3, 1100);
        priceOnProducts.put(4, 890);
    }

    public static void main(String[] args) throws IOException {
        while (!order.isClosed()) {
            int cost;

            String continueChoice;
            do {
                System.out.print(&quot;Please, select a product:&quot; + &quot;\n&quot; +
                        &quot;1 - Mother board&quot; + &quot;\n&quot; +
                        &quot;2 - CPU&quot; + &quot;\n&quot; +
                        &quot;3 - HDD&quot; + &quot;\n&quot; +
                        &quot;4 - Memory&quot; + &quot;\n&quot;);
                int choice = Integer.parseInt(reader.readLine());
                cost = priceOnProducts.get(choice);
                System.out.print(&quot;Count: &quot;);
                int count = Integer.parseInt(reader.readLine());
                order.setTotalCost(cost * count);
                System.out.print(&quot;Do you wish to continue selecting products? Y/N: &quot;);
                continueChoice = reader.readLine();
            } while (continueChoice.equalsIgnoreCase(&quot;Y&quot;));

            if (strategy == null) {
                System.out.println(&quot;Please, select a payment method:&quot; + &quot;\n&quot; +
                        &quot;1 - PalPay&quot; + &quot;\n&quot; +
                        &quot;2 - Credit Card&quot;);
                String paymentMethod = reader.readLine();

                // Client creates different strategies based on input from user,
                // application configuration, etc.
                if (paymentMethod.equals(&quot;1&quot;)) {
                    strategy = new PayByPayPal();
                } else {
                    strategy = new PayByCreditCard();
                }
            }

            // Order object delegates gathering payment data to strategy object,
            // since only strategies know what data they need to process a
            // payment.
            order.processOrder(strategy);

            System.out.print(&quot;Pay &quot; + order.getTotalCost() + &quot; units or Continue shopping? P/C: &quot;);
            String proceed = reader.readLine();
            if (proceed.equalsIgnoreCase(&quot;P&quot;)) {
                // Finally, strategy handles the payment.
                if (strategy.pay(order.getTotalCost())) {
                    System.out.println(&quot;Payment has been successful.&quot;);
                } else {
                    System.out.println(&quot;FAIL! Please, check your data.&quot;);
                }
                order.setClosed();
            }
        }
    }
}

</code></pre>
<p>7、执行结果</p>
<pre><code>Please, select a product:
1 - Mother board
2 - CPU
3 - HDD
4 - Memory
1
Count: 2
Do you wish to continue selecting products? Y/N: y
Please, select a product:
1 - Mother board
2 - CPU
3 - HDD
4 - Memory
2
Count: 1
Do you wish to continue selecting products? Y/N: n
Please, select a payment method:
1 - PalPay
2 - Credit Card
1
Enter the user's email: user@example.com
Enter the password: qwerty
Wrong email or password!
Enter user email: amanda@ya.com
Enter password: amanda1985
Data verification has been successful.
Pay 6250 units or Continue shopping?  P/C: p
Paying 6250 using PayPal.
Payment has been successful.
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[备忘录模式]]></title>
        <id>https://q456qq520.github.io/post/bei-wang-lu-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/bei-wang-lu-mo-shi/">
        </link>
        <updated>2022-06-17T08:37:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="意图">意图</h2>
<p><strong>备忘录模式</strong>是一种行为设计模式， 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。</p>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/content/memento/memento-zh-2x.png" alt="likecat" loading="lazy"></figure>
<h2 id="问题">问题</h2>
<p>假如你正在开发一款文字编辑器应用程序。 除了简单的文字编辑功能外， 编辑器中还要有设置文本格式和插入内嵌图片等功能。</p>
<p>后来， 你决定让用户能撤销施加在文本上的任何操作。 这项功能在过去几年里变得十分普遍， 因此用户期待任何程序都有这项功能。 你选择采用直接的方式来实现该功能： 程序在执行任何操作前会记录所有的对象状态， 并将其保存下来。 当用户此后需要撤销某个操作时， 程序将从历史记录中获取最近的快照， 然后使用它来恢复所有对象的状态。</p>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/memento/problem1-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>程序在执行操作前保存所有对象的状态快照， 稍后可通过快照将对象恢复到之前的状态。</p>
<p>让我们来思考一下这些状态快照。 首先， 到底该如何生成一个快照呢？ 很可能你会需要遍历对象的所有成员变量并将其数值复制保存。 但只有当对象对其内容没有严格访问权限限制的情况下， 你才能使用该方式。 不过很遗憾， 绝大部分对象会使用私有成员变量来存储重要数据， 这样别人就无法轻易查看其中的内容。</p>
<p>现在我们暂时忽略这个问题， 假设对象都像嬉皮士一样： 喜欢开放式的关系并会公开其所有状态。 尽管这种方式能够解决当前问题， 让你可随时生成对象的状态快照， 但这种方式仍存在一些严重问题。 未来你可能会添加或删除一些成员变量。 这听上去很简单， 但需要对负责复制受影响对象状态的类进行更改。</p>
<figure data-type="image" tabindex="3"><img src="https://refactoringguru.cn/images/patterns/diagrams/memento/problem2-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>如何复制对象的私有状态？</p>
<p>还有更多问题。 让我们来考虑编辑器 （Editor） 状态的实际 “快照”， 它需要包含哪些数据？ 至少必须包含实际的文本、 光标坐标和当前滚动条位置等。 你需要收集这些数据并将其放入特定容器中， 才能生成快照。</p>
<p>你很可能会将大量的容器对象存储在历史记录列表中。 这样一来， 容器最终大概率会成为同一个类的对象。 这个类中几乎没有任何方法， 但有许多与编辑器状态一一对应的成员变量。 为了让其他对象能保存或读取快照， 你很可能需要将快照的成员变量设为公有。 无论这些状态是否私有， 其都将暴露一切编辑器状态。 其他类会对快照类的每个小改动产生依赖， 除非这些改动仅存在于私有成员变量或方法中， 而不会影响外部类。</p>
<p>我们似乎走进了一条死胡同： 要么会暴露类的所有内部细节而使其过于脆弱； 要么会限制对其状态的访问权限而无法生成快照。 那么， 我们还有其他方式来实现 “撤销” 功能吗？</p>
<h2 id="解决方案">解决方案</h2>
<p>我们刚才遇到的所有问题都是封装 “破损” 造成的。 一些对象试图超出其职责范围的工作。 由于在执行某些行为时需要获取数据， 所以它们侵入了其他对象的私有空间， 而不是让这些对象来完成实际的工作。</p>
<p>备忘录模式将创建状态快照 （Snapshot） 的工作委派给实际状态的拥有者原发器 （Originator） 对象。 这样其他对象就不再需要从 “外部” 复制编辑器状态了， 编辑器类拥有其状态的完全访问权， 因此可以自行生成快照。</p>
<p>模式建议将对象状态的副本存储在一个名为备忘录 （Memento） 的特殊对象中。 除了创建备忘录的对象外， 任何对象都不能访问备忘录的内容。 其他对象必须使用受限接口与备忘录进行交互， 它们可以获取快照的元数据 （创建时间和操作名称等）， 但不能获取快照中原始对象的状态。</p>
<figure data-type="image" tabindex="4"><img src="https://refactoringguru.cn/images/patterns/diagrams/memento/solution-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>原发器拥有对备忘录的完全访问权限， 负责人则只能访问元数据。</p>
<p>这种限制策略允许你将备忘录保存在通常被称为负责人 （Caretakers） 的对象中。 由于负责人仅通过受限接口与备忘录互动， 故其无法修改存储在备忘录内部的状态。 同时， 原发器拥有对备忘录所有成员的访问权限， 从而能随时恢复其以前的状态。</p>
<p>在文字编辑器的示例中， 我们可以创建一个独立的历史 （History） 类作为负责人。 编辑器每次执行操作前， 存储在负责人中的备忘录栈都会生长。 你甚至可以在应用的 UI 中渲染该栈， 为用户显示之前的操作历史。</p>
<p>当用户触发撤销操作时， 历史类将从栈中取回最近的备忘录， 并将其传递给编辑器以请求进行回滚。 由于编辑器拥有对备忘录的完全访问权限， 因此它可以使用从备忘录中获取的数值来替换自身的状态。</p>
<h2 id="备忘录模式结构">备忘录模式结构</h2>
<h3 id="基于嵌套类的实现">基于嵌套类的实现</h3>
<figure data-type="image" tabindex="5"><img src="https://refactoringguru.cn/images/patterns/diagrams/memento/structure1-2x.png" alt="基于嵌套类的实现" loading="lazy"></figure>
<ol>
<li>
<p><strong>原发器 （Originator）</strong> 类可以生成自身状态的快照， 也可以在需要时通过快照恢复自身状态。</p>
</li>
<li>
<p><strong>备忘录 （Memento）</strong> 是原发器状态快照的值对象 （value object）。 通常做法是将备忘录设为不可变的， 并通过构造函数一次性传递数据。</p>
</li>
<li>
<p><strong>负责人 （Caretaker）</strong> 仅知道 “何时” 和 “为何” 捕捉原发器的状态， 以及何时恢复状态。</p>
</li>
<li>
<p>在该实现方法中， 备忘录类将被嵌套在原发器中。 这样原发器就可访问备忘录的成员变量和方法， 即使这些方法被声明为私有。 另一方面， 负责人对于备忘录的成员变量和方法的访问权限非常有限： 它们只能在栈中保存备忘录， 而不能修改其状态。</p>
</li>
</ol>
<h3 id="封装更加严格的实现">封装更加严格的实现</h3>
<figure data-type="image" tabindex="6"><img src="https://refactoringguru.cn/images/patterns/diagrams/memento/structure3-2x.png" alt="封装更加严格的实现" loading="lazy"></figure>
<ol>
<li>
<p>这种实现方式允许存在多种不同类型的原发器和备忘录。 每种原发器都和其相应的备忘录类进行交互。 原发器和备忘录都不会将其状态暴露给其他类。</p>
</li>
<li>
<p>负责人此时被明确禁止修改存储在备忘录中的状态。 但负责人类将独立于原发器， 因为此时恢复方法被定义在了备忘录类中。</p>
</li>
<li>
<p>每个备忘录将与创建了自身的原发器连接。 原发器会将自己及状态传递给备忘录的构造函数。 由于这些类之间的紧密联系， 只要原发器定义了合适的设置器 （setter）， 备忘录就能恢复其状态。</p>
</li>
</ol>
<h2 id="备忘录模式适合应用场景">备忘录模式适合应用场景</h2>
<ol>
<li>
<p>当你需要创建对象状态快照来恢复其之前的状态时， 可以使用备忘录模式。</p>
<p>备忘录模式允许你复制对象中的全部状态 （包括私有成员变量）， 并将其独立于对象进行保存。 尽管大部分人因为 “撤销” 这个用例才记得该模式， 但其实它在处理事务 （比如需要在出现错误时回滚一个操作） 的过程中也必不可少。</p>
</li>
<li>
<p>当直接访问对象的成员变量、 获取器或设置器将导致封装被突破时， 可以使用该模式。</p>
<p>备忘录让对象自行负责创建其状态的快照。 任何其他对象都不能读取快照， 这有效地保障了数据的安全性。</p>
</li>
</ol>
<h2 id="实现方式">实现方式</h2>
<ol>
<li>
<p>确定担任原发器角色的类。 重要的是明确程序使用的一个原发器中心对象， 还是多个较小的对象。</p>
</li>
<li>
<p>创建备忘录类。 逐一声明对应每个原发器成员变量的备忘录成员变量。</p>
</li>
<li>
<p>将备忘录类设为不可变。 备忘录只能通过构造函数一次性接收数据。 该类中不能包含设置器。</p>
</li>
<li>
<p>如果你所使用的编程语言支持嵌套类， 则可将备忘录嵌套在原发器中； 如果不支持， 那么你可从备忘录类中抽取一个空接口， 然后让其他所有对象通过接口来引用备忘录。 你可在该接口中添加一些元数据操作， 但不能暴露原发器的状态。</p>
</li>
<li>
<p>在原发器中添加一个创建备忘录的方法。 原发器必须通过备忘录构造函数的一个或多个实际参数来将自身状态传递给备忘录。</p>
<p>该方法返回结果的类型必须是你在上一步中抽取的接口 （如果你已经抽取了）。 实际上， 创建备忘录的方法必须直接与备忘录类进行交互。</p>
</li>
<li>
<p>在原发器类中添加一个用于恢复自身状态的方法。 该方法接受备忘录对象作为参数。 如果你在之前的步骤中抽取了接口， 那么可将接口作为参数的类型。 在这种情况下， 你需要将输入对象强制转换为备忘录， 因为原发器需要拥有对该对象的完全访问权限。</p>
</li>
<li>
<p>无论负责人是命令对象、 历史记录或其他完全不同的东西， 它都必须要知道何时向原发器请求新的备忘录、 如何存储备忘录以及何时使用特定备忘录来对原发器进行恢复。</p>
</li>
<li>
<p>负责人与原发器之间的连接可以移动到备忘录类中。 在本例中， 每个备忘录都必须与创建自己的原发器相连接。 恢复方法也可以移动到备忘录类中， 但只有当备忘录类嵌套在原发器中， 或者原发器类提供了足够多的设置器并可对其状态进行重写时， 这种方式才能实现。</p>
</li>
</ol>
<h2 id="备忘录模式优缺点">备忘录模式优缺点</h2>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>你可以在不破坏对象封装情况的前提下创建对象状态快照。</td>
<td style="text-align:center">如果客户端过于频繁地创建备忘录， 程序将消耗大量内存。</td>
</tr>
<tr>
<td>你可以通过让负责人维护原发器状态历史记录来简化原发器代码。</td>
<td style="text-align:center">负责人必须完整跟踪原发器的生命周期， 这样才能销毁弃用的备忘录。</td>
</tr>
<tr>
<td>-</td>
<td style="text-align:center">绝大部分动态编程语言 （例如 PHP、 Python 和 JavaScript） 不能确保备忘录中的状态不被修改。</td>
</tr>
</tbody>
</table>
<h2 id="与其他模式的关系">与其他模式的关系</h2>
<ol>
<li>
<p>你可以同时使用<strong>命令模式</strong>和<strong>备忘录模式</strong>来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态。</p>
</li>
<li>
<p>你可以同时使用<strong>备忘录</strong>和<strong>迭代器模式</strong>来获取当前迭代器的状态， 并且在需要的时候进行回滚。</p>
</li>
<li>
<p>有时候<strong>原型模式</strong>可以作为<strong>备忘录</strong>的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[中介者模式]]></title>
        <id>https://q456qq520.github.io/post/ming-ling-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/ming-ling-mo-shi/">
        </link>
        <updated>2022-06-17T07:29:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="意图">意图</h1>
<p><strong>中介者模式</strong>是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。</p>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/content/mediator/mediator-2x.png" alt="likecat" loading="lazy"></figure>
<h1 id="问题">问题</h1>
<p>假如你有一个创建和修改客户资料的对话框， 它由各种控件组成， 例如文本框 （Text­Field）、 复选框 （Checkbox） 和按钮 （Button） 等。</p>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/mediator/problem1-zh-2x.png" alt="用户界面中各元素间的关系会随程序发展而变得混乱。" loading="lazy"></figure>
<p>用户界面中各元素间的关系会随程序发展而变得混乱。</p>
<p>某些表单元素可能会直接进行互动。 例如， 选中 “我有一只狗” 复选框后可能会显示一个隐藏文本框用于输入狗狗的名字。 另一个例子是提交按钮必须在保存数据前校验所有输入内容。</p>
<p>元素间存在许多关联。 因此， 对某些元素进行修改可能会影响其他元素。</p>
<p>如果直接在表单元素代码中实现业务逻辑， 你将很难在程序其他表单中复用这些元素类。 例如， 由于复选框类与狗狗的文本框相耦合， 所以将无法在其他表单中使用它。 你要么使用渲染资料表单时用到的所有类， 要么一个都不用。</p>
<h1 id="解决方案">解决方案</h1>
<p>中介者模式建议你停止组件之间的直接交流并使其相互独立。 这些组件必须调用特殊的中介者对象， 通过中介者对象重定向调用行为， 以间接的方式进行合作。 最终， 组件仅依赖于一个中介者类， 无需与多个其他组件相耦合。</p>
<p>在资料编辑表单的例子中， 对话框 （Dialog） 类本身将作为中介者， 其很可能已知自己所有的子元素， 因此你甚至无需在该类中引入新的依赖关系。</p>
<figure data-type="image" tabindex="3"><img src="https://refactoringguru.cn/images/patterns/diagrams/mediator/solution1-zh-2x.png" alt="UI 元素必须通过中介者对象进行间接沟通" loading="lazy"></figure>
<p>UI 元素必须通过中介者对象进行间接沟通。</p>
<p>绝大部分重要的修改都在实际表单元素中进行。 让我们想想提交按钮。 之前， 当用户点击按钮后， 它必须对所有表单元素数值进行校验。 而现在它的唯一工作是将点击事件通知给对话框。 收到通知后， 对话框可以自行校验数值或将任务委派给各元素。 这样一来， 按钮不再与多个表单元素相关联， 而仅依赖于对话框类。</p>
<p>你还可以为所有类型的对话框抽取通用接口， 进一步削弱其依赖性。 接口中将声明一个所有表单元素都能使用的通知方法， 可用于将元素中发生的事件通知给对话框。 这样一来， 所有实现了该接口的对话框都能使用这个提交按钮了。</p>
<p>采用这种方式， 中介者模式让你能在单个中介者对象中封装多个对象间的复杂关系网。 类所拥有的依赖关系越少， 就越易于修改、 扩展或复用。</p>
<h1 id="真实世界类比">真实世界类比</h1>
<figure data-type="image" tabindex="4"><img src="https://refactoringguru.cn/images/patterns/diagrams/mediator/live-example-2x.png" alt="likecat" loading="lazy"></figure>
<p>飞行器驾驶员之间不会通过相互沟通来决定下一架降落的飞机。 所有沟通都通过控制塔台进行。</p>
<p>飞行器驾驶员们在靠近或离开空中管制区域时不会直接相互交流。 但他们会与飞机跑道附近， 塔台中的空管员通话。 如果没有空管员， 驾驶员就需要留意机场附近的所有飞机， 并与数十位飞行员组成的委员会讨论降落顺序。 那恐怕会让飞机坠毁的统计数据一飞冲天吧。</p>
<p>塔台无需管制飞行全程， 只需在航站区加强管控即可， 因为该区域的决策参与者数量对于飞行员来说实在太多了。</p>
<h1 id="中介者模式结构">中介者模式结构</h1>
<figure data-type="image" tabindex="5"><img src="https://refactoringguru.cn/images/patterns/diagrams/mediator/structure-2x.png" alt="likecat" loading="lazy"></figure>
<ol>
<li>
<p><strong>组件 （Component）</strong> 是各种包含业务逻辑的类。 每个组件都有一个指向中介者的引用， 该引用被声明为中介者接口类型。 组件不知道中介者实际所属的类， 因此你可通过将其连接到不同的中介者以使其能在其他程序中复用。</p>
</li>
<li>
<p>**中介者 （Mediator） ** 接口声明了与组件交流的方法， 但通常仅包括一个通知方法。 组件可将任意上下文 （包括自己的对象） 作为该方法的参数， 只有这样接收组件和发送者类之间才不会耦合。</p>
</li>
<li>
<p><strong>具体中介者 （Concrete Mediator）</strong> 封装了多种组件间的关系。 具体中介者通常会保存所有组件的引用并对其进行管理， 甚至有时会对其生命周期进行管理。</p>
</li>
<li>
<p>组件并不知道其他组件的情况。 如果组件内发生了重要事件， 它只能通知中介者。 中介者收到通知后能轻易地确定发送者， 这或许已足以判断接下来需要触发的组件了。</p>
</li>
</ol>
<p>对于组件来说， 中介者看上去完全就是一个黑箱。 发送者不知道最终会由谁来处理自己的请求， 接收者也不知道最初是谁发出了请求。</p>
<h2 id="中介者模式适合应用场景">中介者模式适合应用场景</h2>
<ol>
<li>
<p>当一些对象和其他对象紧密耦合以致难以对其进行修改时， 可使用中介者模式。</p>
<p>该模式让你将对象间的所有关系抽取成为一个单独的类， 以使对于特定组件的修改工作独立于其他组件。</p>
</li>
<li>
<p>当组件因过于依赖其他组件而无法在不同应用中复用时， 可使用中介者模式。</p>
<p>应用中介者模式后， 每个组件不再知晓其他组件的情况。 尽管这些组件无法直接交流， 但它们仍可通过中介者对象进行间接交流。 如果你希望在不同应用中复用一个组件， 则需要为其提供一个新的中介者类。</p>
</li>
<li>
<p>如果为了能在不同情景下复用一些基本行为， 导致你需要被迫创建大量组件子类时， 可使用中介者模式。</p>
<p>由于所有组件间关系都被包含在中介者中， 因此你无需修改组件就能方便地新建中介者类以定义新的组件合作方式。</p>
</li>
</ol>
<h1 id="实现方式">实现方式</h1>
<ol>
<li>
<p>找到一组当前紧密耦合， 且提供其独立性能带来更大好处的类 （例如更易于维护或更方便复用）。</p>
</li>
<li>
<p>声明中介者接口并描述中介者和各种组件之间所需的交流接口。 在绝大多数情况下， 一个接收组件通知的方法就足够了。</p>
</li>
</ol>
<p>如果你希望在不同情景下复用组件类， 那么该接口将非常重要。 只要组件使用通用接口与其中介者合作， 你就能将该组件与不同实现中的中介者进行连接。</p>
<ol start="3">
<li>
<p>实现具体中介者类。 该类可从自行保存其下所有组件的引用中受益。</p>
</li>
<li>
<p>你可以更进一步， 让中介者负责组件对象的创建和销毁。 此后， 中介者可能会与工厂或外观类似。</p>
</li>
<li>
<p>组件必须保存对于中介者对象的引用。 该连接通常在组件的构造函数中建立， 该函数会将中介者对象作为参数传递。</p>
</li>
<li>
<p>修改组件代码， 使其可调用中介者的通知方法， 而非其他组件的方法。 然后将调用其他组件的代码抽取到中介者类中， 并在中介者接收到该组件通知时执行这些代码。</p>
</li>
</ol>
<h1 id="中介者模式优缺点">中介者模式优缺点</h1>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>单一职责原则。 你可以将多个组件间的交流抽取到同一位置， 使其更易于理解和维护。</td>
<td style="text-align:center">一段时间后， 中介者可能会演化成为上帝对象。</td>
</tr>
<tr>
<td>开闭原则。 你无需修改实际组件就能增加新的中介者。</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>你可以减轻应用中多个组件间的耦合情况。</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>你可以更方便地复用各个组件。</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h1 id="与其他模式的关系">与其他模式的关系</h1>
<ol>
<li>
<p><strong>责任链模式</strong>、 <strong>命令模式</strong>、 <strong>中介者模式</strong>和<strong>观察者模式</strong>用于处理请求发送者和接收者之间的不同连接方式：</p>
<ul>
<li>责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。</li>
<li>命令在发送者和请求者之间建立单向连接。</li>
<li>中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。</li>
<li>观察者允许接收者动态地订阅或取消接收请求。</li>
</ul>
</li>
<li>
<p><strong>外观模式</strong>和<strong>中介者</strong>的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。</p>
<p>外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。</p>
<p>中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。</p>
</li>
<li>
<p><strong>中介者</strong>和<strong>观察者</strong>之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。</p>
<p>中介者的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 观察者的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。</p>
<p>有一种流行的中介者模式实现方式依赖于观察者。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当中介者以这种方式实现时， 它可能看上去与观察者非常相似。</p>
<p>当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和观察者并不相同， 但这仍是一种中介者模式。</p>
<p>假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。</p>
</li>
</ol>
<h1 id="伪代码">伪代码</h1>
<h2 id="笔记程序">笔记程序</h2>
<p>中介者模式在 Java 代码中最常用于帮助程序 GUI 组件之间的通信。 在 MVC 模式中， 控制器是中介者的同义词。</p>
<p>本例展示了如何将许多 GUI 元素组织起来， 使其在中介者的帮助下无需相互依赖就能合作。</p>
<h3 id="公共组件接口">公共组件接口</h3>
<pre><code>package com.components;

/**
 * 公共组件接口
 * @author likecat
 * @version 1.0
 * @date 2022/6/17 16:10
 */
public interface Component {
    void setMediator(Mediator mediator);
    String getName();
}


</code></pre>
<h3 id="新增按钮">新增按钮</h3>
<pre><code>package com.components;

import javax.swing.*;
import java.awt.event.ActionEvent;

/**
 * 新增按钮
 * @author likecat
 * @version 1.0
 * @date 2022/6/17 16:14
 */
public class AddButton extends JButton implements Component {
    private Mediator mediator;

    public AddButton() {
        super(&quot;Add&quot;);
    }

    @Override
    public void setMediator(Mediator mediator) {
        this.mediator = mediator;
    }

    @Override
    protected void fireActionPerformed(ActionEvent actionEvent) {
        mediator.addNewNote(new Note());
    }

    @Override
    public String getName() {
        return &quot;AddButton&quot;;
    }
}

</code></pre>
<h3 id="删除按钮">删除按钮</h3>
<pre><code>package com.components;

import javax.swing.*;
import java.awt.event.ActionEvent;

/**
 * 删除按钮
 * @author likecat
 * @version 1.0
 * @date 2022/6/17 16:15
 */
public class DeleteButton extends JButton implements Component {
    private Mediator mediator;

    public DeleteButton() {
        super(&quot;Del&quot;);
    }

    @Override
    public void setMediator(Mediator mediator) {
        this.mediator = mediator;
    }

    @Override
    protected void fireActionPerformed(ActionEvent actionEvent) {
        mediator.deleteNote();
    }

    @Override
    public String getName() {
        return &quot;DelButton&quot;;
    }
}

</code></pre>
<h3 id="filter">Filter</h3>
<pre><code>package com.components;

import javax.swing.*;
import java.awt.event.KeyEvent;
import java.util.ArrayList;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/6/17 16:16
 */
public class Filter extends JTextField implements Component {
    private Mediator mediator;
    private ListModel listModel;

    public Filter() {}

    @Override
    public void setMediator(Mediator mediator) {
        this.mediator = mediator;
    }

    @Override
    protected void processComponentKeyEvent(KeyEvent keyEvent) {
        String start = getText();
        searchElements(start);
    }

    public void setList(ListModel listModel) {
        this.listModel = listModel;
    }

    private void searchElements(String s) {
        if (listModel == null) {
            return;
        }

        if (s.equals(&quot;&quot;)) {
            mediator.setElementsList(listModel);
            return;
        }

        ArrayList&lt;Note&gt; notes = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; listModel.getSize(); i++) {
            notes.add((Note) listModel.getElementAt(i));
        }
        DefaultListModel&lt;Note&gt; listModel = new DefaultListModel&lt;&gt;();
        for (Note note : notes) {
            if (note.getName().contains(s)) {
                listModel.addElement(note);
            }
        }
        mediator.setElementsList(listModel);
    }

    @Override
    public String getName() {
        return &quot;Filter&quot;;
    }
}

</code></pre>
<h3 id="list">List</h3>
<pre><code>package com.components;

import javax.swing.*;

/**
 * Concrete components don't talk with each other. They have only one
 * communication channel–sending requests to the mediator.
 */
@SuppressWarnings(&quot;unchecked&quot;)
public class List extends JList implements Component {
    private Mediator mediator;
    private final DefaultListModel LIST_MODEL;

    public List(DefaultListModel listModel) {
        super(listModel);
        this.LIST_MODEL = listModel;
        setModel(listModel);
        this.setLayoutOrientation(JList.VERTICAL);
        Thread thread = new Thread(new Hide(this));
        thread.start();
    }

    @Override
    public void setMediator(Mediator mediator) {
        this.mediator = mediator;
    }

    public void addElement(Note note) {
        LIST_MODEL.addElement(note);
        int index = LIST_MODEL.size() - 1;
        setSelectedIndex(index);
        ensureIndexIsVisible(index);
        mediator.sendToFilter(LIST_MODEL);
    }

    public void deleteElement() {
        int index = this.getSelectedIndex();
        try {
            LIST_MODEL.remove(index);
            mediator.sendToFilter(LIST_MODEL);
        } catch (ArrayIndexOutOfBoundsException ignored) {}
    }

    public Note getCurrentElement() {
        return (Note)getSelectedValue();
    }

    @Override
    public String getName() {
        return &quot;List&quot;;
    }

    private class Hide implements Runnable {
        private List list;

        Hide(List list) {
            this.list = list;
        }

        @Override
        public void run() {
            while (true) {
                try {
                    Thread.sleep(300);
                } catch (InterruptedException ex) {
                    ex.printStackTrace();
                }
                if (list.isSelectionEmpty()) {
                    mediator.hideElements(true);
                } else {
                    mediator.hideElements(false);
                }
            }
        }
    }
}
</code></pre>
<h3 id="保存按钮">保存按钮</h3>
<pre><code>package com.components;

import javax.swing.*;
import java.awt.event.ActionEvent;

/**
 * 保存按钮
 * @author likecat
 * @version 1.0
 * @date 2022/6/17 16:19
 */
public class SaveButton extends JButton implements Component {
    private Mediator mediator;

    public SaveButton() {
        super(&quot;Save&quot;);
    }

    @Override
    public void setMediator(Mediator mediator) {
        this.mediator = mediator;
    }

    @Override
    protected void fireActionPerformed(ActionEvent actionEvent) {
        mediator.saveChanges();
    }

    @Override
    public String getName() {
        return &quot;SaveButton&quot;;
    }
}

</code></pre>
<h3 id="文本框">文本框</h3>
<pre><code>package com.components;

import javax.swing.*;
import java.awt.event.KeyEvent;

/**
 * 文本框
 * @author likecat
 * @version 1.0
 * @date 2022/6/17 16:20
 */
public class TextBox  extends JTextArea implements Component {
    private Mediator mediator;

    @Override
    public void setMediator(Mediator mediator) {
        this.mediator = mediator;
    }

    @Override
    protected void processComponentKeyEvent(KeyEvent keyEvent) {
        mediator.markNote();
    }

    @Override
    public String getName() {
        return &quot;TextBox&quot;;
    }
}

</code></pre>
<h3 id="标题">标题</h3>
<pre><code>package com.components;

import javax.swing.*;
import java.awt.event.KeyEvent;

/**
 * 标题
 * @author likecat
 * @version 1.0
 * @date 2022/6/17 16:21
 */
public class Title extends JTextField implements Component {
    private Mediator mediator;

    @Override
    public void setMediator(Mediator mediator) {
        this.mediator = mediator;
    }

    @Override
    protected void processComponentKeyEvent(KeyEvent keyEvent) {
        mediator.markNote();
    }

    @Override
    public String getName() {
        return &quot;Title&quot;;
    }
}

</code></pre>
<h3 id="定义通用的中介者接口">定义通用的中介者接口</h3>
<pre><code>package com.components;

import javax.swing.*;

/**
 * 定义通用的中介者接口
 * @author likecat
 * @version 1.0
 * @date 2022/6/17 16:11
 */
public interface Mediator {

    void addNewNote(Note note);
    void deleteNote();
    void getInfoFromList(Note note);
    void saveChanges();
    void markNote();
    void clear();
    void sendToFilter(ListModel listModel);
    void setElementsList(ListModel list);
    void registerComponent(Component component);
    void hideElements(boolean flag);
    void createGUI();
}

</code></pre>
<h3 id="具体中介者">具体中介者</h3>
<pre><code>package com.components;

import javax.swing.*;
import javax.swing.border.LineBorder;
import java.awt.*;

/**
 * 具体中介者
 * @author likecat
 * @version 1.0
 * @date 2022/6/17 16:24
 */
public class Editor implements Mediator {
    private Title title;
    private TextBox textBox;
    private AddButton add;
    private DeleteButton del;
    private SaveButton save;
    private List list;
    private Filter filter;

    private JLabel titleLabel = new JLabel(&quot;Title:&quot;);
    private JLabel textLabel = new JLabel(&quot;Text:&quot;);
    private JLabel label = new JLabel(&quot;Add or select existing note to proceed...&quot;);

    /**
     * Here the registration of components by the mediator.
     */
    @Override
    public void registerComponent(Component component) {
        component.setMediator(this);
        switch (component.getName()) {
            case &quot;AddButton&quot;:
                add = (AddButton)component;
                break;
            case &quot;DelButton&quot;:
                del = (DeleteButton)component;
                break;
            case &quot;Filter&quot;:
                filter = (Filter)component;
                break;
            case &quot;List&quot;:
                list = (List)component;
                this.list.addListSelectionListener(listSelectionEvent -&gt; {
                    Note note = (Note)list.getSelectedValue();
                    if (note != null) {
                        getInfoFromList(note);
                    } else {
                        clear();
                    }
                });
                break;
            case &quot;SaveButton&quot;:
                save = (SaveButton)component;
                break;
            case &quot;TextBox&quot;:
                textBox = (TextBox)component;
                break;
            case &quot;Title&quot;:
                title = (Title)component;
                break;
        }
    }

    /**
     * Various methods to handle requests from particular components.
     */
    @Override
    public void addNewNote(Note note) {
        title.setText(&quot;&quot;);
        textBox.setText(&quot;&quot;);
        list.addElement(note);
    }

    @Override
    public void deleteNote() {
        list.deleteElement();
    }

    @Override
    public void getInfoFromList(Note note) {
        title.setText(note.getName().replace('*', ' '));
        textBox.setText(note.getText());
    }

    @Override
    public void saveChanges() {
        try {
            Note note = (Note) list.getSelectedValue();
            note.setName(title.getText());
            note.setText(textBox.getText());
            list.repaint();
        } catch (NullPointerException ignored) {}
    }

    @Override
    public void markNote() {
        try {
            Note note = list.getCurrentElement();
            String name = note.getName();
            if (!name.endsWith(&quot;*&quot;)) {
                note.setName(note.getName() + &quot;*&quot;);
            }
            list.repaint();
        } catch (NullPointerException ignored) {}
    }

    @Override
    public void clear() {
        title.setText(&quot;&quot;);
        textBox.setText(&quot;&quot;);
    }

    @Override
    public void sendToFilter(ListModel listModel) {
        filter.setList(listModel);
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public void setElementsList(ListModel list) {
        this.list.setModel(list);
        this.list.repaint();
    }

    @Override
    public void hideElements(boolean flag) {
        titleLabel.setVisible(!flag);
        textLabel.setVisible(!flag);
        title.setVisible(!flag);
        textBox.setVisible(!flag);
        save.setVisible(!flag);
        label.setVisible(flag);
    }

    @Override
    public void createGUI() {
        JFrame notes = new JFrame(&quot;Notes&quot;);
        notes.setSize(960, 600);
        notes.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        JPanel left = new JPanel();
        left.setBorder(new LineBorder(Color.BLACK));
        left.setSize(320, 600);
        left.setLayout(new BoxLayout(left, BoxLayout.Y_AXIS));
        JPanel filterPanel = new JPanel();
        filterPanel.add(new JLabel(&quot;Filter:&quot;));
        filter.setColumns(20);
        filterPanel.add(filter);
        filterPanel.setPreferredSize(new Dimension(280, 40));
        JPanel listPanel = new JPanel();
        list.setFixedCellWidth(260);
        listPanel.setSize(320, 470);
        JScrollPane scrollPane = new JScrollPane(list);
        scrollPane.setPreferredSize(new Dimension(275, 410));
        listPanel.add(scrollPane);
        JPanel buttonPanel = new JPanel();
        add.setPreferredSize(new Dimension(85, 25));
        buttonPanel.add(add);
        del.setPreferredSize(new Dimension(85, 25));
        buttonPanel.add(del);
        buttonPanel.setLayout(new FlowLayout());
        left.add(filterPanel);
        left.add(listPanel);
        left.add(buttonPanel);
        JPanel right = new JPanel();
        right.setLayout(null);
        right.setSize(640, 600);
        right.setLocation(320, 0);
        right.setBorder(new LineBorder(Color.BLACK));
        titleLabel.setBounds(20, 4, 50, 20);
        title.setBounds(60, 5, 555, 20);
        textLabel.setBounds(20, 4, 50, 130);
        textBox.setBorder(new LineBorder(Color.DARK_GRAY));
        textBox.setBounds(20, 80, 595, 410);
        save.setBounds(270, 535, 80, 25);
        label.setFont(new Font(&quot;Verdana&quot;, Font.PLAIN, 22));
        label.setBounds(100, 240, 500, 100);
        right.add(label);
        right.add(titleLabel);
        right.add(title);
        right.add(textLabel);
        right.add(textBox);
        right.add(save);
        notes.setLayout(null);
        notes.getContentPane().add(left);
        notes.getContentPane().add(right);
        notes.setResizable(false);
        notes.setLocationRelativeTo(null);
        notes.setVisible(true);
    }
}

</code></pre>
<h3 id="笔记类">笔记类</h3>
<pre><code>package com.components;

/**
 * 笔记类
 * @author likecat
 * @version 1.0
 * @date 2022/6/17 16:12
 */
public class Note {
    private String name;
    private String text;

    public Note() {
        name = &quot;New note&quot;;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setText(String text) {
        this.text = text;
    }

    public String getName() {
        return name;
    }

    public String getText() {
        return text;
    }

    @Override
    public String toString() {
        return name;
    }
}

</code></pre>
<h3 id="客户端代码">客户端代码</h3>
<pre><code>package com.components;

import javax.swing.*;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/6/17 16:26
 */
public class Demo {
    public static void main(String[] args) {
        Mediator mediator = new Editor();

        mediator.registerComponent(new Title());
        mediator.registerComponent(new TextBox());
        mediator.registerComponent(new AddButton());
        mediator.registerComponent(new DeleteButton());
        mediator.registerComponent(new SaveButton());
        mediator.registerComponent(new List(new DefaultListModel()));
        mediator.registerComponent(new Filter());

        mediator.createGUI();
    }
}

</code></pre>
<h3 id="执行结果">执行结果</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringCloud微服务]]></title>
        <id>https://q456qq520.github.io/post/springcloud-wei-fu-wu/</id>
        <link href="https://q456qq520.github.io/post/springcloud-wei-fu-wu/">
        </link>
        <updated>2022-04-20T11:02:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-什么是微服务架构">一 什么是微服务架构</h1>
<p>微服务是系统架构上的一种设计风格， 它的主旨是将一个原本独立的系统拆分成多个小型服务，这些小型服务都在各自独立的进程中运行，服务之间通过基于HTTP的RESTful API进行通信协作。 被拆分成的每一个小型服务都围绕着系统中的某一项或一些耦合度较高的业务功能进行构建， 并且每个服务都维护着自身的数据存储、 业务开发、自动化测试案例以及独立部署机制。 由千有了轻量级的通信协作基础， 所以这些微服务可以使用不同的语言来编写。</p>
<h1 id="二-spring-cloud简介">二 Spring Cloud简介</h1>
<p>Spring Cloud是一个基于SpringBoot实现的微服务架构开发 工具。它为微服务架构中涉及的配置管理、服务治理、 断路器、 智能路由、微代理、 控制总线、 全局锁、 决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。</p>
<p>Spring Cloud包含了多个子项目（针对分布式系统中涉及的多个不同开源产品，还可能会新增），如下所述。</p>
<pre><code>- Spring Cloud Config: 配置管理工具， 支持使用Git存储 配置内容，可以使用它实现应用配置的外部化存储，并支持客户端配置信息刷新、 加密／解密配置内容 等。
- Spring Cloud Netflix: 核心 组件， 对多个Netflix OSS开源套件进行整合。
    1. Eureka: 服务治理组件， 包含服务注册中心、 服务注册与发现机制的实现。
    2. Hystrix: 容错管理组件，实现断路器模式，帮助服务依赖中出现的延迟和为故障提供强大的容错能力。
    3. ribbon: 客户端负载均衡的服务调用组件。
    4. Feign: 基于ribbon 和 Hystrix 的声明式服务调用组件。
    5. Zuul: 网关组件， 提供智能路由、 访问过滤等功能。
    6. Archaius: 外部化配置组件。
- Spring Cloud Bus: 事件、 消息总线， 用于传播集群中的状态变化或事件， 以触发后续的处理， 比如用来动态刷新配置等。
- Spring Cloud Cluster: 针对 ZooKeeper、 Redis、 Hazelcast、 Consul 的选举算法和通用状态模式的实现。  
- Spring Cloud Cloudfoundry: 与 Pivotal Cloudfoundry 的整合支持。
- Spring Cloud Consul: 服务发现与配置管理工具。
- Spring Cloud Stream: 通过 Redis、 Rabbit 或者 Kafka 实现的消费微服务， 可以通过简单的声明式模型来发送和接收消息。
- Spring Cloud AWS: 用千简化整合 Amazon Web Service 的组件。
- Spring Cloud Security: 安全工具包， 提供在 Zuul 代理中对 0Auth2 客户端请求的中继器。
- Spring Cloud Sleuth: Spring Cloud 应用的分布式跟踪实现， 可以完美整合 Zipkin。
- Spring Cloud ZooKeeper: 基于 ZooKeeper 的服务发现与配置管理组件。
- Spring Cloud Starters: Spring Cloud 的基础组件， 它是基于Spring Boot 风格项目的基础依赖模块。
- Spring Cloud CLI: 用于在 Groovy 中快速创建 Spring Cloud 应用的 Spring Boot CLI插件。
</code></pre>
<h1 id="三-微服务构建-spring-boot">三 微服务构建： Spring Boot</h1>
<p>为了能够更合理地重写各属性的值，SpringBoot使用了下面这种较为特别的属性加载顺序：</p>
<p>1 在命令行中传入的参数。<br>
2. SPRING APPLICATION JSON中的属性。 SPRING_APPLICATION—JSON是以JSON格式配置在系统环境变量中的内容。<br>
3. java:comp/env中的JNDI 属性。<br>
4. Java的系统属性， 可以通过System.getProperties()获得的内容。<br>
5. 操作系统的环境变量 。<br>
6. 通过random.*配置的随机属性。<br>
7. 位于当前应用 jar 包之外，针对不同{profile}环境的配置文件内容，例如application-{profile}.properties或是YAML定义的配置文件。<br>
8. 位于当前应用 jar 包之内 ，针对不同{profile}环境的配置文件内容，例如application-{profile}.properties或是YAML定义的配置文件。<br>
9. 位于当前应用jar包之外的application.properties和YAML配置内容。<br>
10. 位于当前应用jar包之内的application.properties和YAML配置内容。<br>
11. 在@Configuration注解修改的类中，通过@PropertySource注解定义的属性。<br>
12. 应用默认属性，使用SpringApplication.setDefaultProperties 定义的内容。</p>
<h1 id="四-服务治理-spring-cloud-eureka">四 服务治理： Spring Cloud Eureka</h1>
<p>Spring Cloud Eureka 是 Spring Cloud Netflix 微服务套件中的一部分， 它基于 NetflixEureka 做了二次封装， 主要负责完成微服务架构中的服务治理功能。 Spring Cloud 通过为Eureka 增加了 Spring Boot 风格的自动化配置，我们只需通过简单引入依赖和注解配置就能让 Spring Boot 构建的微服务应用轻松地与 Eureka 服务治理体系进行整合。</p>
<h2 id="41-服务治理">4.1 服务治理</h2>
<p>服务治理可以说是微服务架构中最为核心和基础的模块， 它主要用来实现各个微服务实例的自动化注册与发现。</p>
<p>为了解决微服务架构中的服务实例维护问题， 产生了大量的服务治理框架和产品。 这些框架和产品的实现都围绕着服务注册与服务发现机制来完成对微服务应用实例的自动化管理。</p>
<ul>
<li>服务注册：</li>
</ul>
<p>在服务治理框架中， 通常都会构建一个注册中心， 每个服务单元向注册中心登记自己提供的服务， 将主机与端口号、 版本号、 通信协议等一些附加信息告知注册中心， 注册中心按服务名分类组织服务清单。 比如， 我们有两个提供服务A的进程分别运行于 192.168.0.100:8000和192.168.0.101:8000位置上，<br>
另外还有三个 提供服务B的进程分别运行千192.168.0.100:9000 、192.168.0.101:9000、 192.168.0.102:9000位置上。 当这些进程均启动，并向注册中心注册自己的服务之后， 注册中心就会维护类似下面的一个服务清单。另外， 服务注册中心还需要以心跳的方式去监测清单中的服务是否可用， 若不可用需要从服务清单中剔除， 达到排除故障服务的效果。</p>
<table>
<thead>
<tr>
<th>服务名</th>
<th style="text-align:center">位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>服务A</td>
<td style="text-align:center">192.168.0.100:8000、192.168.0.101:8000</td>
</tr>
<tr>
<td>服务B</td>
<td style="text-align:center">192.168.0.100:9000、192.168.0.101:9000、192.168.0.102:9000</td>
</tr>
</tbody>
</table>
<ul>
<li>服务发现：</li>
</ul>
<p>由于在服务治理框架下运作， 服务间的调用不再通过指定具体的实例地址来实现， 而是通过向服务名发起请求调用实现。 所以， 服务调用方在调用服务提供方接口的时候， 并不知道具体的服务实例位置。 因此， 调用方需要向服务注册中心咨询服务， 并获取所有服务的实例清单， 以实现对具体服务实例的访问。 比如，现有服务C希望调用服务A, 服务C就需要向注册中心发起咨询服务请求， 服务注册中心就会将服务A的位置清单返回给服务C, 如按上例服务A的情况，C便获得了服务A的两个可用位置 192.168.0.100:8000和192.168.0.101:8000。当服务C要发起调用的时候， 便从该清单中以某种轮询策略取出一 个位置来进行服务调用， 这就是后续我们将会介绍的客户端负载均衡。 这里我们只是列举了一种简单的服务治理逻辑， 以方便理解服务治理框架的基本运行思路。 实际的框架为了性能等因素， 不会采用每次都向服务注册中心获取服务的方式， 并且不同的应用场景在缓存和服务剔除等机制上也会有一些不同的实现策略。</p>
<h2 id="42-netflix-eureka">4.2 Netflix Eureka</h2>
<p>Spring Cloud Eureka, 使用Netflix Eureka来实现服务注册与发现， 它既包含了服务端组件，也包含了客户端组件，并且服务端与客户端均采用Java编写，所以Eureka主要适用于通过Java实现的分布式系统，或是与NM兼容语言构建的系统。但是， 由于Eureka服务端的服务治理机制提供了完备的RESTful APL所以它也支持将非Java语言构建的微服务应用纳入Eureka的服务治理体系中来。只是在使用其他语言平台的时候，需要自己来实现Eureka的客户端程序。</p>
<p>Eureka服务端，我们也称为服务注册中心。 它同其他服务注册中心一样，支持高可用配置。它依托于强一致性提供良好的服务实例可用性，可以应对多种不同的故障场景。 如果Eureka以集群模式部署，当集群中有分片出现故障时，那么Eureka就转入自我保护模式。它允许在分片故障期间继续提供服务的发现和注册，当故障分片恢复运行时， 集群中的其他分片会把它们的状态再次同步回来。</p>
<p>Eureka客户端，主要处理服务的注册与发现。客户端服务通过注解和参数配置的方式，嵌入在客户端应用程序的代码中，在应用程序运行时，Eureka客户端向注册中心注册自身提供的服务并周期性地发送心跳来更新它的服务租约。同时，它也能从服务端查询当前注册的服务信息并把它们缓存到本地并周期性地刷新服务状态。</p>
<h2 id="43-高可用注册中心">4.3 高可用注册中心</h2>
<p>在微服务架构这样的分布式环境中， 我们需要充分考虑发生故障的情况， 所以在生产环境中必须对各个组件进行高可用部署， 对于微服务如此， 单节点的服务注册中心这在生产环境中显然并不合适，我们需要构建高可用的服务注册中心以增强系统的可用性。<br>
Eureka Server的设计一开始就考虑了高可用问题， 在Eureka的服务治理设计中， 所有节点即是服务提供方， 也是服务消费方， 服务注册中心也不例外。 通过在单节点的配置中， 设置过下面这两个参数， 让服务注册中心不注册自己：</p>
<pre><code>eureka.client.register-with-eureka=false 由于该应用为注册中心，所以设置为 false, 代表不向注册中心注册自己。
eureka.client.fetch-registry=false 由于注册中心的职责就是维护服务实例，它并不需要去检索服务， 所以也设置为 false。
</code></pre>
<p>Eureka Server的高可用实际上就是将自己作为服务向其他服务注册中心注册自己，这样就可以形成一组互相注册的服务注册中心， 以实现服务清单的互相同步， 达到高可用的效果。</p>
<h2 id="44-服务发现与消费">4.4 服务发现与消费</h2>
<p>服务发现的任务由Eureka的客户端完成，而服务消费的任务由ribbon完成 。Ribbon是一个基于HTTP和TCP的客户端负载均衡器，它可以在通过客户端中配置的 ribbonServerList服务端列表去轮询访问以达到均衡负载的作用。</p>
<p>当Ribbon与Eureka联合使用时，ribbon的服务实例清单ribbonServerList会被DiscoveryEnabledNIWSServerList重写， 扩展成从Eureka注册中心中获取服务端列表。同时它也会用 NIWSDiscoveryPing来取代工ping, 它将职责委托给Eureka 来确定服务端是否已经启动 。</p>
<h2 id="45eureka详解">4.5Eureka详解</h2>
<p>Eureka 服务治理体系中的三个核心角色： 服务注册中心、 服务提供者以及服务消费者。</p>
<h3 id="451-基础架构">4.5.1 基础架构</h3>
<ul>
<li>服务注册中心：Eureka 提供的服务端， 提供服务注册与发现的功能</li>
<li>服务提供者：提供服务的应用， 可以是 Spring Boot 应用， 也可以是其他技术平台且遵循 Eureka 通信机制的应用。它将自己提供的服务注册到 Eureka</li>
<li>服务消费者：消费者应用从服务注册中心获取服务列表， 从而使消费者可以知道去何处调用其所需要的服务</li>
</ul>
<h3 id="452-服务治理机制">4.5.2 服务治理机制</h3>
<p>以下图为例， 以此来理解基于Eureka 实现的服务治理体系是如何运作起来的。</p>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1650616057614.png" alt="服务治理机制" loading="lazy"></figure>
<p>• &quot;服务注册中心-1&quot; 和 “服务注册中心-2&quot;, 它们互相注册组成了高可用集群。<br>
• &quot;服务提供者” 启动了两个实例， 一个注册到 “服务注册中心-1&quot; 上， 另外一个注册到 “服务注册中心-2&quot; 上。<br>
• 还有两个 “服务消费者“， 它们也都分别只指向了一个注册中心。</p>
<p><strong>服务提供者</strong></p>
<p><em>服务注册</em></p>
<p>“服务提供者” 在启动的时候会通过发送REST请求的方式将自己注册到EurekaServer上， 同时带上了自身服务的一些元数据信息。Eureka Server接收到这个REST请求之后，将元数据信息存储在一个双层结构Map中， 其中第一层的key是服务名， 第二层的key是具体服务的实例名。</p>
<pre><code>在服务注册时， 需要确认一下 eureka.client.register-with-eureka=true参数是否正确， 该值默认为true。 若设置为false将不会 启动注册操作。
</code></pre>
<p><em>服务同步</em></p>
<p>如架构图中所示， 这里的两个服务提供者分别注册到了两个不同的服务注册中心上，也就是说， 它们的信息分别被两个服务注册中心所维护。 此时， 由于服务注册中心之间因互相注册为服务， 当服务提供者发送注册请求到一个服务注册中心时， 它会将该请求转发给集群中相连的其他注册中心， 从而实现注册中心之间的服务同步 。 通过服务同步，两个服务提供者的服务信息就可以通过这两台服务注册中心中的任意一台获取到。</p>
<p><em>服务续约</em></p>
<p>在注册完服务之后，服务提供者会维护一个心跳用来持续告诉EurekaSe1-ver: &quot;我还活着”， 以防止Eureka Server的“剔除任务 ” 将该服务实例从服务列表中排除出去，我们称该操作为服务续约(Renew)。<br>
关于服务续约有两个重要属性，我们可以关注并根据需要来进行调整：</p>
<pre><code>eureka.instance.lease-renewal-interval-in-seconds=30 用于定义服务续约任务的调用间隔时间，默认为30秒
eureka.instance.lease-expiration-duration-in-seconds=90 用于定义服务失效的时间，默认为90秒。
</code></pre>
<p><strong>服务消费者</strong></p>
<p><em>获取服务</em></p>
<p>当启动服务消费者的时候， 它会发送一个REST请求给服务注册中心，来获取上面注册的服务清单 。 为了性能考虑， Eureka Server会维护一份只读的服务清单来返回给客户端，同时该缓存清单会每隔30秒更新 一次。</p>
<p>获取服务是服务消费者的基础，所以必须确保eureka.client.fetch-registry=true参数没有被修改成false, 该值默认为七rue。若希望修改缓存清单的 更新时间，可以通过 eureka.client.registry-fetch-interval-seconds= 30参数进行修改，该参数默认值为30, 单位为秒。</p>
<p><em>服务调用</em></p>
<p>服务消费者在 获取服务清单后，通过服务名可以获得具体提供服务的实例名和该实例的元数据信息。 因为有这些服务实例的详细信息， 所以客户端可以根据自己的需要决定具体调用哪个实例，在ribbon中会默认采用轮询的方式进行调用，从而实现客户端的负载均衡。</p>
<p>对于访问实例的选择，Eureka中有Region和Zone的概念， 一个Region中可以包含多个Zone, 每个服务客户端需要被注册到 一个Zone中， 所以每个客户端对应一个Region和一个Zone。 在进行服务调用的时候，优先访问同处一个 Zone 中的服务提供方， 若访问不到，就访问其他的Zone。</p>
<p><em>服务下线</em></p>
<p>在系统运行过程中必然会面临关闭或重启服务的某个实例的情况， 在服务关闭期间，我们自然不希望客户端会继续调用关闭了的实例。 所以在客户端程序中， 当服务实例进行正常的关闭操作时， 它会触发一个服务下线的REST请求给Eurke a Server, 告诉服务注册中心：“我要下线了”。 服务端在接收到请求之后， 将该服务状态置为下线(DOWN), 并把该下线事件传播出去。</p>
<p><strong>服务注册中心</strong></p>
<p><em>失效剔除</em></p>
<p>有些时候， 我们的服务实例并不一定会正常下线， 可能由于内存溢出、 网络故障等原因使得服务不能正常工作， 而服务注册中心并未收到 “服务下线” 的请求。 为了从服务列表中将这些无法提供服务的实例剔除， Eureka Server在启动的时候会创建一个定时任务，默认每隔一段时间（默认为60秒） 将当前清单中超时（默认为90秒）没有续约的服务剔除出去。</p>
<p><em>自我保护</em></p>
<p>服务注册到EurekaServer之后，会维护一个心跳连接，告诉EurekaServer自己还活着。EurekaServer<br>
在运行期间，会统计心跳失败的比例在15分钟之内是否低于85%, 如果出现低于的情况（在单机调试的时候很容易满足， 实际在生产环境上通常是由于网络不稳定导致）， EurekaServer会将当前的实例注册信息保护起来， 让这些实例不会过期， 尽可能保护这些注册信息。 但是， 在这段保护期间内实例若出现问题， 那么客户端很容易拿到实际已经不存在的服务实例， 会出现调用失败的清况， 所以客户端必须要有容错机制， 比如可以使用请求重试、 断路器等机制。</p>
<p>由于本地调试很容易触发注册中心的保护机制， 这会使得注册中心维护的服务实例不那么准确。 所以， 我们在本地进行开发的时候， 可以使用eureka.server.enableself-preservation = false参数来关闭护机制， 以确保注册中心可以将不可用的实例正确剔除。</p>
<h3 id="453-源码分析">4.5.3 源码分析</h3>
<p>首先， 对于服务注册中心、 服务提供者、 服务消费者这三个主要元素来说， 后两者（也就是 Eureka 客户端）在整个运行机制中是大部分通信行为的主动发起者， 而注册中心主要是处理请求的接收者。所以， 我们可以从 Eureka 的客户端作为入口看看它是如何完成这些主动通信行为的。我们在将一个普通的 Spring Boot 应用注册到 Eureka Server 或是从 Eureka Server 中获取服务列表时， 主要就做了两件事：</p>
<p>•  在应用主类中配置了@EnableDiscoveryClient注解。<br>
•  在 app让cation.properties 中用 eureka .client.serviceUrl.defaultZone参数指定了服务注册中心的位置。</p>
<p>顺着上面的线索， 我们来看看@EnableDiscoveryClient 的源码， 具体如下：</p>
<pre><code>@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import({EnableDiscoveryClientImportSelector.class})
public @interface EnableDiscoveryClient {
    boolean autoRegister() default true;
}
</code></pre>
<p>从该注解的注释中我们可以知道，它主要用来开启discoveryClient 的实例。通过搜索 DiscoveryClient, 我们可以发现有一个类和一个接口。通过梳理可以得到如下图所示的关系：</p>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1655362319278.png" alt="服务发现类图" loading="lazy"></figure>
<p>其中左边的org.springframework.cloud.client.discovery.DiscoveryClient是Spring Cloud的接口，它定义了用来发现服务的常用抽象方法， 通过该接口可以有效地屏蔽服务治理的实现细节， 所以使用 Spring Cloud 构建的微服务应用可以方便地切换不同服务治理框架， 而不改动程序代码， 只需要另外添加一些针对服务治理框架的配置即可。</p>
<p>org.springframework.cloud.netflix.eureka.EurekaDiscoveryClient是对该接口的实现， 从命名来判断， 它实现的是对 Eureka 发现服务的封装。所以 EurekaDiscoveryClient 依赖了 Netflix Eureka的com.netflix.discovery.EurekaClient接口，EurekaClient 继承了 LookupService 接口， 它们都是Netflix开源包中的内容， 主要定义了针对Eureka的发现服务的抽象方法， 而真正实现发现服务的 则是Netflix包中的com.netf巨x.discovery.DiscoveryClient类。</p>
<p>详细看看 DiscoveryClient 类，首先是该类头部的注释部分：</p>
<pre><code>这个类用于帮助与Eureka Server互相协作。Eureka Client负责下面的任务:
- 向Eureka Server注册服务实例 
- 向Eureka Server服务租约
- 当服务关闭期间， 向Eureka Server取消租约 
- 查询Eureka Server中的服务实例列表
Eureka Client还需要配置一个Eureka Server的 URL列表。
</code></pre>
<p>在具体研究 Eureka Client 负责完成的任务之前， 我们先看看在哪里对 Eureka Server 的 URL 列表进行配置。根据我们配置的属性名eureka.client.serviceUrl.defaultZone, 通 过 serviceUrl 可 以找 到该属性相关的加载属性， 但是在 SR5 版本中它们 都被 @Deprecated 标注为不再建议使用，并@link到了替代类com.netflix.discovery. endpoint.EndpointUtils, 所以我们可以在该类中找到下面逻辑函数。</p>
<h4 id="region-zone">Region、 Zone</h4>
<p>客户端依次加载了两个内容， 第一个是Region, 第二个是Zone, 从其加载逻辑上我们可以判断它们之间的关系:<br>
• 通过getRegion函数， 我们可以看到它从配置中读取了 一个Region返回， 所以 一 个微服务应用只可以属于 一个Region, 如果不特别配置， 默认为default 若我们要自己设置， 可以通过eureka.client.region属性来定义。<br>
• 通过 getAvailabilityZones 函数， 可以知道当我们没有特别为Region配置 Zone的时候，将默 认采用defaulZt one , 这也是我们之前配置参数 eureka. client.serviceUrl.defaultZone的由来。若要为应用指定Zone, 可以通过 eureka.client.availability-zones属性来进行设置。从该函数的return内容， 我们可以知道Zone能够设置多个， 并且通过逗号分隔来配置。 由此， 我们可以判断Region与Zone是一对多的关系。</p>
<h4 id="serviceurls">serviceUrls</h4>
<p>在获取了 Region 和 Zone 的信息之后， 才开始真正加载Eureka Server的具体地址。 具体获取 serviceUrls 的实现， 我们可以详细查看 getEurekaServerServiceUrls 函数的具体实现类 EurekaClientConfigBean, 该类是 EurekaClientConfig 和 EurekaConstants接口的实现，用来加载配置文件中的内容。</p>
<p>当我们在微服务应用中使用 Ribbon 来实现服务调用时， 对千 Zone 的设置可以在负载 均衡时实现区域亲和特性: Ribbon 的默认策略会优先访问同客户端处于 一个 Zone 中的服 务端实例，只有当同 一个 Zone 中没有可用服务端实例的时候才会访问其他 Zone 中的实例。 所以通过 Zone 属性的定义，配合实际部署的物理结构，我们就可以有效地设计出对区域性 故障的容错集群。</p>
<h4 id="服务注册">服务注册</h4>
<p>在理解了多个服务注册中心信息的加载后，我们再回头看看 DiscoveryClient 类是 如何实现 “ 服务注册 “ 行为的， 通过查看它的构造类， 可以找到它调用了下面这个函数:</p>
<pre><code>  /**
     * Initializes all scheduled tasks.
     */
    private void initScheduledTasks() {
        if (clientConfig.shouldFetchRegistry()) {
            // registry cache refresh timer
            int registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();
            int expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();
            cacheRefreshTask = new TimedSupervisorTask(
                    &quot;cacheRefresh&quot;,
                    scheduler,
                    cacheRefreshExecutor,
                    registryFetchIntervalSeconds,
                    TimeUnit.SECONDS,
                    expBackOffBound,
                    new CacheRefreshThread()
            );
            scheduler.schedule(
                    cacheRefreshTask,
                    registryFetchIntervalSeconds, TimeUnit.SECONDS);
        }

        if (clientConfig.shouldRegisterWithEureka()) {
            int renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs();
            int expBackOffBound = clientConfig.getHeartbeatExecutorExponentialBackOffBound();
            logger.info(&quot;Starting heartbeat executor: &quot; + &quot;renew interval is: {}&quot;, renewalIntervalInSecs);

            // Heartbeat timer
            heartbeatTask = new TimedSupervisorTask(
                    &quot;heartbeat&quot;,
                    scheduler,
                    heartbeatExecutor,
                    renewalIntervalInSecs,
                    TimeUnit.SECONDS,
                    expBackOffBound,
                    new HeartbeatThread()
            );
            scheduler.schedule(
                    heartbeatTask,
                    renewalIntervalInSecs, TimeUnit.SECONDS);

            // InstanceInfo replicator
            instanceInfoReplicator = new InstanceInfoReplicator(
                    this,
                    instanceInfo,
                    clientConfig.getInstanceInfoReplicationIntervalSeconds(),
                    2); // burstSize

            statusChangeListener = new ApplicationInfoManager.StatusChangeListener() {
                @Override
                public String getId() {
                    return &quot;statusChangeListener&quot;;
                }

                @Override
                public void notify(StatusChangeEvent statusChangeEvent) {
                    logger.info(&quot;Saw local status change event {}&quot;, statusChangeEvent);
                    instanceInfoReplicator.onDemandUpdate();
                }
            };

            if (clientConfig.shouldOnDemandUpdateStatusChange()) {
                applicationInfoManager.registerStatusChangeListener(statusChangeListener);
            }

            instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());
        } else {
            logger.info(&quot;Not registering with Eureka server per configuration&quot;);
        }
    }
</code></pre>
<p>从上面的函数中， 可以看到一个与服务注册相关的判断语旬 if (clientConfig. shouldRegisterWithEureka ())。 在该分支内， 创建了一个 InstanceinfoReplicator 类的实例， 它会执行一个定时任务， 而这个定时任务的具体工作可以查看该类的 run() 函数， 具体如下所示:</p>
<pre><code> public void run() {
        try {
            discoveryClient.refreshInstanceInfo();

            Long dirtyTimestamp = instanceInfo.isDirtyWithTime();
            if (dirtyTimestamp != null) {
                discoveryClient.register();
                instanceInfo.unsetIsDirty(dirtyTimestamp);
            }
        } catch (Throwable t) {
            logger.warn(&quot;There was a problem with the instance info replicator&quot;, t);
        } finally {
            Future next = scheduler.schedule(this, replicationIntervalSeconds, TimeUnit.SECONDS);
            scheduledPeriodicRef.set(next);
        }
    }
</code></pre>
<p>其中discoveryClient.register () ;是真正触发调用注册的地方。继续查看 register ()的实现内容， 如下所示:</p>
<pre><code>/**
     * Register with the eureka service by making the appropriate REST call.
     */
    boolean register() throws Throwable {
        logger.info(PREFIX + &quot;{}: registering service...&quot;, appPathIdentifier);
        EurekaHttpResponse&lt;Void&gt; httpResponse;
        try {
            httpResponse = eurekaTransport.registrationClient.register(instanceInfo);
        } catch (Exception e) {
            logger.warn(PREFIX + &quot;{} - registration failed {}&quot;, appPathIdentifier, e.getMessage(), e);
            throw e;
        }
        if (logger.isInfoEnabled()) {
            logger.info(PREFIX + &quot;{} - registration status: {}&quot;, appPathIdentifier, httpResponse.getStatusCode());
        }
        return httpResponse.getStatusCode() == Status.NO_CONTENT.getStatusCode();
    }
</code></pre>
<p>通过属性命名， 大家基本也能猜出来， 注册操作也是通过REST请求的方式进行的。同时， 我们能看到发起注册请求的时候， 传入了一个 com.netfix.appinfo. Instanceinfo 对象， 该对象就是注册时客户端给服务端的服务的元数据。</p>
<h4 id="服务获取与服务续约">服务获取与服务续约</h4>
<p>DiscoveryClient 的initScheduledTasks 函 数，其中还有两个定时任务，分别是 “ 服务获取 ” 和 “ 服务续约&quot;:</p>
<p>“ 服务获取 ” 任务相对于 “ 服务续约 ” 和 “ 服务注册 “ 任务更为独立。”服务续约 ” 与 “ 服务注册 “ 在同一个 if 逻辑中，这个不难理解，服务注册到 Eureka Server 后， 自然需要一个心跳去续约， 防止被剔除，所以它们肯定是成对出现的。从源码中，我们更清楚地看到了之前所提到的，对于服务续约相关的时间控制参数:</p>
<pre><code>eureka.instance.lease-renewal-interval-in-seconds= 30
eureka.instance.lease-expiration-duration-in-seconds= 90
</code></pre>
<p>而 “ 服务获取 ” 的逻辑在独立的一个if判断中， 其判断依据就是我们之前所提到的 eureka.client.fetch-registry=true参数，它默认为 true, 为了定期更新客户端的服务清单， 以保证客户端能够访问确实健康的服务实例，“服务获取” 的请求不会只限于服务启动，而是一个定时执行的任务，任务运行中的 registryFetchintervalSeconds 参数对应的的eureka.client.registry-fetch-interval-seconds= 30 配置参数， 它默认为 30 秒。</p>
<h3 id="454-服务注册中心处理">4.5.4 服务注册中心处理</h3>
<p>服务注册接收请求</p>
<pre><code>   @POST
    @Consumes({&quot;application/json&quot;, &quot;application/xml&quot;})
    public Response addInstance(InstanceInfo info,
                                @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication) {
        logger.debug(&quot;Registering instance {} (replication={})&quot;, info.getId(), isReplication);
        // validate that the instanceinfo contains all the necessary required fields
        if (isBlank(info.getId())) {
            return Response.status(400).entity(&quot;Missing instanceId&quot;).build();
        } else if (isBlank(info.getHostName())) {
            return Response.status(400).entity(&quot;Missing hostname&quot;).build();
        } else if (isBlank(info.getIPAddr())) {
            return Response.status(400).entity(&quot;Missing ip address&quot;).build();
        } else if (isBlank(info.getAppName())) {
            return Response.status(400).entity(&quot;Missing appName&quot;).build();
        } else if (!appName.equals(info.getAppName())) {
            return Response.status(400).entity(&quot;Mismatched appName, expecting &quot; + appName + &quot; but was &quot; + info.getAppName()).build();
        } else if (info.getDataCenterInfo() == null) {
            return Response.status(400).entity(&quot;Missing dataCenterInfo&quot;).build();
        } else if (info.getDataCenterInfo().getName() == null) {
            return Response.status(400).entity(&quot;Missing dataCenterInfo Name&quot;).build();
        }

        // handle cases where clients may be registering with bad DataCenterInfo with missing data
        DataCenterInfo dataCenterInfo = info.getDataCenterInfo();
        if (dataCenterInfo instanceof UniqueIdentifier) {
            String dataCenterInfoId = ((UniqueIdentifier) dataCenterInfo).getId();
            if (isBlank(dataCenterInfoId)) {
                boolean experimental = &quot;true&quot;.equalsIgnoreCase(serverConfig.getExperimental(&quot;registration.validation.dataCenterInfoId&quot;));
                if (experimental) {
                    String entity = &quot;DataCenterInfo of type &quot; + dataCenterInfo.getClass() + &quot; must contain a valid id&quot;;
                    return Response.status(400).entity(entity).build();
                } else if (dataCenterInfo instanceof AmazonInfo) {
                    AmazonInfo amazonInfo = (AmazonInfo) dataCenterInfo;
                    String effectiveId = amazonInfo.get(AmazonInfo.MetaDataKey.instanceId);
                    if (effectiveId == null) {
                        amazonInfo.getMetadata().put(AmazonInfo.MetaDataKey.instanceId.getName(), info.getId());
                    }
                } else {
                    logger.warn(&quot;Registering DataCenterInfo of type {} without an appropriate id&quot;, dataCenterInfo.getClass());
                }
            }
        }

        registry.register(info, &quot;true&quot;.equals(isReplication));
        return Response.status(204).build();  // 204 to be backwards compatible
    }
</code></pre>
<p>在对注册信息进行了 一 堆校验之后，会调用org.springframework.cloud. netflix.eureka.server.InstanceRegistry对象中的register(Instanceinfo info, int leaseDuration, boolean isReplication)函数来进行服务注册:</p>
<pre><code>  @Override
    public void register(final InstanceInfo info, final boolean isReplication) {
        int leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;
        if (info.getLeaseInfo() != null &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; 0) {
            leaseDuration = info.getLeaseInfo().getDurationInSecs();
        }
        super.register(info, leaseDuration, isReplication);
        replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, null, isReplication);
    }
</code></pre>
<p>在注册函数中， 调用com.netflix.eureka.registry.AbstractlnstanceRegistry父类中的<br>
注册实现，将InstanceInfo中的元数据信息存储在 一个ConcurrentHashMap对象中。 正如我们之前所说的， 注册中心存储了两层Map结构， 第一 层的key 存储服务名:<br>
Insztancelnfo中的appName属性， 第二层的key存储实例名: Instancelnfo中的 instanceId属性。</p>
<pre><code>private final ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; registry
</code></pre>
<h1 id="五-客户端负载均衡-spring-cloud-ribbon">五 客户端负载均衡 Spring Cloud Ribbon</h1>
<p>负载均衡在系统架构中是一 个非常重要， 并且是不得不去实施的内容。 因为负载均衡 是对系统的高可用、 网络压力的缓解和处理能力扩容的重要手段之一 。 我们通常所说的负 载均衡都指的是服务端负载均衡，其中分为硬件负载均衡和软件负载均衡。 硬件负载均衡主要通过在服务器节点之间安装专门用于负载均衡的设备，比如 F5 等;而软件负载均衡则 是通过在服务器上安装一些具有均衡负载功能或模块的软件来完成请求分发工作，比如 Nginx 等。</p>
<p>硬件负载均衡的设备或是软件负载均衡的软件模块都会维护一 个下挂可用的服务端清 单，通过心跳检测来剔除故障的服务端节点以保证清单中都是可以正常访问的服务端节点。 当客户端发送请求到负载均衡设备的时候 ， 该设备按某种算法(比如线性轮询、 按权重负载、 按流量负载等)从维护的可用服务端清单中取出 一台服务端的地址， 然后进行转发。</p>
<p>而客户端负载均衡和服务端负载均衡最大的不同点在于上面所提到的服务清单所存储 的位置。 在客户端负载均衡中， 所有客户端节点都维护着自己要访问的服务端清单， 而这些服务端的清单来自于服务注册中心。在Spring Cloud实现的服务治理框架中， 默认会创建针对各 个服务治理框架的沁bbon自动化整合配置， 比如Eureka 中的 org.springframework. cloud.netflix.ribbon.eureka. RibbonEurekaAutoConfiguration , Consul 中的org.springframework.cloud.consul.discovery. RibbonConsulAuto- Configuration。<br>
通过Spring CloudR巾bon的封装， 我们在微服务架构中使用客户端负载均衡调用非常<br>
简单， 只需要如下两步:</p>
<pre><code>- 服务提供者只需要启动多个服务实例并注册到一个注册中心或是多个相关联的服务注册中心。
- 服务消费者直接通过调用被@LoadBalanced 注解修饰过的 RestTemplate来实现面向服务的接口调用。
</code></pre>
<h2 id="51-ribbon源码分析">5.1 ribbon源码分析</h2>
<h1 id="六-服务容错保护-spring-cloud-hystrix">六 服务容错保护: Spring Cloud Hystrix</h1>
<h1 id="七-卢朋式服务调用-spring-cloud-feign">七 卢朋式服务调用: Spring Cloud Feign</h1>
<h1 id="八-api网关服务spring-cloud-zuul">八 API网关服务：Spring Cloud Zuul</h1>
<h1 id="九-分布式配置中心-spring-cloud-config">九 分布式配置中心: Spring Cloud Config</h1>
<h1 id="十-消息总线-spring-cloud-bus">十 消息总线: Spring Cloud Bus</h1>
<h1 id="十一-消息驱动的微服务-spring-cloud-stream">十一 消息驱动的微服务: Spring Cloud Stream</h1>
<h1 id="十二-分布式服务跟踪-spring-cloud-sleuth">十二 分布式服务跟踪: Spring Cloud Sleuth</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[flowable使用注意事项]]></title>
        <id>https://q456qq520.github.io/post/flowable-shi-yong-zhu-yi-shi-xiang/</id>
        <link href="https://q456qq520.github.io/post/flowable-shi-yong-zhu-yi-shi-xiang/">
        </link>
        <updated>2022-03-21T07:02:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="表结构分析">表结构分析</h1>
<p>ACT_EVT_*</p>
<pre><code>ACT_EVT_LOG: 事件日志相关
ACT_PROCDEF_INFO: 当通过缓存保存的流程信息
</code></pre>
<p>ACT_GE_*</p>
<pre><code>ACT_GE_BYTEARRAY：保存流程的bpmn的xml以及流程的Image缩略图等信息
ACT_GE_PROPERTY：Flowable相关的基本信息。比如各个module使用的版本信息。
</code></pre>
<p>ACT_RE_*</p>
<pre><code>ACT_RE_DEPLOYMENT: 部署对象，存储流程名称 租户相关
ACT_RE_MODEL：基于流程的模型信息
ACT_RE_PROCDEF：流程定义表
</code></pre>
<p>ACT_RU_*(Runtime相关)</p>
<pre><code>ACT_RU_ACTINST：运行中实例的活动表
ACT_RU_DEADLETTER_JOB：当JOB执行很多次都无法执行，就会被记录在此表
ACT_RU_ENTITYLINK：还没使用到。后续更新此表。
ACT_RU_EVENT_SUBSCR：运行时的事件
ACT_RU_EXECUTION：运行的实例表
ACT_RU_HISTORY_JOB； 运行中的定时任务历史表
ACT_RU_IDENTITYLINK： 当前任务执行人的信息
ACT_RU_JOB：运行中的异步任务
ACT_RU_SUSPENDED_JOB：暂停的任务表。如果一个异步任务在运行中，被暂停。就会记录在词表
ACT_RU_TASK：运行中的正常节点任务
ACT_RU_TIMER_JOB：定时作业表
ACT_RU_VARIABLE：运行中的流程实例变量
</code></pre>
<p>ACT_ID_*(IDM模块。用户相关)</p>
<p>这块其实基于我个人想法，不建议使用。但是如果是以工作流为核心，为业务的公司，比如专门做OA的公司。鄙人是制造业相关出身，故工作流这块的IDM没有使用。都是业务系统进行WorkFlowEngine的调用而已。</p>
<pre><code>ACT_ID_BYTEARRAY：
ACT_ID_GROUP：用户组信息
ACT_ID_INFO：用户详情
ACT_ID_MEMBERSHIP：用户组和用户的关系
ACT_ID_PRIV：权限
ACT_ID_PRIV_MAPPING：用户组和权限之间的关系
ACT_ID_PROPERTY：用户或者用户组属性拓展表
ACT_ID_TOKEN：登录相关日志
ACT_ID_USER：用户
</code></pre>
<p>ACT_HI_*(历史相关)</p>
<pre><code>ACT_HI_ACTINST: 流程实例历史
ACT_HI_ATTACHMENT：实例的历史附件，几乎不会使用，会加大数据库很大的一个loading
ACT_HI_COMMENT：实例的历史备注
ACT_HI_DETAIL：实例流程详细信息
ACT_HI_IDENTITYLINK: 实例节点中，如果指定了目标人，产生的历史
ACT_HI_PROCINST：流程实例历史
ACT_HI_TASKINST：流程实例的任务历史
ACT_HI_VARINST：流程实例的变量历史
</code></pre>
<p>FLW_*</p>
<pre><code>FLW_CHANNEL_DEFINITION: 泳池管道定义表
FLW_EVENT_DEFINITION：事件定义
FLW_EVENT_DEPLOYMENT：事件必输
FLW_EVENT_RESOURCE：事件所需资源
FLW_EV_DATABASECHANGELOG：Liquibase执行的记录
FLW_EV_DATABASECHANGELOGLOCK：Liquibase执行锁
FLW_RU_BATCH：暂时未知
FLW_RU_BATCH_PART：暂时未知</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[流程引擎]]></title>
        <id>https://q456qq520.github.io/post/liu-cheng-yin-qing/</id>
        <link href="https://q456qq520.github.io/post/liu-cheng-yin-qing/">
        </link>
        <updated>2022-03-17T08:12:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="流程概念">流程概念</h1>
<h2 id="流程的定义">流程的定义</h2>
<p>维基百科：对工作流程及其各操作步骤之间业务规则的抽象、概括描述。即将工作流程中的工作如何前后组织在一起的逻辑和规则。</p>
<p>流程就是一组活动按照一定的顺序组成的序列流，其顺序可能是串行的、并行的，或者两者的组合模式</p>
<p>流程一般具备六个要素：输入、活动、活动间的相互作用、输出、流程的服务对象和价值。</p>
<ul>
<li>输入：是运作流程所必须的资源</li>
<li>输出：流程运作的结果</li>
<li>活动：是流程运作的环节</li>
<li>活动间的相互作用：是环节之间的关系，把流程从头尾串联起来</li>
<li>价值：是流程运作为流程的服务对象带来的好处</li>
<li>流程的服务对象：是流程服务的对象，也叫做流程的下一个环节</li>
</ul>
<h1 id="为什么要用流程引擎">为什么要用流程引擎</h1>
<h2 id="工作流程常见问题">工作流程常见问题</h2>
<ol>
<li>
<p>做需求时考虑不周全，上线后不断修改流程。</p>
</li>
<li>
<p>组织架构调整，产生业务流程变更。</p>
</li>
<li>
<p>业务流程比较复杂，使用的状态很多。</p>
</li>
<li>
<p>工作流业务耦合度太高，很多场景不适用。</p>
</li>
</ol>
<h2 id="例子">例子</h2>
<p>假定我们有一个支付订单状态需要维护，它的状态图如下：</p>
<p>它的状态跃迁自左向右，清晰名了，而且没有处理角色的概念，此时我们使用代码控制好状态流转即可，无需使用框架。</p>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1647572517222.png" alt="流程1" loading="lazy"></figure>
<p>假设有一天流程变更为下图所示：</p>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1647572617376.png" alt="流程2" loading="lazy"></figure>
<p>如果是开发人员，看到的则是：</p>
<pre><code>public function doSomething(int case){
   if(case == 0){
       //业务逻辑
       retutn;
   }
    if(case == 1){
       //业务逻辑
       retutn;
   }
    if(case == 2){
       //业务逻辑
       retutn;
   }
   .
   .
   .
}
</code></pre>
<p>这个采购订单的状态复杂多变，状态的转换不稳定性很强，随时有可能增加新的状态；而且不同状态的处理人也是不同的，存在权限管理功能，若此时我们仍然使用一个状态字段来维持状态变更，无疑会困难重重。</p>
<p>复杂繁多的业务流程如果采用 if else 实现那将是崩溃的，代码不可维护，业务流程在代码中可读性很差，所以就有了业务流程模型图示 BPMN2.0 规范，我们要做到就是把业务场景抽象为标准流程图，把流程图丢到流程引擎中按流程定义约定逐步流转，很显然扩展性和业务可描述性会好很多，所以工作流引擎主要用于解决复杂的业务。</p>
<h2 id="流程引擎适用场景">流程引擎适用场景</h2>
<ol>
<li>
<p>状态的个数及其稳定性，个数多且不稳定，适合使用工作流引擎。</p>
</li>
<li>
<p>每个状态的处理人，处理人角色多且不稳定，适合使用工作流引擎。</p>
</li>
</ol>
<h2 id="流程引擎优缺点">流程引擎优缺点</h2>
<h3 id="优点">优点</h3>
<pre><code>- 具有可视化的流程设计工具
- 业务数据和流程数据的分离，可以进行更专注的性能优化，业务划分
- 内置API能很好的完成常见的功能场景
- 具有完善的流程监控体系
- 具备大量的自定义扩展接口
</code></pre>
<h1 id="工作流规范简介">工作流规范简介</h1>
<p>20 世纪 70 年代中期，工作流出现并运用于办公自动化领域，使流程管理技术第一次有了系统的技术规范。20 世纪 80 年代 初期，工作流伴随着 OA 系统走向商用，但是应用范围有限。至 80 年代后期，OA 系统的研究被群件和工作流管理系统所代替。20 世纪 90 年代以后，相关技术逐渐成熟，工作流管理联盟(WfMC)成立并发布了工作流参考模型。进入 21 世纪， BPM 更进一步发展。SOA 的出现使得流程管理技术从工作流转向业务流，基于此的一系列规范也相应被推出。</p>
<figure data-type="image" tabindex="3"><img src="https://q456qq520.github.io/post-images/1647574593657.png" alt="流程管理技术发展时间线" loading="lazy"></figure>
<h2 id="bpmn20-规范">BPMN2.0 规范</h2>
<p>业务流程模型和标记法（BPMN, Business Process Model and Notation）是一套图形化表示法，用于以图形的方式详细说明各种业务流程。</p>
<p>它最初由业务流程管理倡议组织（BPMI, Business Process Management Initiative）开发，名称为”Business Process Modeling Notation”，即“业务流程建模标记法”。BPMI 于 2005 年与对象管理组织（OMG, Object Management Group）合并。2011 年 1 月 OMG 发布 2.0 版本（时至今日，没人会用 1.0 版本了），同时改为现在的名称。</p>
<p>BPMN2.0 规范的实现，实质上是一个按照特定规范编写的 XML 文件，使用特定的 BPMN 设计器，即可以图形化的形式查看和编辑该文件。Camunda，Activiti，Flowable 等主流的 java 开源流程引擎，以代码的形式实现了这套图形化表示法，使任务的流转依赖图形，而非具体的实现代码。</p>
<figure data-type="image" tabindex="4"><img src="https://q456qq520.github.io/post-images/1647574956600.png" alt="BPMN2.0规范图1" loading="lazy"></figure>
<h1 id="开源流程引擎">开源流程引擎</h1>
<p>目前 java 主流的开源流程引擎，有 jBPM，Activiti，Camunda，Flowable 等</p>
<p>Activiti<br>
Activiti 由 Alfresco 公司开发，目前最高版本为 Activiti cloud 7.1.0。其中 activiti5 和 activiti6 的核心 leader 是 Tijs Rademakers，由于团队内部分歧，2017 年 Tijs Rademakers 离开团队，创建了后来的 Flowable。activiti6 以及 activiti5 代码则交接给 Salaboy 团队维护，activiti6 以及 activiti5 的代码官方已经暂停维护。往后 Salaboy 团队开发了 activiti7 框架，activiti7 内核使用的还是 activiti6，并没有为引擎注入更多的新特性，只是在 Activiti 之外的上层封装了一些应用。直到 Activiti cloud 7.1.0 版本，Activiti cloud 将系统拆分为 Runtime Bundle、Audit Service、Query Service、Cloud Connectors、Application Service、Notification Service。这些工作的主要目的其实就是为了上云，减少对 Activiti 依赖的耦合，需要使用 Activiti 的系统只需要通过调用 http 接口的方式来实现工作流能力的整合，将工作流业务托管上云。</p>
<p>Flowable<br>
Flowable 是基于 activiti6 衍生出来的版本，目前最新版本是 v6.7.0。开发团队是从 Activiti 中分裂出来的，修复了一众 activiti6 的 bug，并在其基础上实现了 DMN 支持，BPEL 支持等。相对开源版，其商业版的功能会更强大。Flowable 是一个使用 Java 编写的轻量级业务流程引擎，使用 Apache V2 license 协议开源。2016 年 10 月，Activiti 工作流引擎的主要开发者离开 Alfresco 公司并在 Activiti 分支基础上开启了 Flowable 开源项目。Flowable 项目中包括 BPMN（Business Process Model and Notation）引擎、CMMN（Case Management Model and Notation）引擎、DMN（Decision Model and Notation）引擎和表单引擎（Form Engine）等模块。</p>
<p>Camunda<br>
Camunda 基于 activiti5，所以其保留了 PVM，最新版本 Camunda7.17，开发团队也是从 activiti 中分裂出来的，发展轨迹与 Flowable 相似。通过压力测试验证 Camunda BPMN 引擎性能和稳定性更好。功能比较完善，除了 BPMN，Camunda 还支持 CMMN（案例管理）和 DMN（决策自动化）。Camunda 不仅带有引擎，还带有非常强大的工具，用于建模、任务管理、操作监控和用户管理。</p>
<p>jBPM<br>
jBPM 由 JBoss 公司开发，目前最高版本 7.61.0.Final，不过从 jBPM5 开始已经跟之前不是同一个产品了，jBPM5 的代码基础不是 jBPM4，而是从 Drools Flow 重新开始，基于 Drools Flow 技术在国内市场上用的很少，jBPM4 诞生的比较早，后来 jBPM4 创建者 Tom Baeyens 离开 JBoss 后，加入 Alfresco 后很快推出了新的基于 jBPM4 的开源工作流系统 Activiti，另外 jBPM 以 Hibernate 作为数据持久化 ORM，而 Hibernate 也已不是主流技术。</p>
<p>osworkflow<br>
osworkflow 是一个轻量化的流程引擎，基于状态机机制，数据库表很少，osworkflow 提供的工作流构成元素有：步骤（step）、条件（conditions）、循环（loops）、分支（spilts）、合并（joins）等，但不支持会签、跳转、退回、加签等这些操作，需要自己扩展开发，有一定难度。如果流程比较简单，osworkflow 是很好的选择。</p>
<p>选型建议：</p>
<pre><code>Flowable6 &gt; Activiti7 &gt; Activiti6 &gt; Activiti5 &gt; Camunda &gt; jBPM7
</code></pre>
<h1 id="表单引擎">表单引擎</h1>
<p>表单引擎，也可以称为表单流程，流程表单和工作流表单，为快速实施项目研发的轻量级表单设计工具,是基于Web界面上可视化编辑的表单设计系统。它可以设置数据库的字段和属性，并设置模块的配置。采用表单引擎工具可在不开发和新增加代码的情况下设计出新表单样式，同比程序开发可省掉程序员差不多70%的开发工作量，并且后期维护相对简单，管理方便。</p>
<h2 id="表单构成">表单构成</h2>
<p>表单内容一般由基本信息、逻辑主体、补充说明三部分构成：</p>
<p>基本信息：基本就是常规信息，差不多每个表单都会用到的，例如：发起人、发起组织、发起时间等身份标识，与业务相关的客户基本信息或者合同基本信息等。</p>
<p>逻辑主体：流程的主要部分，相当于流程的详细描述，涉及逻辑交互、数据交互等，比如合同具体成交的业务类型、费用、数量、付款和回款信息等。</p>
<p>补充说明：作为逻辑主体没有表达清楚的补充说明，例如备注、说明、附件等让相关人员将表单没表达清楚的部分表达清楚。</p>
<h2 id="字段设置">字段设置</h2>
<p>字段设置个性化、灵活性越高，流程引擎能面向的用户则更广，能达到的管理要求也更高。</p>
<p>1）字段排版排序：字段排版、排序要符合用户使用习惯，有逻辑关联的字段要放一起，不要隔开；例如：客户姓名后放了一堆合同信息，最后又放一个客户地址，这样填写和审批都不方便，打乱使用者思维；合理的排序在数据列表展示或导出时都省事不少，表单在使用过程中会不断优化调整，优化后的字段页面上也要及时取消，避免增加页面空值字段。</p>
<p>2）字段查看权限：有的字段比如上传的附件资料，不允许某些节点处理人查阅，则会限制查看。</p>
<p>3）字段编辑权限：不是所有字段在所有节点都允许编辑，所以要根据字段的数据管理要求来设置字段在不同节点的编辑属性。</p>
<p>4）字段留痕：字段修改和留痕关联，重要的字段修改后如果找不到修改人只有系统背锅。有的字段在员工节点填写后，上级节点需要再确认修改；或者流程已结束再修改字段内容的情况就需要将修改痕迹保留下来；留痕就是日志，需要考虑痕迹的重要性，如果重要性不高的字段就不必设置留痕，浪费服务器空间。</p>
<p>5）字段只读：自动填充的关联数据有的能修改，有的不能修改，如果有只读这个控制开关便能更好管理，默认情况应该将自动填充的关联数据都设置只读；设置了只读的字段，一定要关闭必填属性，否则当关联数据空值或者关联失败时，用户是无法提交表单的，设计者应该避免犯这种常规错误。</p>
<p>6）修改字段值：很多流程结束后但需要修改页面内容，需要考虑是否允许不通过节点，直接更改页面表单值，如果允许直接修改已有值，那必须得留痕；但应该尽量避免这种情况，如果直接修改已有值会让流程规范变得更难，使用者对于规范会越来越不重视。</p>
<h2 id="关联数据">关联数据</h2>
<p>1）页面字段数据：表单除了要手动输入的数据外，还有很多数据是由其他表单关联过来的；选择关键字段后会自动带出关联数据，有的表单可能一个字段都不填，打开流程所有数据都自动填充了；有的数据也只需要选择关键字段就自动填充；常规人事、行政审批对数据串联要求不高，但财务或者业务，逻辑关联性较强，涉及数据多，数据串联就变得非常重要。</p>
<p>2）流程相关数据：除了自动填充表单字段数据外，还要将影响审批判断但表单上没有的数据体现出来，便于审批；例如项目请款，同一个合同所有的请款历史、项目信息都应该展示出来，让审批人能快速做审批判断。</p>
<h2 id="表单引擎单优点">表单引擎单优点</h2>
<p>1.技术人员在有详细需求文档的情况下，通过表单引擎可快速实现表单功能。</p>
<p>2.轻松维护系统。</p>
<p>3.提高工作效率。即使是个性化的系统定制也可以批量化的实现业务功能。</p>
<p>4.快速更新。您可以随时根据用户要求添加或删除字段和统计信息，摘要以及数据导入和导出，而无需修改任何代码行。可以在半小时内自定义演示，以赢得客户的信任。</p>
<p>5.个性化的DIY系统。使用表单引擎系统快速定义其他系统，例如：行政管理，客户关系，采购管理，请假表单，人事档案等。</p>
<h2 id="表单引擎设计思想">表单引擎设计思想</h2>
<p>基于文件模式的与基于关系型数据库模式的。</p>
<h3 id="基于文件设计的">基于文件设计的</h3>
<p>基于文件设计的思想是，创建表单的时候，首先创建一个文件比如：xxxx.jsp,xxx.aspx,xxx.php 文件。在这个文件上拖放相关的控件，或者加载相关的通用js代码,或者在对字段Input元素做特殊的标记，让表单引擎解析执行。</p>
<p>表单运行时，运行的界面载体是一个Url文件地址，这个地址引用到相关的菜单上去。</p>
<p>基于文件设计思想的表单引擎系统，需要由软件开发工作者首先设计好项目需要的网页内容，进行封装和部署后，生成使用者可以编辑的表单结构。因为是定制化开发可满足不同的表单样式、表单模板等的设计，能最大程度的符合企业管理者的需求。</p>
<p>弊端一、文件表单布局排版是固定化的，需要改动就需要联系研发人员进行重新设计页面布局，耗时长。</p>
<p>弊端二、该设计模式不能适用于多种行业的表单需求。如现有的系列OA请假报销等表单文件是不能使用项目管理、公文审批等表单引擎需要的。只能是需要开发者根据后者的表单要求重新研发网页功能，从而导致现有表单系统的不可复用性，以及开发多套表单引擎系统投入的大量的人力研发。</p>
<h3 id="基于关系数据库设计">基于关系数据库设计</h3>
<p>基于关系数据库设计的组成部分是表单设计器、表单解析执行器、表单模板三部分组成。</p>
<p>表单设计器，把表单元素都按照关系表存储到数据库里面，每个表单有一个ID，这个表单ID，挂接到表单的解析执行器上，就可以工作。</p>
<p>表单模板将从表单设计器上设计组件关系存储到数据库中，由各个组件表组成的数据间的关系拼接成表单模板。</p>
<p>表单解析执行器是将表单模板数据进行解析，将解析后的数据形态以网页的形式展现</p>
<p>基于关系数据库的设计模式将表单引擎系统封装为一个设计工具，任何需要的表单只需要在该工具上进行拖拽设计即可，拖拽生成表单数据以数据流的形式存放在数据库中，由系统内置的表单解析器解析和展示填写的内容。该过程无须研发人员改动，表单设计人员可随意使用表单设计工具实现目标表单。</p>
<p>弊端是表单展示为统一风格，较为单调。</p>
<h2 id="表单引擎类型">表单引擎类型</h2>
<pre><code>1. 自由表单
2. 自定义表单
3. 开发者表单
4. Office表单
</code></pre>
<h1 id="表单-流程引擎的关系">表单、流程引擎的关系</h1>
<p>流程引擎与表单引擎的关系，就是车的制动系统与车厢的关系。</p>
<p>汽车的控制系统控制前进、转向、后退、鸣笛、刹车等，流程引擎控制功能有发送、移交、退回、关注、删除等。</p>
<p>汽车的车厢可以填充货物，流程的表单可以传递数据。汽车的控制系统、车厢、货物与流程引擎、表单引擎、表单数据三者的关系类似。</p>
<p>表单引擎与流程引擎，就类似于汽车的控制系统与汽车的车厢一样。</p>
<p>流程 = 控制系统  表单 = 货物盒子  数据 = 货物</p>
<h2 id="引擎测试">引擎测试</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高性能Mysql]]></title>
        <id>https://q456qq520.github.io/post/gao-xing-neng-mysql/</id>
        <link href="https://q456qq520.github.io/post/gao-xing-neng-mysql/">
        </link>
        <updated>2022-03-15T06:12:26.000Z</updated>
        <content type="html"><![CDATA[<h6 id="文章基于mysql55">文章基于mysql5.5</h6>
<h1 id="一-mysql架构与历史">一 mysql架构与历史</h1>
<h2 id="11-mysql逻辑架构">1.1 mysql逻辑架构</h2>
<p>下图为mysql各组件之间协同工作的架构图<br>
<img src="https://q456qq520.github.io/post-images/1647325954273.png" alt="mysql逻辑架构图" loading="lazy"></p>
<ol>
<li>最上层不是mysql特有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。</li>
<li>第二层为大多数mysql核心服务所在的位置，包括解析、分析、优化、缓存及所有内置函数、所有跨存储引擎的功能（存储过程、触发器、视图等）都在这一层实现。</li>
<li>第三次包含了存储引擎，负责数据都存储与提取。</li>
</ol>
<h3 id="111-连接管理与安全性">1.1.1 连接管理与安全性</h3>
<p>每个客户端连接都会在服务器进程中<strong>拥有</strong>一个线程，这个连接对查询只会单独在这个线程中执行，该线程只能轮流在某个cpu中运行，服务器会负责缓存栈线程，因此不必每个新建的连接都需要创建或者销毁线程。</p>
<h3 id="112-优化与执行">1.1.2 优化与执行</h3>
<p>mysql会解析查询，并创建内部数据结构（解析树），然后对其进行优化。包括重新给查询、决定表的读取顺以及选择合适的索引等。</p>
<p>对于select语句在解析查询之前，服务器会先检查查询缓存如果能能在其中找到对应的查询，服务器就不必在执行查询解析。</p>
<h2 id="12-并发控制">1.2 并发控制</h2>
<p>无论何时，只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题。下面将从2个方面在说明并发控制：服务器层与存储引擎层。</p>
<h3 id="121-读写锁">1.2.1 读写锁</h3>
<p>读取数据的时候，即使同一时刻有多个用户读取数据也不会有什么问题，因为此时数据没有发生改变，用户读到到数据都是同一份。</p>
<p>但是如果在读取到时候另一个用户试图修改数据，就有可能读错或者读取到数据不一致到情况。</p>
<p>解决这类问题到方法就是并发控制，在处理并发读或者写时，可以通过实现由2种类型的锁组成的锁系统来解决问题。也就是俗称的<strong>共享锁</strong>与<strong>排他锁</strong>，也叫做读锁或者写锁。读锁是共享的，或者说是互不阻塞的，多个用户可以在统一时刻读取‍同一资源而且互不干扰。写锁是排他的，也就是说一个写锁会阻塞其他的写锁或者读锁，确保在给定时间内只有一个用户能执行写入操作，防止其他用户读取正在写入的其他资源，这也是处于安全策略的考虑。</p>
<h3 id="122-锁粒度">1.2.2 锁粒度</h3>
<p>一种提高共享资源并发性的方式就是让锁定的对象更具选择性。尽量只锁定需要修改的部分数据，而不是所有资源，更理想的方式就是只会对需要修改的数据片进行精确的锁定。任何时候，在给定的资源上，锁定的数据流越少，系统的并发性越高。只要相互之间不发生冲突即可。</p>
<p>问题是加锁也需要消耗资源。锁的各种操作，包括获得锁，检查锁是否以及接触、释放锁等都会增加系统的开销。如果花费大量时间来管理锁而不是存取数据，那么系统的性能也会因此受到影响。</p>
<p>所谓锁策略，就是在锁开销与数据安全性之前平衡，这种平衡也会影响到性能，这是不可避免的。大多数都是在表上加行级锁，并以各种复杂的方式来实现，以便在锁较多的情况下尽可能地提供更好的性能。</p>
<p>在mysql中每种存储引擎都可以实现自己的锁策略和锁粒度。将锁粒度固定在某个级别可以更好为某些特定场景提供性能支持，但同时也会失去对另一些应用场景对良好支持。</p>
<h3 id="123-表锁">1.2.3 表锁</h3>
<p>表锁是mysql最基本的锁策略，并且是开销最小的锁策略。他的工作思路是会锁住整张表，一个用户对表进行插入、更新、删除操作需要先获得锁，这回阻塞娶她用户对这张表的读写操作。只要没有写锁时，其他用户才能获得读锁，读锁之前是不互相阻塞的。</p>
<p>在某些特定的场景下，表锁也有良好的性能。比如READ LOCAL支持某些类型的并发写操作。另外，写锁也比读锁拥有更高的优先级，因此一个写锁请求可能会被插入到读锁请求队列前面，但是反之则不能。</p>
<h3 id="124-行级锁">1.2.4 行级锁</h3>
<p>行级锁能够最大程度的支持并发处理，但是也会带来最大的锁开销。行级锁只能子啊存储引擎中实现。</p>
<h2 id="13-事务">1.3 事务</h2>
<h3 id="acid">ACID</h3>
<p>一个运行良好的事务处理系统，必须满足下列4点：原子性、一致性、隔离性、持久性。</p>
<ul>
<li>
<p>原子性 ：</p>
<ul>
<li>一个事务必须被视为不可分割的最小工作单元，整个事务中的所有操作要么全部执行成功，要么全部失败回滚。对于一个事务来说，不可能只执行其中的某一部分。</li>
</ul>
</li>
<li>
<p>一致性：</p>
<ul>
<li>数据库总是从一个一致性状态转换到另外一个一致性状态。</li>
</ul>
</li>
<li>
<p>隔离性：</p>
<ul>
<li>通常来说，一个事务所做的修改在最终提交以前对其他事务来说是不可见的。但是数据库对隔离级别会影响这个操作。</li>
</ul>
</li>
<li>
<p>持久性：</p>
<ul>
<li>一旦事务提交，其所做对修改就会永久保存到数据库中。即使此时系统崩溃，修改的数据也不会丢失。</li>
</ul>
</li>
</ul>
<h3 id="131-事务隔离级别">1.3.1 事务隔离级别</h3>
<ol>
<li>
<p>未提交读（READ UNCOMMITED）</p>
<p>在此级别事务的修改即使没有提交，对其他事务也是可见的。事务可以读到未提交到数据，这也被称为脏读。这个级别会导致很多问题，但性能也不会比别的级别好太多，但却缺乏别的级别的好处，所以一般条件下不会使用。</p>
</li>
<li>
<p>读以提交（READ COMMITED）</p>
<p>一个事务从开始知道提交之前，所做的任何修改对其他事务都是不可见的。这个级别也叫做不可重复读。因为两次执行相同的查询，可能读到到结果不一样。</p>
</li>
<li>
<p>可重复度（REPEATABLE READ）</p>
<p>可重复度解决了脏读的问题，该级别保证了在同一事物多次读取同样的记录的结果是一致的。但是可重复读还是无法解决另外一个问题--幻读。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的纪录，当之前的事务再次读取该范围的记录时，就会产生幻行。INnoDb和XtraDB存储引擎通过多版本并发控制MVCC解决了幻读的问题。</p>
</li>
<li>
<p>可串行化（SERIALIZABLE）</p>
<p>可串行化（SERIALIZABLE）是最高的隔离级别，它通过强制事务串行执行，避免了前面说的幻读的问题。简单来说可串行化（SERIALIZABLE）会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。实际生产过程中很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接收没有并发的情况下才会考虑使用该级别。</p>
</li>
</ol>
<h3 id="132-死锁">1.3.2 死锁</h3>
<p>死锁是指两个或者多个事务在统一资源上相互占用，并请求锁定对方占的资源，从而导致恶心循环的现象。当多个事务视图以不同的顺序锁定资源时，就坑会产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。</p>
<p>为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制。还有一个解决方式，就是当查询的时候达到锁等待超时的设定后放弃锁请求，这种方式通常来说不太好。InnoDB目前处理死锁的方式是，将持有最少行级排他锁的事务进行回滚。</p>
<h2 id="多版本并发控制">多版本并发控制</h2>
<p>Mysql的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑。他们一般都同时实现了多版本并发控制（MVCC）。</p>
<p>可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞但读操作，写操作也只锁定必要但行。</p>
<p>MVCC的实现是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p>
<p>不同的存储引擎的MVCC实现是不同的，典型的又乐观并发控制和悲观并发控制。</p>
<p>InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列一个保存了行的创建时间，一个保存行的过期时间。当然保存的并不是实际的时间值，而是系统的版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<p>下面看一下Repeatable read隔离级别下MVCC具体是如何操作的。</p>
<p><strong>SELECT</strong></p>
<pre><code>InnoDB会根据以下两个条件检查每行记录：
a：InnoDB指查找版本早于当前事务的数据行，这样可以确保事务读取的行要么是在事务开始前就已经存在的，要么就是事务自身插入或者修改过的。
b：行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。
只有复核上述两个条件的记录才能返回作为查询结果。
</code></pre>
<p><strong>INSERT</strong></p>
<pre><code>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。
</code></pre>
<p><strong>DELETE</strong></p>
<pre><code>InnoDB为删除的每一行保存当前系统版本号作为行删除标识。
</code></pre>
<p><strong>UPDATE</strong></p>
<pre><code>InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识。
</code></pre>
<p>保存这两个额外系统版本号，是大多数读操作都可以不用加锁。这是设计使得读数据操作很简单，性能很好<br>
并且也能保证只会读取到复核标准的行。不足指出是每行记录都需要额外的存储空间，需要做更多的行检查工作以及一些额外的维护工作。</p>
<p>MCVV只在REPEATABLE READ和READ COMMITED两个级别下工作。其他两个隔离级别都和MVCC不兼容，因为<br>
READ UNCOMMITED总是读取最新的数据行，而不是复核当前事务版本的数据行。而SERIALIZABLE则会对所有读取的行都加锁。</p>
<h2 id="15-mysql的存储引擎">1.5 Mysql的存储引擎</h2>
<p>在文件系统中，Mysql将每个数据库（也可以称之为Schema）保存为数据目录下的一个子目录。创建表时，Mysql会在数据哭子目录下创建一个和表同名的.frm文件保存表的定义。可以使用SHOW TABLE STATUS命令显示表的相关信息。</p>
<h3 id="151-innodb存储引擎">1.5.1 InnoDB存储引擎</h3>
<p>InnoDB是mysql的默认事务型引擎，也是最重要使用最广泛的存储引擎。它被设计用来处理大量的短期事务，短期事务大部分情况是正常提交的。很少会被回滚。InnoDB的性能和自动崩溃恢复特性，使得它在非事务型存取的需求中也很流行。</p>
<p>InnoDB的数据存储在表空间中，表空间是由InnoDB管理的一个黑盒子，由一系列的数据文件组成。InnoDB可以将每个表的数据和索引存放在单独的文件中。</p>
<p>InnoDB采用MVCC来支持高并发，并且实现来四个标准的隔离级别。其默认级别是PEPEABTABLE READ（可重复度），并且通过间隙锁策略防止幻读的出现。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。</p>
<p>InnoDB是基于聚簇索引建立的，聚簇索引对主键查询有很高的性能。不过它的二级索引（非主键索引）中必须包含主键列，索引主键列很大的话，其他的所有索引都会很大，所以标上的所以比较多的话，主键应当尽可能的小。</p>
<h1 id="二-创建高性能索引">二 创建高性能索引</h1>
<p>索引是存储引擎用于快速找到记录的一种数据结构。</p>
<h2 id="21-索引基础">2.1 索引基础</h2>
<p>索引可以包含一个或者多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为mysql只能高校地使用索引的<strong>最左前缀列</strong>。</p>
<h3 id="索引的类型">索引的类型</h3>
<p><strong>B-Tree索引</strong></p>
<p>它使用B-tree数据结构来存储数据，大多数mysql引擎都支持这种索引。</p>
<p>B-tree通常意味着所有的值是按顺序存储的，并且每一个叶子页到根到距离相同。下图为建立在B-tree结构上到索引：</p>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1648450168485.png" alt="" loading="lazy"></figure>
<p>B-tree索引能够加快范根数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根结点开始进行搜索。根结点的槽中存放来指向自节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值看可以找到合适的指针进入下层子节点，这些指针实际上定义来子节点页中值的上限和下限。最终存取引擎要么是找到对应的值，要么该记录不存在。</p>
<p>叶子节点比较特别，他们的指针指向的是被索引的数据，而不是其他的节点页。树的深度和表的大小之间相关。</p>
<p>B-tree对索引列是顺序组织存储的，所以很适合查找范围数据。例如，在一个基于文本域的索引树上，按字母顺序传递连续的值进行查找是非常合适的。</p>
<p>可以使用B-tree索引的查询类型。B-tree索引适用于全键值、键值范围活键前缀查询。其中键前缀查找只适用于根据最左前缀的查找。前面所述的索引对如下类型的查询有效。</p>
<p>全值匹配<br>
全值匹配  指的是和索引中所有列进行匹配。</p>
<p>匹配最左前缀<br>
只使用索引第一列进行匹配。</p>
<p>匹配列前缀<br>
页可以指匹配某一列的值的开头部分， 例如匹配姓名为谭开头的人。</p>
<p>匹配范围值<br>
匹配在范围之间的人，只使用索引的第一列。</p>
<p>精确匹配某一列并范围匹配另外一列<br>
例如查询所有姓为jack而且名字是字母k开头的人。即第一列全匹配，第二轮范围匹配。</p>
<p>只访问索引的查询<br>
即查询只需要访问索引而无需访问数据行。</p>
<p>因为索引树的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的ORDER BY操作。一般来说，如果B-Tree可以按照某种方式查找到值，那么页可以按照这种方式用于排序。所以如果BRDER BY子句满足前面列出的集中查询类型，则这个索引也可以满足对应的排序需求。</p>
<p>下面是一些关于B-Tree索引的限制：</p>
<ul>
<li>如果不是按照索引的最左列开始查询，则无法使用索引。</li>
<li>不能跳过索引中的列。</li>
<li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。</li>
</ul>
<p><strong>哈希索引</strong><br>
哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对搜有的索引列计算一个哈希码，哈希码是一个比较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p>
<p>实际上，使用哈希索引的引擎只有Memory。所以这边不过多赘述。</p>
<p><strong>空间数据索引R-Tree</strong></p>
<p>MyISAM表支持空间索引，可以用作地理数据存储。和B-Tree索引不同，这类索引无需前缀查询。空间索引会从所有纬度来索引数据。查询时，可以有效地使用任意维度来组合查询。</p>
<p><strong>全文索引</strong></p>
<p>全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是之间比较索引中的值。全文搜索和其他的几类索引的匹配方式完全不一样。它有许多需要注意的细节，如停用词、词干和附属、布尔搜索等。全文索引更类似于搜索引擎做的失去，而不是简单的where条件匹配。</p>
<p><strong>其他索引类别</strong></p>
<p>还有很多第三方的存取引擎使用不同的数据结构累存储索引。例如TokuDB使用分形树索引，它既有b-<br>
tree的很多有点也避免来b-tree的一些缺点。</p>
<h2 id="22-索引的优点">2.2 索引的优点</h2>
<p>索引可以让服务器快速地定位到表到指定位置。但是这并不少索引到唯一作用，到目前为止可以看到，根据创建索引到数据结构不同，索引也有一些其他到附加作用。</p>
<p>最常见到B-tree索引，按照顺序存储数据，所以mysql可以用来做Order by 和Group by操作。因为数据是有序到，所以B-Tree也就会将相关到列值都存储在一起，最后，因为索引中存储都实际都列值，所以某些查询只使用索引就能够完成全部查询，根据此特性，总结下来索引有如下三个优点：</p>
<pre><code>1. 索引大大减少列服务器需要扫描都数据量
2. 索引可以帮助服务器避免排序和临时表
3. 索引可以将随机I/O变为顺序I/O
</code></pre>
<p>索引并不总是最好的工具。总的来说，只有当索引帮助存储引擎快速查找到记录带来带好处大于其带来带额外工作时，索引才是有效带。对于非常小的表，大部分情况下简单的全表扫描更高效。对于中到大型到表，索引就非常有效。但对于特大型但表，建立和使用索引但代价将随之增长。这种情况下，则需要一种技术可以直接区分出查询需要的一组数据，而不是一条记录一条记录的匹配。例如可以使用分区技术。如果表的数量特别多，可以建立一个元数据信息表，用来查询需要用到的某些特性。例如指向那些需要聚合多个应用分布在多个表的数据的查询，则需要记录哪个用户的信息存储在哪个表中的元数据，这样查询时就可以直接忽略那些不包含指定用户信息的表。对于TB级别的数据，定位单条记录的意义不大，索引经常回使用块级别元数据技术来代替索引。</p>
<h2 id="23-高性能的索引策略">2.3 高性能的索引策略</h2>
<p>正确地场景和使用索引是实现高性能查询地基础。</p>
<h3 id="231-独立地列">2.3.1 独立地列</h3>
<p>独如果查询中的列不是独立的，那么Mysql就不会使用索引。立的列是值索引列不能是表达式的一部分，也不能是函数的参数。</p>
<p>例如，下面这个查询无法泗洪actor_id列的索引</p>
<pre><code>select actor_id from actor where actor_id + 1 = 5 ;
</code></pre>
<p>凭开发者是可以知道where表达式其实等价于actor_id = 4，但是mysql无法字段解析这个方程式。这完全就是用户行为，所以我们应该始终将所以列单独放在比较符号的一侧。</p>
<p>下面的例子也是如此：</p>
<pre><code>select ... where TO_DAYS(current_date) - TO_DAYS(date_col) &lt;= 10 ;
</code></pre>
<h3 id="232-前缀索引和索引选择性">2.3.2 前缀索引和索引选择性</h3>
<p>有时候需要索引很长的字符列，这会让索引变得大且慢。一个策略就是模拟哈希索引。但是这还不够。</p>
<p>通常可以索引开始的部分字符，这样可以节约索引空间，从而提高索引效率。但是这样也会降低索引的选择性。</p>
<p>索引的选择性是指，不重复的索引值（也称为基数）和数据表的记录总数（<em>#T</em>）的比值，范围从1/<em>#T</em>到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让mysql在查询时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p>
<p>一般情况下某个列前缀的选择性也是足够高的，足以满足查询性能。但是对于BLOB、TEXT或者很长但VARCHAR类型但列必须使用前缀索引，因为mysql不允许索引这些列完整长度。</p>
<p>诀窍在于要选择足够长但前缀以保证较高的选择性，同时又不能太长（节约空间）。前缀应该足够长，以使得前缀索引的选择性接近于索引整个列。换句话说，前缀的基数应该接近于完整列的基数。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[迭代器模式]]></title>
        <id>https://q456qq520.github.io/post/die-dai-qi-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/die-dai-qi-mo-shi/">
        </link>
        <updated>2022-03-14T01:55:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="意图">意图</h1>
<p><strong>迭代器模式</strong>是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。</p>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/content/iterator/iterator-zh-2x.png" alt="likecat" loading="lazy"></figure>
<h1 id="问题">问题</h1>
<p>集合是编程中最常使用的数据类型之一。 尽管如此， 集合只是一组对象的容器而已。</p>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/iterator/problem1-2x.png" alt="各种类型的集合" loading="lazy"></figure>
<p>大部分集合使用简单列表存储元素。 但有些集合还会使用栈、 树、 图和其他复杂的数据结构。</p>
<p>无论集合的构成方式如何， 它都必须提供某种访问元素的方式， 便于其他代码使用其中的元素。 集合应提供一种能够遍历元素的方式， 且保证它不会周而复始地访问同一个元素。</p>
<p>如果你的集合基于列表， 那么这项工作听上去仿佛很简单。 但如何遍历复杂数据结构 （例如树） 中的元素呢？ 例如， 今天你需要使用深度优先算法来遍历树结构， 明天可能会需要广度优先算法； 下周则可能会需要其他方式 （比如随机存取树中的元素）。</p>
<figure data-type="image" tabindex="3"><img src="https://refactoringguru.cn/images/patterns/diagrams/iterator/problem2-2x.png" alt="可通过不同的方式遍历相同的集合" loading="lazy"></figure>
<p>不断向集合中添加遍历算法会模糊其 “高效存储数据” 的主要职责。 此外， 有些算法可能是根据特定应用订制的， 将其加入泛型集合类中会显得非常奇怪。</p>
<p>另一方面， 使用多种集合的客户端代码可能并不关心存储数据的方式。 不过由于集合提供不同的元素访问方式， 你的代码将不得不与特定集合类进行耦合。</p>
<h1 id="解决方案">解决方案</h1>
<p>迭代器模式的主要思想是将集合的遍历行为抽取为单独的迭代器对象。</p>
<figure data-type="image" tabindex="4"><img src="https://refactoringguru.cn/images/patterns/diagrams/iterator/solution1-2x.png" alt="迭代器可实现多种遍历算法。 多个迭代器对象可同时遍历同一个集合" loading="lazy"></figure>
<p>除实现自身算法外， 迭代器还封装了遍历操作的所有细节， 例如当前位置和末尾剩余元素的数量。 因此， 多个迭代器可以在相互独立的情况下同时访问集合。</p>
<p>迭代器通常会提供一个获取集合元素的基本方法。 客户端可不断调用该方法直至它不返回任何内容， 这意味着迭代器已经遍历了所有元素。</p>
<p>所有迭代器必须实现相同的接口。 这样一来， 只要有合适的迭代器， 客户端代码就能兼容任何类型的集合或遍历算法。 如果你需要采用特殊方式来遍历集合， 只需创建一个新的迭代器类即可， 无需对集合或客户端进行修改。</p>
<h1 id="真实世界类比">真实世界类比</h1>
<figure data-type="image" tabindex="5"><img src="https://refactoringguru.cn/images/patterns/content/iterator/iterator-comic-1-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>你计划在罗马游览数天， 参观所有主要的旅游景点。 但在到达目的地后， 你可能会浪费很多时间绕圈子， 甚至找不到罗马斗兽场在哪里。</p>
<p>或者你可以购买一款智能手机上的虚拟导游程序。 这款程序非常智能而且价格不贵， 你想在景点待多久都可以。</p>
<p>第三种选择是用部分旅行预算雇佣一位对城市了如指掌的当地向导。 向导能根据你的喜好来安排行程， 为你介绍每个景点并讲述许多激动人心的故事。 这样的旅行可能会更有趣， 但所需费用也会更高。</p>
<p>所有这些选择(自由漫步、 智能手机导航或真人向导)都是这个由众多罗马景点组成的集合的迭代器。</p>
<h1 id="迭代器模式结构">迭代器模式结构</h1>
<figure data-type="image" tabindex="6"><img src="https://refactoringguru.cn/images/patterns/diagrams/iterator/structure-2x.png" alt="likecat" loading="lazy"></figure>
<ol>
<li>
<p><strong>迭代器 （Iterator）</strong> 接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。</p>
</li>
<li>
<p><strong>具体迭代器 （Concrete Iterators）</strong> 实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。</p>
</li>
<li>
<p><strong>集合</strong>（Collection）接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意， 返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。</p>
</li>
<li>
<p><strong>具体集合（Concrete Collections）</strong> 会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 你可能会琢磨， 剩下的集合代码在什么地方呢？ 不用担心， 它也会在同一个类中。 只是这些细节对于实际模式来说并不重要， 所以我们将其省略了而已。</p>
</li>
<li>
<p><strong>客户端</strong> （Client）通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。</p>
<p>客户端通常不会自行创建迭代器， 而是会从集合中获取。 但在特定情况下， 客户端可以直接创建一个迭代器 （例如当客户端需要自定义特殊迭代器时）。</p>
</li>
</ol>
<h2 id="迭代器模式适合应用场景">迭代器模式适合应用场景</h2>
<ol>
<li>
<p>当集合背后为复杂的数据结构， 且你希望对客户端隐藏其复杂性时 （出于使用便利性或安全性的考虑）， 可以使用迭代器模式。</p>
<p>迭代器封装了与复杂数据结构进行交互的细节， 为客户端提供多个访问集合元素的简单方法。 这种方式不仅对客户端来说非常方便， 而且能避免客户端在直接与集合交互时执行错误或有害的操作， 从而起到保护集合的作用。</p>
</li>
<li>
<p>使用该模式可以减少程序中重复的遍历代码。</p>
<p>重要迭代算法的代码往往体积非常庞大。 当这些代码被放置在程序业务逻辑中时， 它会让原始代码的职责模糊不清， 降低其可维护性。 因此， 将遍历代码移到特定的迭代器中可使程序代码更加精炼和简洁。</p>
</li>
<li>
<p>如果你希望代码能够遍历不同的甚至是无法预知的数据结构， 可以使用迭代器模式。</p>
</li>
</ol>
<pre><code>该模式为集合和迭代器提供了一些通用接口。 如果你在代码中使用了这些接口， 那么将其他实现了这些接口的集合和迭代器传递给它时， 它仍将可以正常运行。
</code></pre>
<h1 id="实现方式">实现方式</h1>
<ol>
<li>
<p>声明迭代器接口。 该接口必须提供至少一个方法来获取集合中的下个元素。 但为了使用方便， 你还可以添加一些其他方法， 例如获取前一个元素、 记录当前位置和判断迭代是否已结束。</p>
</li>
<li>
<p>声明集合接口并描述一个获取迭代器的方法。 其返回值必须是迭代器接口。 如果你计划拥有多组不同的迭代器， 则可以声明多个类似的方法。</p>
</li>
<li>
<p>为希望使用迭代器进行遍历的集合实现具体迭代器类。 迭代器对象必须与单个集合实体链接。 链接关系通常通过迭代器的构造函数建立。</p>
</li>
<li>
<p>在你的集合类中实现集合接口。 其主要思想是针对特定集合为客户端代码提供创建迭代器的快捷方式。 集合对象必须将自身传递给迭代器的构造函数来创建两者之间的链接。</p>
</li>
<li>
<p>检查客户端代码， 使用迭代器替代所有集合遍历代码。 每当客户端需要遍历集合元素时都会获取一个新的迭代器。</p>
</li>
</ol>
<h1 id="迭代器模式优缺点">迭代器模式优缺点</h1>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>单一职责原则。 通过将体积庞大的遍历算法代码抽取为独立的类， 你可对客户端代码和集合进行整理。</td>
<td style="text-align:center">如果你的程序只与简单的集合进行交互， 应用该模式可能会矫枉过正。</td>
</tr>
<tr>
<td>开闭原则。 你可实现新型的集合和迭代器并将其传递给现有代码， 无需修改现有代码。</td>
<td style="text-align:center">对于某些特殊集合， 使用迭代器可能比直接遍历的效率低。</td>
</tr>
<tr>
<td>你可以并行遍历同一集合， 因为每个迭代器对象都包含其自身的遍历状态。</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>相似的， 你可以暂停遍历并在需要时继续。</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h1 id="与其他模式的关系">与其他模式的关系</h1>
<ol>
<li>
<p>你可以使用<strong>迭代器模式</strong>来遍历<strong>组合模式树</strong>。</p>
</li>
<li>
<p>你可以同时使用<strong>工厂方法模式</strong>和<strong>迭代器</strong>来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。</p>
</li>
<li>
<p>你可以同时使用<strong>备忘录模式</strong>和<strong>迭代器</strong>来获取当前迭代器的状态， 并且在需要的时候进行回滚。</p>
</li>
<li>
<p>可以同时使用<strong>访问者模式</strong>和<strong>迭代器</strong>来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同。</p>
</li>
</ol>
<h1 id="伪代码">伪代码</h1>
<h2 id="迭代访问社交网络档案">迭代访问社交网络档案</h2>
<p>在本例中， 迭代器模式被用于在不向客户端代码暴露通信细节的情况下访问远程社交网络集合中的社交媒体档案。</p>
<h3 id="社交档案">社交档案</h3>
<pre><code>package com.iterator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * 社交档案
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:35
 */
public class Profile {

    private String name;
    private String email;
    private Map&lt;String, List&lt;String&gt;&gt; contacts = new HashMap&lt;&gt;();

    public Profile(String email, String name, String... contacts) {
        this.email = email;
        this.name = name;

        // Parse contact list from a set of &quot;friend:email@gmail.com&quot; pairs.
        for (String contact : contacts) {
            String[] parts = contact.split(&quot;:&quot;);
            String contactType = &quot;friend&quot;, contactEmail;
            if (parts.length == 1) {
                contactEmail = parts[0];
            }
            else {
                contactType = parts[0];
                contactEmail = parts[1];
            }
            if (!this.contacts.containsKey(contactType)) {
                this.contacts.put(contactType, new ArrayList&lt;&gt;());
            }
            this.contacts.get(contactType).add(contactEmail);
        }
    }

    public String getEmail() {
        return email;
    }

    public String getName() {
        return name;
    }

    public List&lt;String&gt; getContacts(String contactType) {
        if (!this.contacts.containsKey(contactType)) {
            this.contacts.put(contactType, new ArrayList&lt;&gt;());
        }
        return contacts.get(contactType);
    }
}

</code></pre>
<h3 id="定义档案接口">定义档案接口</h3>
<pre><code>package com.iterator;

/**
 * 定义档案接口
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:34
 */
public interface ProfileIterator {
    boolean hasNext();

    Profile getNext();

    void reset();
}
</code></pre>
<h3 id="定义通用的社交网络接口">定义通用的社交网络接口</h3>
<pre><code>package com.iterator;

/**
 * 定义通用的社交网络接口
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:39
 */
public interface SocialNetwork {
    ProfileIterator createFriendsIterator(String profileEmail);

    ProfileIterator createCoworkersIterator(String profileEmail);
}
</code></pre>
<h3 id="facebook">Facebook</h3>
<pre><code>package com.iterator;

import java.util.ArrayList;
import java.util.List;

/**
 * Facebook
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:40
 */
public class Facebook implements SocialNetwork {
    private List&lt;Profile&gt; profiles;

    public Facebook(List&lt;Profile&gt; cache) {
        if (cache != null) {
            this.profiles = cache;
        } else {
            this.profiles = new ArrayList&lt;&gt;();
        }
    }

    public Profile requestProfileFromFacebook(String profileEmail) {
        // Here would be a POST request to one of the Facebook API endpoints.
        // Instead, we emulates long network connection, which you would expect
        // in the real life...
        simulateNetworkLatency();
        System.out.println(&quot;Facebook: Loading profile '&quot; + profileEmail + &quot;' over the network...&quot;);

        // ...and return test data.
        return findProfile(profileEmail);
    }

    public List&lt;String&gt; requestProfileFriendsFromFacebook(String profileEmail, String contactType) {
        // Here would be a POST request to one of the Facebook API endpoints.
        // Instead, we emulates long network connection, which you would expect
        // in the real life...
        simulateNetworkLatency();
        System.out.println(&quot;Facebook: Loading '&quot; + contactType + &quot;' list of '&quot; + profileEmail + &quot;' over the network...&quot;);

        // ...and return test data.
        Profile profile = findProfile(profileEmail);
        if (profile != null) {
            return profile.getContacts(contactType);
        }
        return null;
    }

    private Profile findProfile(String profileEmail) {
        for (Profile profile : profiles) {
            if (profile.getEmail().equals(profileEmail)) {
                return profile;
            }
        }
        return null;
    }

    private void simulateNetworkLatency() {
        try {
            Thread.sleep(2500);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
    }

    @Override
    public ProfileIterator createFriendsIterator(String profileEmail) {
        return new FacebookIterator(this, &quot;friends&quot;, profileEmail);
    }

    @Override
    public ProfileIterator createCoworkersIterator(String profileEmail) {
        return new FacebookIterator(this, &quot;coworkers&quot;, profileEmail);
    }
}
</code></pre>
<h3 id="在-facebook-档案上实现迭代">在 Facebook 档案上实现迭代</h3>
<pre><code>package com.iterator;

import java.util.ArrayList;
import java.util.List;

/**
 * 在 Facebook 档案上实现迭代
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:38
 */
public class FacebookIterator implements ProfileIterator {
    private Facebook facebook;
    private String type;
    private String email;
    private int currentPosition = 0;
    private List&lt;String&gt; emails = new ArrayList&lt;&gt;();
    private List&lt;Profile&gt; profiles = new ArrayList&lt;&gt;();

    public FacebookIterator(Facebook facebook, String type, String email) {
        this.facebook = facebook;
        this.type = type;
        this.email = email;
    }

    private void lazyLoad() {
        if (emails.size() == 0) {
            List&lt;String&gt; profiles = facebook.requestProfileFriendsFromFacebook(this.email, this.type);
            for (String profile : profiles) {
                this.emails.add(profile);
                this.profiles.add(null);
            }
        }
    }

    @Override
    public boolean hasNext() {
        lazyLoad();
        return currentPosition &lt; emails.size();
    }

    @Override
    public Profile getNext() {
        if (!hasNext()) {
            return null;
        }

        String friendEmail = emails.get(currentPosition);
        Profile friendProfile = profiles.get(currentPosition);
        if (friendProfile == null) {
            friendProfile = facebook.requestProfileFromFacebook(friendEmail);
            profiles.set(currentPosition, friendProfile);
        }
        currentPosition++;
        return friendProfile;
    }

    @Override
    public void reset() {
        currentPosition = 0;
    }
}
</code></pre>
<h3 id="在领英档案上实现迭代">在领英档案上实现迭代</h3>
<pre><code>package com.iterator;

import java.util.ArrayList;
import java.util.List;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:44
 */
public class LinkedInIterator implements ProfileIterator {
    private LinkedIn linkedIn;
    private String type;
    private String email;
    private int currentPosition = 0;
    private List&lt;String&gt; emails = new ArrayList&lt;&gt;();
    private List&lt;Profile&gt; contacts = new ArrayList&lt;&gt;();

    public LinkedInIterator(LinkedIn linkedIn, String type, String email) {
        this.linkedIn = linkedIn;
        this.type = type;
        this.email = email;
    }

    private void lazyLoad() {
        if (emails.size() == 0) {
            List&lt;String&gt; profiles = linkedIn.requestRelatedContactsFromLinkedInAPI(this.email, this.type);
            for (String profile : profiles) {
                this.emails.add(profile);
                this.contacts.add(null);
            }
        }
    }

    @Override
    public boolean hasNext() {
        lazyLoad();
        return currentPosition &lt; emails.size();
    }

    @Override
    public Profile getNext() {
        if (!hasNext()) {
            return null;
        }

        String friendEmail = emails.get(currentPosition);
        Profile friendContact = contacts.get(currentPosition);
        if (friendContact == null) {
            friendContact = linkedIn.requestContactInfoFromLinkedInAPI(friendEmail);
            contacts.set(currentPosition, friendContact);
        }
        currentPosition++;
        return friendContact;
    }

    @Override
    public void reset() {
        currentPosition = 0;
    }
}
</code></pre>
<h3 id="领英">领英</h3>
<pre><code>package com.iterator;

import java.util.ArrayList;
import java.util.List;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:42
 */
public class LinkedIn implements SocialNetwork {
    private List&lt;Profile&gt; contacts;

    public LinkedIn(List&lt;Profile&gt; cache) {
        if (cache != null) {
            this.contacts = cache;
        } else {
            this.contacts = new ArrayList&lt;&gt;();
        }
    }

    public Profile requestContactInfoFromLinkedInAPI(String profileEmail) {
        // Here would be a POST request to one of the LinkedIn API endpoints.
        // Instead, we emulates long network connection, which you would expect
        // in the real life...
        simulateNetworkLatency();
        System.out.println(&quot;LinkedIn: Loading profile '&quot; + profileEmail + &quot;' over the network...&quot;);

        // ...and return test data.
        return findContact(profileEmail);
    }

    public List&lt;String&gt; requestRelatedContactsFromLinkedInAPI(String profileEmail, String contactType) {
        // Here would be a POST request to one of the LinkedIn API endpoints.
        // Instead, we emulates long network connection, which you would expect
        // in the real life.
        simulateNetworkLatency();
        System.out.println(&quot;LinkedIn: Loading '&quot; + contactType + &quot;' list of '&quot; + profileEmail + &quot;' over the network...&quot;);

        // ...and return test data.
        Profile profile = findContact(profileEmail);
        if (profile != null) {
            return profile.getContacts(contactType);
        }
        return null;
    }

    private Profile findContact(String profileEmail) {
        for (Profile profile : contacts) {
            if (profile.getEmail().equals(profileEmail)) {
                return profile;
            }
        }
        return null;
    }

    private void simulateNetworkLatency() {
        try {
            Thread.sleep(2500);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
    }

    @Override
    public ProfileIterator createFriendsIterator(String profileEmail) {
        return new LinkedInIterator(this, &quot;friends&quot;, profileEmail);
    }

    @Override
    public ProfileIterator createCoworkersIterator(String profileEmail) {
        return new LinkedInIterator(this, &quot;coworkers&quot;, profileEmail);
    }
}
</code></pre>
<h3 id="消息发送应用">消息发送应用</h3>
<pre><code>package com.iterator;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:47
 */
public class SocialSpammer {
    public SocialNetwork network;
    public ProfileIterator iterator;

    public SocialSpammer(SocialNetwork network) {
        this.network = network;
    }

    public void sendSpamToFriends(String profileEmail, String message) {
        System.out.println(&quot;\nIterating over friends...\n&quot;);
        iterator = network.createFriendsIterator(profileEmail);
        while (iterator.hasNext()) {
            Profile profile = iterator.getNext();
            sendMessage(profile.getEmail(), message);
        }
    }

    public void sendSpamToCoworkers(String profileEmail, String message) {
        System.out.println(&quot;\nIterating over coworkers...\n&quot;);
        iterator = network.createCoworkersIterator(profileEmail);
        while (iterator.hasNext()) {
            Profile profile = iterator.getNext();
            sendMessage(profile.getEmail(), message);
        }
    }

    public void sendMessage(String email, String message) {
        System.out.println(&quot;Sent message to: '&quot; + email + &quot;'. Message body: '&quot; + message + &quot;'&quot;);
    }
}
</code></pre>
<h3 id="客户端代码">客户端代码</h3>
<pre><code>package com.iterator;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:50
 */
public class Demo {
    public static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println(&quot;Please specify social network to target spam tool (default:Facebook):&quot;);
        System.out.println(&quot;1. Facebook&quot;);
        System.out.println(&quot;2. LinkedIn&quot;);
        String choice = scanner.nextLine();

        SocialNetwork network;
        if (choice.equals(&quot;2&quot;)) {
            network = new LinkedIn(createTestProfiles());
        }
        else {
            network = new Facebook(createTestProfiles());
        }

        SocialSpammer spammer = new SocialSpammer(network);
        spammer.sendSpamToFriends(&quot;anna.smith@bing.com&quot;,
                &quot;Hey! This is Anna's friend Josh. Can you do me a favor and like this post [link]?&quot;);
        spammer.sendSpamToCoworkers(&quot;anna.smith@bing.com&quot;,
                &quot;Hey! This is Anna's boss Jason. Anna told me you would be interested in [link].&quot;);
    }

    public static List&lt;Profile&gt; createTestProfiles() {
        List&lt;Profile&gt; data = new ArrayList&lt;Profile&gt;();
        data.add(new Profile(&quot;anna.smith@bing.com&quot;, &quot;Anna Smith&quot;, &quot;friends:mad_max@ya.com&quot;, &quot;friends:catwoman@yahoo.com&quot;, &quot;coworkers:sam@amazon.com&quot;));
        data.add(new Profile(&quot;mad_max@ya.com&quot;, &quot;Maximilian&quot;, &quot;friends:anna.smith@bing.com&quot;, &quot;coworkers:sam@amazon.com&quot;));
        data.add(new Profile(&quot;bill@microsoft.eu&quot;, &quot;Billie&quot;, &quot;coworkers:avanger@ukr.net&quot;));
        data.add(new Profile(&quot;avanger@ukr.net&quot;, &quot;John Day&quot;, &quot;coworkers:bill@microsoft.eu&quot;));
        data.add(new Profile(&quot;sam@amazon.com&quot;, &quot;Sam Kitting&quot;, &quot;coworkers:anna.smith@bing.com&quot;, &quot;coworkers:mad_max@ya.com&quot;, &quot;friends:catwoman@yahoo.com&quot;));
        data.add(new Profile(&quot;catwoman@yahoo.com&quot;, &quot;Liza&quot;, &quot;friends:anna.smith@bing.com&quot;, &quot;friends:sam@amazon.com&quot;));
        return data;
    }
}
</code></pre>
<h3 id="执行结果">执行结果</h3>
<pre><code>Please specify social network to target spam tool (default:Facebook):
1. Facebook
2. LinkedIn
&gt; 1

Iterating over friends...

Facebook: Loading 'friends' list of 'anna.smith@bing.com' over the network...
Facebook: Loading profile 'mad_max@ya.com' over the network...
Sent message to: 'mad_max@ya.com'. Message body: 'Hey! This is Anna's friend Josh. Can you do me a favor and like this post [link]?'
Facebook: Loading profile 'catwoman@yahoo.com' over the network...
Sent message to: 'catwoman@yahoo.com'. Message body: 'Hey! This is Anna's friend Josh. Can you do me a favor and like this post [link]?'

Iterating over coworkers...

Facebook: Loading 'coworkers' list of 'anna.smith@bing.com' over the network...
Facebook: Loading profile 'sam@amazon.com' over the network...
Sent message to: 'sam@amazon.com'. Message body: 'Hey! This is Anna's boss Jason. Anna told me you would be interested in [link].'
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从PAXOS到ZOOKEEPER分布式一致性原理与实践]]></title>
        <id>https://q456qq520.github.io/post/cong-paxos-dao-zookeeper-fen-bu-shi-yi-zhi-xing-yuan-li-yu-shi-jian/</id>
        <link href="https://q456qq520.github.io/post/cong-paxos-dao-zookeeper-fen-bu-shi-yi-zhi-xing-yuan-li-yu-shi-jian/">
        </link>
        <updated>2022-03-11T01:50:43.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Domain Drive Design（领域驱动设计）]]></title>
        <id>https://q456qq520.github.io/post/domain-drive-designling-yu-qu-dong-she-ji/</id>
        <link href="https://q456qq520.github.io/post/domain-drive-designling-yu-qu-dong-she-ji/">
        </link>
        <updated>2022-03-10T06:23:54.000Z</updated>
        <content type="html"><![CDATA[<p>Domain Drive Design（领域驱动设计）</p>
]]></content>
    </entry>
</feed>