<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://q456qq520.github.io</id>
    <title>LIKE CAT</title>
    <updated>2022-01-14T03:03:44.601Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://q456qq520.github.io"/>
    <link rel="self" href="https://q456qq520.github.io/atom.xml"/>
    <subtitle>一条小咸鱼</subtitle>
    <logo>https://q456qq520.github.io/images/avatar.png</logo>
    <icon>https://q456qq520.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, LIKE CAT</rights>
    <entry>
        <title type="html"><![CDATA[组合模式]]></title>
        <id>https://q456qq520.github.io/post/zu-he-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/zu-he-mo-shi/">
        </link>
        <updated>2022-01-12T08:22:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="意图">意图</h2>
<p><strong>组合模式</strong>是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。</p>
<h2 id="问题">问题</h2>
<p>如果应用的核心模型能用树状结构表示， 在应用中使用组合模式才有价值。</p>
<p>例如， 你有两类对象： ​ 产品和 盒子 。 一个盒子中可以包含多个 产品或者几个较小的 盒子 。 这些小 盒子中同样可以包含一些 产品或更小的 盒子 ， 以此类推。</p>
<p>假设你希望在这些类的基础上开发一个定购系统。 订单中可以包含无包装的简单产品， 也可以包含装满产品的盒子……以及其他盒子。 此时你会如何计算每张订单的总价格呢？</p>
<p><img src="https://refactoringguru.cn/images/patterns/diagrams/composite/problem-zh-2x.png" alt="likecat" loading="lazy"><br>
订单中可能包括各种产品， 这些产品放置在盒子中， 然后又被放入一层又一层更大的盒子中。 整个结构看上去像是一棵倒过来的树。</p>
<p>你可以尝试直接计算： 打开所有盒子， 找到每件产品， 然后计算总价。 这在真实世界中或许可行， 但在程序中， 你并不能简单地使用循环语句来完成该工作。 你必须事先知道所有 产品和 盒子的类别， 所有盒子的嵌套层数以及其他繁杂的细节信息。 因此， 直接计算极不方便， 甚至完全不可行。</p>
<h2 id="解决方案">解决方案</h2>
<p>组合模式建议使用一个通用接口来与 产品和 盒子进行交互， 并且在该接口中声明一个计算总价的方法。</p>
<p>那么方法该如何设计呢？ 对于一个产品， 该方法直接返回其价格； 对于一个盒子， 该方法遍历盒子中的所有项目， 询问每个项目的价格， 然后返回该盒子的总价格。 如果其中某个项目是小一号的盒子， 那么当前盒子也会遍历其中的所有项目， 以此类推， 直到计算出所有内部组成部分的价格。 你甚至可以在盒子的最终价格中增加额外费用， 作为该盒子的包装费用。</p>
<p><img src="https://refactoringguru.cn/images/patterns/content/composite/composite-comic-1-zh-2x.png" alt="likecat" loading="lazy"><br>
组合模式以递归方式处理对象树中的所有项目</p>
<p>该方式的最大优点在于你无需了解构成树状结构的对象的具体类。 你也无需了解对象是简单的产品还是复杂的盒子。 你只需调用通用接口以相同的方式对其进行处理即可。 当你调用该方法后， 对象会将请求沿着树结构传递下去。</p>
<h2 id="组合模式结构">组合模式结构</h2>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/diagrams/composite/structure-zh-2x.png" alt="likecat" loading="lazy"></figure>
<ol>
<li><strong>组件 （Component）</strong> 接口描述了树中简单项目和复杂项目所共有的操作。</li>
<li><strong>叶节点 （Leaf）</strong> 是树的基本结构， 它不包含子项目。<br>
一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。</li>
<li><strong>容器 （Container）</strong>——又名 “<strong>组合 （Composite）</strong>”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。<br>
容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。</li>
<li><strong>客户端 （Client）</strong> 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。</li>
</ol>
<h2 id="伪代码">伪代码</h2>
<p>简单和复合图形</p>
<p>本例展示了如何利用较为简单的形状来组成复杂图形， 以及如何统一处理简单和复杂图形。</p>
<ol>
<li>通用形状接口</li>
</ol>
<pre><code>package com.composite;

import java.awt.*;

/**
 * 通用形状接口
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 09:26
 */
public interface Shape {
    int getX();
    int getY();
    int getWidth();
    int getHeight();
    void move(int x, int y);
    boolean isInsideBounds(int x, int y);
    void select();
    void unSelect();
    boolean isSelected();
    void paint(Graphics graphics);
}

</code></pre>
<ol start="2">
<li>提供基本功能的抽象形状</li>
</ol>
<pre><code>package com.composite;

import java.awt.*;

/**
 * 提供基本功能的抽象形状
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 10:48
 */
abstract class BaseShape implements Shape{
    public int x;
    public int y;
    public Color color;
    private boolean selected = false;

    BaseShape(int x, int y, Color color) {
        this.x = x;
        this.y = y;
        this.color = color;
    }

    @Override
    public int getX() {
        return x;
    }

    @Override
    public int getY() {
        return y;
    }

    @Override
    public int getWidth() {
        return 0;
    }

    @Override
    public int getHeight() {
        return 0;
    }

    @Override
    public void move(int x, int y) {
        this.x += x;
        this.y += y;
    }

    @Override
    public boolean isInsideBounds(int x, int y) {
        return x &gt; getX() &amp;&amp; x &lt; (getX() + getWidth()) &amp;&amp;
                y &gt; getY() &amp;&amp; y &lt; (getY() + getHeight());
    }

    @Override
    public void select() {
        selected = true;
    }

    @Override
    public void unSelect() {
        selected = false;
    }

    @Override
    public boolean isSelected() {
        return selected;
    }

    void enableSelectionStyle(Graphics graphics) {
        graphics.setColor(Color.LIGHT_GRAY);

        Graphics2D g2 = (Graphics2D) graphics;
        float dash1[] = {2.0f};
        g2.setStroke(new BasicStroke(1.0f,
                BasicStroke.CAP_BUTT,
                BasicStroke.JOIN_MITER,
                2.0f, dash1, 0.0f));
    }

    void disableSelectionStyle(Graphics graphics) {
        graphics.setColor(color);
        Graphics2D g2 = (Graphics2D) graphics;
        g2.setStroke(new BasicStroke());
    }


    @Override
    public void paint(Graphics graphics) {
        if (isSelected()) {
            enableSelectionStyle(graphics);
        }
        else {
            disableSelectionStyle(graphics);
        }

        // ...
    }
}

</code></pre>
<ol start="3">
<li>点</li>
</ol>
<pre><code>package com.composite;

import java.awt.*;

/**
 * 点
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 10:49
 */
public class Dot extends BaseShape {
    private final int DOT_SIZE = 3;

    public Dot(int x, int y, Color color) {
        super(x, y, color);
    }

    @Override
    public int getWidth() {
        return DOT_SIZE;
    }

    @Override
    public int getHeight() {
        return DOT_SIZE;
    }

    @Override
    public void paint(Graphics graphics) {
        super.paint(graphics);
        graphics.fillRect(x - 1, y - 1, getWidth(), getHeight());
    }
}

</code></pre>
<ol start="4">
<li>圆</li>
</ol>
<pre><code>package com.composite;

import java.awt.*;

/**
 * 圆
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 10:50
 */
public class Circle extends BaseShape{
    public int radius;

    public Circle(int x, int y, int radius, Color color) {
        super(x, y, color);
        this.radius = radius;
    }

    @Override
    public int getWidth() {
        return radius * 2;
    }

    @Override
    public int getHeight() {
        return radius * 2;
    }

    public void paint(Graphics graphics) {
        super.paint(graphics);
        graphics.drawOval(x, y, getWidth() - 1, getHeight() - 1);
    }
}

</code></pre>
<ol start="5">
<li>三角形</li>
</ol>
<pre><code>package com.composite;

import java.awt.*;

/**
 * 三角形
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 10:50
 */
public class Rectangle extends BaseShape{
    public int width;
    public int height;

    public Rectangle(int x, int y, int width, int height, Color color) {
        super(x, y, color);
        this.width = width;
        this.height = height;
    }

    @Override
    public int getWidth() {
        return width;
    }

    @Override
    public int getHeight() {
        return height;
    }

    @Override
    public void paint(Graphics graphics) {
        super.paint(graphics);
        graphics.drawRect(x, y, getWidth() - 1, getHeight() - 1);
    }
}

</code></pre>
<ol start="6">
<li>由其他形状对象组成的复合形状</li>
</ol>
<pre><code>package com.composite;

import java.awt.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * 由其他形状对象组成的复合形状
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 10:51
 */
public class CompoundShape extends BaseShape{
    protected List&lt;Shape&gt; children = new ArrayList&lt;&gt;();

    public CompoundShape(Shape... components) {
        super(0, 0, Color.BLACK);
        add(components);
    }

    public void add(Shape component) {
        children.add(component);
    }

    public void add(Shape... components) {
        children.addAll(Arrays.asList(components));
    }

    public void remove(Shape child) {
        children.remove(child);
    }

    public void remove(Shape... components) {
        children.removeAll(Arrays.asList(components));
    }

    public void clear() {
        children.clear();
    }

    @Override
    public int getX() {
        if (children.size() == 0) {
            return 0;
        }
        int x = children.get(0).getX();
        for (Shape child : children) {
            if (child.getX() &lt; x) {
                x = child.getX();
            }
        }
        return x;
    }

    @Override
    public int getY() {
        if (children.size() == 0) {
            return 0;
        }
        int y = children.get(0).getY();
        for (Shape child : children) {
            if (child.getY() &lt; y) {
                y = child.getY();
            }
        }
        return y;
    }

    @Override
    public int getWidth() {
        int maxWidth = 0;
        int x = getX();
        for (Shape child : children) {
            int childsRelativeX = child.getX() - x;
            int childWidth = childsRelativeX + child.getWidth();
            if (childWidth &gt; maxWidth) {
                maxWidth = childWidth;
            }
        }
        return maxWidth;
    }

    @Override
    public int getHeight() {
        int maxHeight = 0;
        int y = getY();
        for (Shape child : children) {
            int childsRelativeY = child.getY() - y;
            int childHeight = childsRelativeY + child.getHeight();
            if (childHeight &gt; maxHeight) {
                maxHeight = childHeight;
            }
        }
        return maxHeight;
    }

    @Override
    public void move(int x, int y) {
        for (Shape child : children) {
            child.move(x, y);
        }
    }

    @Override
    public boolean isInsideBounds(int x, int y) {
        for (Shape child : children) {
            if (child.isInsideBounds(x, y)) {
                return true;
            }
        }
        return false;
    }

    @Override
    public void unSelect() {
        super.unSelect();
        for (Shape child : children) {
            child.unSelect();
        }
    }

    public boolean selectChildAt(int x, int y) {
        for (Shape child : children) {
            if (child.isInsideBounds(x, y)) {
                child.select();
                return true;
            }
        }
        return false;
    }

    @Override
    public void paint(Graphics graphics) {
        if (isSelected()) {
            enableSelectionStyle(graphics);
            graphics.drawRect(getX() - 1, getY() - 1, getWidth() + 1, getHeight() + 1);
            disableSelectionStyle(graphics);
        }

        for (Shape child : children) {
            child.paint(graphics);
        }
    }
}

</code></pre>
<ol start="7">
<li>形状编辑器</li>
</ol>
<pre><code>package com.composite;

import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

/**
 * 形状编辑器
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 10:53
 */
public class ImageEditor {
    private EditorCanvas canvas;
    private CompoundShape allShapes = new CompoundShape();

    public ImageEditor() {
        canvas = new EditorCanvas();
    }

    public void loadShapes(Shape... shapes) {
        allShapes.clear();
        allShapes.add(shapes);
        canvas.refresh();
    }

    private class EditorCanvas extends Canvas {
        JFrame frame;

        private static final int PADDING = 10;

        EditorCanvas() {
            createFrame();
            refresh();
            addMouseListener(new MouseAdapter() {
                @Override
                public void mousePressed(MouseEvent e) {
                    allShapes.unSelect();
                    allShapes.selectChildAt(e.getX(), e.getY());
                    e.getComponent().repaint();
                }
            });
        }

        void createFrame() {
            frame = new JFrame();
            frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
            frame.setLocationRelativeTo(null);

            JPanel contentPanel = new JPanel();
            Border padding = BorderFactory.createEmptyBorder(PADDING, PADDING, PADDING, PADDING);
            contentPanel.setBorder(padding);
            frame.setContentPane(contentPanel);

            frame.add(this);
            frame.setVisible(true);
            frame.getContentPane().setBackground(Color.LIGHT_GRAY);
        }

        public int getWidth() {
            return allShapes.getX() + allShapes.getWidth() + PADDING;
        }

        public int getHeight() {
            return allShapes.getY() + allShapes.getHeight() + PADDING;
        }

        void refresh() {
            this.setSize(getWidth(), getHeight());
            frame.pack();
        }

        public void paint(Graphics graphics) {
            allShapes.paint(graphics);
        }
    }
}

</code></pre>
<ol start="8">
<li>客户端代码</li>
</ol>
<pre><code>package com.composite;

import java.awt.*;

/**
 * 客户端代码
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 10:54
 */
public class Demo {
    public static void main(String[] args) {
        ImageEditor editor = new ImageEditor();

        editor.loadShapes(
                new Circle(10, 10, 10, Color.BLUE),

                new CompoundShape(
                        new Circle(110, 110, 50, Color.RED),
                        new Dot(160, 160, Color.RED)
                ),

                new CompoundShape(
                        new Rectangle(250, 250, 100, 100, Color.GREEN),
                        new Dot(240, 240, Color.GREEN),
                        new Dot(240, 360, Color.GREEN),
                        new Dot(360, 360, Color.GREEN),
                        new Dot(360, 240, Color.GREEN)
                )
        );
    }
}

</code></pre>
<h2 id="组合模式适合应用场景">组合模式适合应用场景</h2>
<ol>
<li>
<p>如果你需要实现树状对象结构， 可以使用组合模式。</p>
<p>组合模式为你提供了两种共享公共接口的基本元素类型： 简单叶节点和复杂容器。 容器中可以包含叶节点和其他容器。 这使得你可以构建树状嵌套递归对象结构。</p>
</li>
<li>
<p>如果你希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。</p>
<p>组合模式中定义的所有元素共用同一个接口。 在这一接口的帮助下， 客户端不必在意其所使用的对象的具体类。</p>
</li>
</ol>
<h2 id="实现方式">实现方式</h2>
<ol>
<li>
<p>确保应用的核心模型能够以树状结构表示。 尝试将其分解为简单元素和容器。 记住， 容器必须能够同时包含简单元素和其他容器。</p>
</li>
<li>
<p>声明组件接口及其一系列方法， 这些方法对简单和复杂元素都有意义。</p>
</li>
<li>
<p>创建一个叶节点类表示简单元素。 程序中可以有多个不同的叶节点类。</p>
</li>
<li>
<p>创建一个容器类表示复杂元素。 在该类中， 创建一个数组成员变量来存储对于其子元素的引用。 该数组必须能够同时保存叶节点和容器， 因此请确保将其声明为组合接口类型。</p>
<p>实现组件接口方法时， 记住容器应该将大部分工作交给其子元素来完成。</p>
</li>
<li>
<p>最后， 在容器中定义添加和删除子元素的方法。</p>
</li>
</ol>
<p>记住， 这些操作可在组件接口中声明。 这将会违反<strong>接口隔离原则</strong>， 因为叶节点类中的这些方法为空。 但是， 这可以让客户端无差别地访问所有元素， 即使是组成树状结构的元素。</p>
<h2 id="组合模式优缺点">组合模式优缺点</h2>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>你可以利用多态和递归机制更方便地使用复杂树结构。</td>
<td style="text-align:center">对于功能差异较大的类， 提供公共接口或许会有困难。 在特定情况下， 你需要过度一般化组件接口， 使其变得令人难以理解。</td>
</tr>
<tr>
<td>开闭原则。 无需更改现有代码， 你就可以在应用中添加新元素， 使其成为对象树的一部分。</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="与其他模式的关系">与其他模式的关系</h2>
<ol>
<li>
<p><strong>桥接模式</strong>、 <strong>状态模式</strong>和<strong>策略模式</strong> （在某种程度上包括<strong>适配器模式</strong>） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p>
</li>
<li>
<p>你可以在创建复杂<strong>组合树</strong>时使用<strong>生成器模式</strong>， 因为这可使其构造步骤以递归的方式运行。</p>
</li>
<li>
<p><strong>责任链模式</strong>通常和<strong>组合模式</strong>结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。</p>
</li>
<li>
<p>你可以使用<strong>迭代器模式</strong>来遍历组合树。</p>
</li>
<li>
<p>你可以使用<strong>访问者模式</strong>对整个<strong>组合树</strong>执行操作。</p>
</li>
<li>
<p>你可以使用<strong>享元模式</strong>实现组合树的共享叶节点以节省内存。</p>
</li>
<li>
<p><strong>组合</strong>和<strong>装饰模式</strong>的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。</p>
<p>装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。</p>
<p>但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。</p>
</li>
<li>
<p>大量使用<strong>组合</strong>和<strong>装饰</strong>的设计通常可从对于<strong>原型模式</strong>的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[适配器模式]]></title>
        <id>https://q456qq520.github.io/post/gua-pei-qi-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/gua-pei-qi-mo-shi/">
        </link>
        <updated>2022-01-12T03:39:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="意图">意图</h2>
<p>适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。</p>
<h2 id="问题">问题</h2>
<p>假如你正在开发一款股票市场监测程序， 它会从不同来源下载 XML 格式的股票数据， 然后向用户呈现出美观的图表。</p>
<p>在开发过程中， 你决定在程序中整合一个第三方智能分析函数库。 但是遇到了一个问题， 那就是分析函数库只兼容 JSON 格式的数据。<br>
<img src="https://refactoringguru.cn/images/patterns/diagrams/adapter/problem-zh-2x.png" alt="likecat" title="你无法 “直接” 使用分析函数库， 因为它所需的输入数据格式与你的程序不兼容。" loading="lazy"><br>
你可以修改程序库来支持 XML。 但是， 这可能需要修改部分依赖该程序库的现有代码。 甚至还有更糟糕的情况， 你可能根本没有程序库的源代码， 从而无法对其进行修改。</p>
<h2 id="解决方案">解决方案</h2>
<p>你可以创建一个适配器。 这是一个特殊的对象， 能够转换对象接口， 使其能与其他对象进行交互。</p>
<p>适配器模式通过封装对象将复杂的转换过程隐藏于幕后。 被封装的对象甚至察觉不到适配器的存在。 例如， 你可以使用一个将所有数据转换为英制单位 （如英尺和英里） 的适配器封装运行于米和千米单位制中的对象。</p>
<p>适配器不仅可以转换不同格式的数据， 其还有助于采用不同接口的对象之间的合作。 它的运作方式如下：</p>
<ol>
<li>适配器实现与其中一个现有对象兼容的接口。</li>
<li>现有对象可以使用该接口安全地调用适配器方法。</li>
<li>适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象。</li>
</ol>
<p>有时你甚至可以创建一个双向适配器来实现双向转换调用。<br>
<img src="https://refactoringguru.cn/images/patterns/diagrams/adapter/solution-zh-2x.png" alt="likecat" loading="lazy"></p>
<p>让我们回到股票市场程序。 为了解决数据格式不兼容的问题， 你可以为分析函数库中的每个类创建将 XML 转换为 JSON 格式的适配器， 然后让客户端仅通过这些适配器来与函数库进行交流。 当某个适配器被调用时， 它会将传入的 XML 数据转换为 JSON 结构， 并将其传递给被封装分析对象的相应方法。</p>
<h2 id="适配器模式结构">适配器模式结构</h2>
<h4 id="对象适配器">对象适配器</h4>
<p>实现时使用了构成原则： 适配器实现了其中一个对象的接口， 并对另一个对象进行封装。 所有流行的编程语言都可以实现适配器。</p>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/diagrams/adapter/structure-object-adapter-2x.png" alt="likecat" loading="lazy"></figure>
<ol>
<li>**客户端 （Client） **是包含当前程序业务逻辑的类。</li>
<li><strong>客户端接口 （Client Interface）</strong> 描述了其他类与客户端代码合作时必须遵循的协议。</li>
<li><strong>服务 （Service）</strong> 中有一些功能类 （通常来自第三方或遗留系统）。 客户端与其接口不兼容， 因此无法直接调用其功能。</li>
<li><strong>适配器 （Adapter）</strong> 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时封装了服务对象。 适配器接受客户端通过适配器接口发起的调用， 并将其转换为适用于被封装服务对象的调用。</li>
<li>客户端代码只需通过接口与适配器交互即可， 无需与具体的适配器类耦合。 因此， 你可以向程序中添加新类型的适配器而无需修改已有代码。 这在服务类的接口被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器类。</li>
</ol>
<h4 id="类适配器">类适配器</h4>
<p>这一实现使用了继承机制： 适配器同时继承两个对象的接口。</p>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/adapter/structure-class-adapter-2x.png" alt="likecat" title="类适配器" loading="lazy"></figure>
<ol>
<li><strong>类适配器</strong>不需要封装任何对象， 因为它同时继承了客户端和服务的行为。 适配功能在重写的方法中完成。 最后生成的适配器可替代已有的客户端类进行使用。</li>
</ol>
<h2 id="伪代码">伪代码</h2>
<p>下列适配器模式演示基于经典的 “方钉和圆孔” 问题。</p>
<p><img src="https://refactoringguru.cn/images/patterns/diagrams/adapter/example-2x.png" alt="likecat" title="方钉圆孔" loading="lazy"><br>
让方钉适配圆孔。</p>
<p>适配器假扮成一个圆钉 （Round­Peg）， 其半径等于方钉 （Square­Peg） 横截面对角线的一半 （即能够容纳方钉的最小外接圆的半径）。</p>
<p><strong>圆孔</strong></p>
<pre><code>package round;

/**
 * 圆孔
 * @author TZP
 * @version 1.0
 * @date 2022/1/12 14:26
 */
public class RoundHole {

    //半径
    private double radius;

    public RoundHole(double radius) {
        this.radius = radius;
    }

    public double getRadius() {
        return radius;
    }

    //打圆孔
    public boolean fits(RoundPeg peg) {
        boolean result;
        result = (this.getRadius() &gt;= peg.getRadius());
        return result;
    }
}

</code></pre>
<p><strong>圆钉</strong></p>
<pre><code>package round;

/**
 * 圆钉
 * @author TZP
 * @version 1.0
 * @date 2022/1/12 14:28
 */
public class RoundPeg {
    private double radius;

    public RoundPeg() {}

    public RoundPeg(double radius) {
        this.radius = radius;
    }

    public double getRadius() {
        return radius;
    }
}

</code></pre>
<p><strong>方钉</strong></p>
<pre><code>package round;

/**
 * 方钉
 * @author TZP
 * @version 1.0
 * @date 2022/1/12 14:31
 */
public class SquarePeg {
    private double width;

    public SquarePeg(double width) {
        this.width = width;
    }

    public double getWidth() {
        return width;
    }

    public double getSquare() {
        double result;
        result = Math.pow(this.width, 2);
        return result;
    }
}

</code></pre>
<p><strong>方钉到圆孔的适配器</strong></p>
<pre><code>package round;

/**
 * 方钉到圆孔的适配器
 * @author TZP
 * @version 1.0
 * @date 2022/1/12 14:33
 */
public class SquarePegAdapter extends RoundPeg{

    private SquarePeg peg;

    public SquarePegAdapter(SquarePeg peg) {
        this.peg = peg;
    }

    @Override
    public double getRadius() {
        double result;
        // Calculate a minimum circle radius, which can fit this peg.
        result = (Math.sqrt(Math.pow((peg.getWidth() / 2), 2) * 2));
        return result;
    }
}

</code></pre>
<p><strong>客户端代码</strong></p>
<pre><code>package round;

/**
 * 客户端代码
 * @author TZP
 * @version 1.0
 * @date 2022/1/12 14:36
 */
public class Demo {
    public static void main(String[] args) {
        // Round fits round, no surprise.
        RoundHole hole = new RoundHole(5);
        RoundPeg rpeg = new RoundPeg(5);
        if (hole.fits(rpeg)) {
            System.out.println(&quot;Round peg r5 fits round hole r5.&quot;);
        }

        SquarePeg smallSqPeg = new SquarePeg(2);
        SquarePeg largeSqPeg = new SquarePeg(20);
        // hole.fits(smallSqPeg); // Won't compile.

        // Adapter solves the problem.
        SquarePegAdapter smallSqPegAdapter = new SquarePegAdapter(smallSqPeg);
        SquarePegAdapter largeSqPegAdapter = new SquarePegAdapter(largeSqPeg);
        if (hole.fits(smallSqPegAdapter)) {
            System.out.println(&quot;Square peg w2 fits round hole r5.&quot;);
        }
        if (!hole.fits(largeSqPegAdapter)) {
            System.out.println(&quot;Square peg w20 does not fit into round hole r5.&quot;);
        }
    }
}

</code></pre>
<p><strong>执行结果</strong></p>
<pre><code>Round peg r5 fits round hole r5.
Square peg w2 fits round hole r5.
Square peg w20 does not fit into round hole r5.
</code></pre>
<h2 id="适配器模式适合应用场景">适配器模式适合应用场景</h2>
<p><strong>当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。</strong><br>
适配器模式允许你创建一个中间层类， 其可作为代码与遗留类、 第三方类或提供怪异接口的类之间的转换器。</p>
<p><strong>如果您需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。</strong><br>
你可以扩展每个子类， 将缺少的功能添加到新的子类中。 但是， 你必须在所有新子类中重复添加这些代码， 这样会使得代码有坏味道。</p>
<p>将缺失功能添加到一个适配器类中是一种优雅得多的解决方案。 然后你可以将缺少功能的对象封装在适配器中， 从而动态地获取所需功能。 如要这一点正常运作， 目标类必须要有通用接口， 适配器的成员变量应当遵循该通用接口。 这种方式同<strong>装饰模式</strong>非常相似。</p>
<h2 id="实现方式">实现方式</h2>
<ol>
<li>确保至少有两个类的接口不兼容：
<ul>
<li>一个无法修改 （通常是第三方、 遗留系统或者存在众多已有依赖的类） 的功能性服务类。</li>
<li>一个或多个将受益于使用服务类的客户端类。</li>
</ul>
</li>
<li>声明客户端接口， 描述客户端如何与服务交互。</li>
<li>创建遵循客户端接口的适配器类。 所有方法暂时都为空。</li>
<li>在适配器类中添加一个成员变量用于保存对于服务对象的引用。 通常情况下会通过构造函数对该成员变量进行初始化， 但有时在调用其方法时将该变量传递给适配器会更方便。</li>
<li>依次实现适配器类客户端接口的所有方法。 适配器会将实际工作委派给服务对象， 自身只负责接口或数据格式的转换。</li>
<li>客户端必须通过客户端接口使用适配器。 这样一来， 你就可以在不影响客户端代码的情况下修改或扩展适配器。</li>
</ol>
<h2 id="适配器模式优缺点">适配器模式优缺点</h2>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>单一职责原则_你可以将接口或数据转换代码从程序主要业务逻辑中分离。</td>
<td style="text-align:center">代码整体复杂度增加， 因为你需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。</td>
</tr>
<tr>
<td>开闭原则。 只要客户端代码通过客户端接口与适配器进行交互， 你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="与其他模式的关系">与其他模式的关系</h2>
<ul>
<li>
<p><strong>桥接模式</strong>通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， <strong>适配器模式</strong>通常在已有程序中使用， 让相互不兼容的类能很好地合作。</p>
</li>
<li>
<p><strong>适配器</strong>可以对已有对象的接口进行修改， <strong>装饰模式</strong>则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。</p>
</li>
<li>
<p><strong>适配器</strong>能为被封装对象提供不同的接口， <strong>代理模式</strong>能为对象提供相同的接口， <strong>装饰</strong>则能为对象提供加强的接口。</p>
</li>
<li>
<p><strong>外观模式</strong>为现有对象定义了一个新接口，** 适配器**则会试图运用已有的接口。 <strong>适配器</strong>通常只封装一个对象， <strong>外观</strong>通常会作用于整个对象子系统上。</p>
</li>
<li>
<p><strong>桥接</strong>、 <strong>状态模式</strong>和<strong>策略模式</strong> （在某种程度上包括<strong>适配器</strong>） 模式的接口非常相似。 实际上， 它们都基于<strong>组合模式</strong>——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[桥接模式]]></title>
        <id>https://q456qq520.github.io/post/qiao-jie-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/qiao-jie-mo-shi/">
        </link>
        <updated>2022-01-11T10:24:16.000Z</updated>
        <content type="html"><![CDATA[<p>桥接模式是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。</p>
<p>先考虑一个简单的例子。</p>
<p>假如你有一个几何 形状Shape类， 从它能扩展出两个子类： ​ 圆形Circle和 方形Square 。 你希望对这样的类层次结构进行扩展以使其包含颜色， 所以你打算创建名为 红色Red和 蓝色Blue的形状子类。 但是， 由于你已有两个子类， 所以总共需要创建四个类才能覆盖所有组合， 例如 蓝色圆形Blue­Circle和 红色方形Red­Square 。</p>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/diagrams/bridge/problem-zh-2x.png" alt="likecat" title="桥接模式" loading="lazy"></figure>
<p>在层次结构中新增形状和颜色将导致代码复杂程度指数增长。 例如添加三角形状， 你需要新增两个子类， 也就是每种颜色一个； 此后新增一种新颜色需要新增三个子类， 即每种形状一个。 如此以往， 情况会越来越糟糕。</p>
<p>问题的根本原因是我们试图在两个独立的维度——形状与颜色——上扩展形状类。 这在处理类继承时是很常见的问题。</p>
<p>桥接模式通过将继承改为组合的方式来解决这个问题。 具体来说， 就是抽取其中一个维度并使之成为独立的类层次， 这样就可以在初始类中引用这个新层次的对象， 从而使得一个类不必拥有所有的状态和行为。</p>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/bridge/solution-zh-2x.png" alt="将一个类层次转化为多个相关的类层次， 避免单个类层次的失控。" title="将一个类层次转化为多个相关的类层次， 避免单个类层次的失控。" loading="lazy"></figure>
<p>根据该方法， 我们可以将颜色相关的代码抽取到拥有 红色和 蓝色两个子类的颜色类中， 然后在 形状类中添加一个指向某一颜色对象的引用成员变量。 现在， 形状类可以将所有与颜色相关的工作委派给连入的颜色对象。 这样的引用就成为了 形状和 颜色之间的桥梁。 此后， 新增颜色将不再需要修改形状的类层次， 反之亦然。</p>
<h4 id="抽象部分和实现部分">抽象部分和实现部分</h4>
<p>抽象部分 （也被称为接口） 是一些实体的高阶控制层。 该层自身不完成任何具体的工作， 它需要将工作委派给实现部分层 （也被称为平台）。</p>
<p>在实际的程序中， 抽象部分是图形用户界面 （GUI）， 而实现部分则是底层操作系统代码 （API）， GUI 层调用 API 层来对用户的各种操作做出响应。</p>
<p>一般来说， 你可以在两个独立方向上扩展这种应用：</p>
<ul>
<li>开发多个不同的 GUI （例如面向普通用户和管理员进行分别配置）</li>
<li>支持多个不同的 API （例如， 能够在 Windows、 Linux 和 macOS 上运行该程序）。</li>
</ul>
<p>在最糟糕的情况下， 程序可能会是一团乱麻， 其中包含数百种条件语句， 连接着代码各处不同种类的 GUI 和各种 API。</p>
<h4 id="桥接模式结构">桥接模式结构</h4>
<figure data-type="image" tabindex="3"><img src="https://refactoringguru.cn/images/patterns/diagrams/bridge/structure-zh-2x.png" alt="桥接模式" title="桥接模式" loading="lazy"></figure>
<ol>
<li><strong>抽象部分 （Abstraction）</strong> 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。</li>
<li><strong>实现部分 （Implementation） <strong>为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。<br>
抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作。<br>
3.</strong> 具体实现 （Concrete Implementations） <strong>中包括特定于平台的代码。<br>
4.</strong> 精确抽象 （Refined Abstraction）</strong> 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。</li>
<li>通常情况下， **客户端 （Client） **仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。</li>
</ol>
<h4 id="伪代码">伪代码</h4>
<p>所有设备的通用接口</p>
<pre><code>package com.bridge;

/**
 * 所有设备的通用接口
 * @author TZP
 * @version 1.0
 * @date 2022/1/11 23:48
 */
public interface Device {
    //是否在运行
    boolean isEnabled();

    //运行
    void enable();

    //关闭
    void disable();

    //获取体积
    int getVolume();

    void setVolume(int percent);

    //过去渠道
    int getChannel();

    void setChannel(int channel);

    //状态
    void printStatus();
}

</code></pre>
<p>收音机</p>
<pre><code>package com.bridge;

/**
 * 收音机
 * @author TZP
 * @version 1.0
 * @date 2022/1/11 23:51
 */
public class Radio implements Device{
    private boolean on = false;
    private int volume = 30;
    private int channel = 1;

    @Override
    public boolean isEnabled() {
        return on;
    }

    @Override
    public void enable() {
        on = true;
    }

    @Override
    public void disable() {
        on = false;
    }

    @Override
    public int getVolume() {
        return volume;
    }

    @Override
    public void setVolume(int volume) {
        if (volume &gt; 100) {
            this.volume = 100;
        } else if (volume &lt; 0) {
            this.volume = 0;
        } else {
            this.volume = volume;
        }
    }

    @Override
    public int getChannel() {
        return channel;
    }

    @Override
    public void setChannel(int channel) {
        this.channel = channel;
    }

    @Override
    public void printStatus() {
        System.out.println(&quot;------------------------------------&quot;);
        System.out.println(&quot;| I'm radio.&quot;);
        System.out.println(&quot;| I'm &quot; + (on ? &quot;enabled&quot; : &quot;disabled&quot;));
        System.out.println(&quot;| Current volume is &quot; + volume + &quot;%&quot;);
        System.out.println(&quot;| Current channel is &quot; + channel);
        System.out.println(&quot;------------------------------------\n&quot;);
    }
}

</code></pre>
<p>电视机</p>
<pre><code>package com.bridge;

/**
 * 电视机
 * @author TZP
 * @version 1.0
 * @date 2022/1/11 23:53
 */
public class Tv implements Device{
    private boolean on = false;
    private int volume = 30;
    private int channel = 1;

    @Override
    public boolean isEnabled() {
        return on;
    }

    @Override
    public void enable() {
        on = true;
    }

    @Override
    public void disable() {
        on = false;
    }

    @Override
    public int getVolume() {
        return volume;
    }

    @Override
    public void setVolume(int volume) {
        if (volume &gt; 100) {
            this.volume = 100;
        } else if (volume &lt; 0) {
            this.volume = 0;
        } else {
            this.volume = volume;
        }
    }

    @Override
    public int getChannel() {
        return channel;
    }

    @Override
    public void setChannel(int channel) {
        this.channel = channel;
    }

    @Override
    public void printStatus() {
        System.out.println(&quot;------------------------------------&quot;);
        System.out.println(&quot;| I'm TV set.&quot;);
        System.out.println(&quot;| I'm &quot; + (on ? &quot;enabled&quot; : &quot;disabled&quot;));
        System.out.println(&quot;| Current volume is &quot; + volume + &quot;%&quot;);
        System.out.println(&quot;| Current channel is &quot; + channel);
        System.out.println(&quot;------------------------------------\n&quot;);
    }
}
</code></pre>
<p>所有远程控制器的通用接口</p>
<pre><code>package com.bridge;

/**
 * 所有远程控制器的通用接口
 * @author TZP
 * @version 1.0
 * @date 2022/1/11 23:54
 */
public interface Remote {
    void power();

    void volumeDown();

    void volumeUp();

    void channelDown();

    void channelUp();
}

</code></pre>
<p>基础远程控制器</p>
<pre><code>package com.bridge;

/**
 * 基础远程控制器
 * @author TZP
 * @version 1.0
 * @date 2022/1/11 23:56
 */
public class BasicRemote implements Remote{
    protected Device device;

    public BasicRemote() {}

    public BasicRemote(Device device) {
        this.device = device;
    }

    @Override
    public void power() {
        System.out.println(&quot;Remote: power toggle&quot;);
        if (device.isEnabled()) {
            device.disable();
        } else {
            device.enable();
        }
    }

    @Override
    public void volumeDown() {
        System.out.println(&quot;Remote: volume down&quot;);
        device.setVolume(device.getVolume() - 10);
    }

    @Override
    public void volumeUp() {
        System.out.println(&quot;Remote: volume up&quot;);
        device.setVolume(device.getVolume() + 10);
    }

    @Override
    public void channelDown() {
        System.out.println(&quot;Remote: channel down&quot;);
        device.setChannel(device.getChannel() - 1);
    }

    @Override
    public void channelUp() {
        System.out.println(&quot;Remote: channel up&quot;);
        device.setChannel(device.getChannel() + 1);
    }
}

</code></pre>
<p>高级远程控制器</p>
<pre><code>package com.bridge;

/**
 * 高级远程控制器
 * @author TZP
 * @version 1.0
 * @date 2022/1/11 23:57
 */
public class AdvancedRemote extends BasicRemote {

    public AdvancedRemote(Device device) {
        super.device = device;
    }

    public void mute() {
        System.out.println(&quot;Remote: mute&quot;);
        device.setVolume(0);
    }
}

</code></pre>
<p>客户端代码</p>
<pre><code>package com.bridge;

/**
 * 客户端代码
 * @author TZP
 * @version 1.0
 * @date 2022/1/11 23:58
 */
public class Demo {
    public static void main(String[] args) {
        testDevice(new Tv());
        testDevice(new Radio());
    }

    public static void testDevice(Device device) {
        System.out.println(&quot;Tests with basic remote.&quot;);
        BasicRemote basicRemote = new BasicRemote(device);
        basicRemote.power();
        device.printStatus();

        System.out.println(&quot;Tests with advanced remote.&quot;);
        AdvancedRemote advancedRemote = new AdvancedRemote(device);
        advancedRemote.power();
        advancedRemote.mute();
        device.printStatus();
    }
}

</code></pre>
<p>执行结果</p>
<pre><code>Tests with basic remote.
Remote: power toggle
------------------------------------
| I'm TV set.
| I'm enabled
| Current volume is 30%
| Current channel is 1
------------------------------------

Tests with advanced remote.
Remote: power toggle
Remote: mute
------------------------------------
| I'm TV set.
| I'm disabled
| Current volume is 0%
| Current channel is 1
------------------------------------

Tests with basic remote.
Remote: power toggle
------------------------------------
| I'm radio.
| I'm enabled
| Current volume is 30%
| Current channel is 1
------------------------------------

Tests with advanced remote.
Remote: power toggle
Remote: mute
------------------------------------
| I'm radio.
| I'm disabled
| Current volume is 0%
| Current channel is 1
------------------------------------
</code></pre>
<h4 id="桥接模式适合应用场景">桥接模式适合应用场景</h4>
<p>####### 如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。</p>
<p>类的代码行数越多， 弄清其运作方式就越困难， 对其进行修改所花费的时间就越长。 一个功能上的变化可能需要在整个类范围内进行修改， 而且常常会产生错误， 甚至还会有一些严重的副作用。</p>
<p>桥接模式可以将庞杂类拆分为几个类层次结构。 此后， 你可以修改任意一个类层次结构而不会影响到其他类层次结构。 这种方法可以简化代码的维护工作， 并将修改已有代码的风险降到最低。</p>
<p>####### 如果你希望在几个独立维度上扩展一个类， 可使用该模式。<br>
桥接建议将每个维度抽取为独立的类层次。 初始类将相关工作委派给属于对应类层次的对象， 无需自己完成所有工作。</p>
<p>#######  如果你需要在运行时切换不同实现方法， 可使用桥接模式。<br>
当然并不是说一定要实现这一点， 桥接模式可替换抽象部分中的实现对象， 具体操作就和给成员变量赋新值一样简单。</p>
<p>顺便提一句， 最后一点是很多人混淆桥接模式和策略模式的主要原因。 记住， 设计模式并不仅是一种对类进行组织的方式， 它还能用于沟通意图和解决问题。</p>
<h4 id="实现方式">实现方式</h4>
<ol>
<li>
<p>明确类中独立的维度。 独立的概念可能是： 抽象/平台， 域/基础设施， 前端/后端或接口/实现。</p>
</li>
<li>
<p>了解客户端的业务需求， 并在抽象基类中定义它们。</p>
</li>
<li>
<p>确定在所有平台上都可执行的业务。 并在通用实现接口中声明抽象部分所需的业务。</p>
</li>
<li>
<p>为你域内的所有平台创建实现类， 但需确保它们遵循实现部分的接口。</p>
</li>
<li>
<p>在抽象类中添加指向实现类型的引用成员变量。 抽象部分会将大部分工作委派给该成员变量所指向的实现对象。</p>
</li>
<li>
<p>如果你的高层逻辑有多个变体， 则可通过扩展抽象基类为每个变体创建一个精确抽象。</p>
</li>
<li>
<p>客户端代码必须将实现对象传递给抽象部分的构造函数才能使其能够相互关联。 此后， 客户端只需与抽象对象进行交互， 无需和实现对象打交道。</p>
</li>
</ol>
<h4 id="桥接模式优缺点">桥接模式优缺点</h4>
<h5 id="优点">优点</h5>
<ul>
<li>你可以创建与平台无关的类和程序。</li>
<li>客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息。</li>
<li>开闭原则。 你可以新增抽象部分和实现部分， 且它们之间不会相互影响。</li>
<li>单一职责原则。 抽象部分专注于处理高层逻辑， 实现部分处理平台细节。</li>
</ul>
<h5 id="缺点">缺点</h5>
<ul>
<li>对高内聚的类使用该模式可能会让代码更加复杂。</li>
</ul>
<h4 id="与其他模式的关系">与其他模式的关系</h4>
<p>桥接模式通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器模式通常在已有程序中使用， 让相互不兼容的类能很好地合作。</p>
<p>桥接、 状态模式和策略模式 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p>
<p>你可以将抽象工厂模式和桥接搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</p>
<p>你可以结合使用生成器模式和桥接模式： 主管类负责抽象工作， 各种不同的生成器负责实现工作。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法设计的常用思想]]></title>
        <id>https://q456qq520.github.io/post/suan-fa-she-ji-de-chang-yong-si-xiang/</id>
        <link href="https://q456qq520.github.io/post/suan-fa-she-ji-de-chang-yong-si-xiang/">
        </link>
        <updated>2022-01-04T09:31:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="贪婪法">贪婪法</h3>
<p>贪婪法(greedy algorithm)，又称贪心算法，是寻找最优解问题的常用方法。这种方法模式 一般将求解过程分成若干个步骤，在每个步骤都应用贪心原则，选取当前状态下最好的或最优的 选择(局部最有利的选择)，并以此希望最后堆叠出的结果也是最好或最优的解。贪婪法的每次 决策都以当前情况为基础并根据某个最优原则进行选择，不从整体上考虑其他各种可能的情况。 一般来说，这种贪心原则在各种算法模式中都会体现，单独作为一种方法来说明，是因为贪婪法 对于特定的问题是非常有效的方法。</p>
<p>贪婪法和动态规划法以及分治法一样，都需要对问题进行分解，定义最优解的子结构。但是， 贪婪法与其他方法最大的不同在于，贪婪法每一步选择完之后，局部最优解就确定了，不再进行 回溯处理，也就是说，每一个步骤的局部最优解确定以后，就不再修改，直到算法结束。因为不 进行回溯处理，贪婪法只在很少的情况下可以得到真正的最优解，比如最短路径问题、图的最小 生成树问题。大多数情况下，由于选择策略的“短视”，贪婪法会错过真正的最优解，得不到问题的真正答案。但是贪婪法简单高效，省去了为找最优解可能需要的穷举操作，可以得到与最优解比较接近的近似最优解，通常作为其他算法的辅助算法使用。</p>
<ol>
<li>贪婪法的基本思想<br>
贪婪法的基本设计思想有以下三个步骤。</li>
</ol>
<ul>
<li>建立对问题精确描述的数学模型，包括定义最优解的模型;</li>
<li>将问题分解为一系列子问题，同时定义子问题的最优解结构;</li>
<li>应用贪心原则确定每个子问题的局部最优解，并根据最优解的模型，用子问题的局部最<br>
优解堆叠出全局最优解。</li>
</ul>
<p>定义最优解的模型通常和定义子问题的最优解结构是同时进行的，最优解的模型一般都体现 了最优解子问题的分解结构和堆叠方式。对于子问题的分解有多种方式，有的问题可以按照问题 的求解过程一步一步地进行分解，每一步都在前一步的基础上选择当前最好的解，每做一次选择 就将问题简化为一个规模更小的子问题，当最后一步的求解完成后就得到了全局最优解。还有的 问题可以将问题分解成相对独立的几个子问题，对每个子问题求解完成后再按照一定的规则(比 如某种公式或计算法则)将其组合起来得到全局最优解。</p>
<ol start="2">
<li>贪婪法的例子:0-1背包问题</li>
</ol>
<p><strong>0-1 背包问题:有 N 件物品和一个承重为 C 的背包(也 可定义为体积)，每件物品的重量是 wi，价值是 pi，求解将哪几件物品装入背包可使这些物品在 重量总和不超过 C 的情况下价值总和最大。</strong></p>
<p>背包问题(knapsack problem)是此类组合优化的 NP 完全问题的统称，比如货箱装载问题、货船载物问题等，因问题最初来源于如何选择最合适的物 品装在背包中而得名。这个问题隐含了一个条件，每个物品只有一件，也就是限定每件物品只能选择 0 个或 1 个，因此又被称为 0-1 背包问题。</p>
<p>来看一个具体的例子，有一个背包，最多能承载重量为 C=150 的物品，现在有 7 个物品(物 品不能分割成任意大小)，编号为 1~7，重量分别是 wi=[35,30,60,50,40,10,25]，价值分别是 pi=[10,40,30,50,35,40,30]，现在从这 7 个物品中选择一个或多个装入背包，要求在物品总重量不 超过 C 的前提下，所装入的物品总价值最高。这个问题的子问题可以按照选择物品装入背包的过 程按部就班地一步一步分解，将子问题定义为在被背包容量还有 C’的情况下，选择一个物品装 入背包。C’的初始值就是 150，假如选择了一个重为 35 的物品，则子问题就变成在背包容量 C’ 是 115 的情况下，从剩下的 6 件物品中选择一个物品，这样每选择一个物品就相当于子问题的规 模减小了。</p>
<p>那么如何选择物品呢?这就是贪婪策略的选择问题。对于本题，常见的贪婪策略有三种。第 一种策略是根据物品价值选择，每次都选价值最高的物品。根据这个策略最终选择装入背包的物 品编号依次是 4、2、6、5，此时包中物品总重量是 130，总价值是 165。第二种策略是根据物品 重量选择，每次都选择重量最轻的物品。根据这个策略最终选择装入背包的物品编号依次是 6、 7、2、1、5，此时包中物品总重量是 140，总价值是 155。第三种策略是定义一个价值密度的概 念，每次选择都选价值密度最高的物品。物品的价值密度 si 定义为 pi/wi，这 7 件物品的价值密度 分别为 si=[0.286,1.333,0.5,1.0,0.875,4.0,1.2]。根据这个策略最终选择装入背包的物品编号依次是 6、2、7、4、1，此时包中物品的总重量是 150，总价值是 170。<br>
根据前文的分析结果，我们给出贪婪法解决背包问题的算法实现。首先定义背包问题的数 据结构，根据问题描述，可以直接知道每个物品有两个属性，分别是重量和价值。此外，每个 物品只能被选择一次，因此还需要给每个物品增加一个选择状态的属性，因此物品的数据结构 定义如下:</p>
<pre><code>public class TagObject  implements Comparable&lt;TagObject&gt; {

    private int weight; //重量
    private int price; //价值
    private int unitValue;//单位重量价值

    public TagObject(int weight, int price) {
        this.weight = weight;
        this.price = price;
        this.unitValue = (weight == 0) ? 0 : price / weight;
    }

    @Override
    public int compareTo(TagObject tagObject) {
        int value = tagObject.unitValue;
        if (unitValue &gt; value)
            return 1;
        if (unitValue &lt; value)
            return -1;
        return 0;
    }
}
</code></pre>
<p>需要特别说明的是状态值为 2 的情况，这种情况表示用当前策略选择的物品导致总重量超过 背包承重量，在这种情况下，如果放弃这个物品，按照策略从剩下的物品中再选一个，有可能就 能满足背包承重的要求。因此，设置了一个状态 2，表示当前选择物品不合适，下次选择也不要 再选这个物品了。接下来是背包问题的定义，背包问题包括两个属性，一个是可选物品列表，一 个是背包总的承重量。简单定义背包问题数据结构如下:</p>
<pre><code>public class TagKnapsackProblem {

    // 现有的物品
    private TagObject[] bags;
    // 背包的总承重
    private int totalWeight;
    // 背包最大总价值
    private int bestValue;

    public TagKnapsackProblem(TagObject[] bags, int totalWeight) {
        this.bags = bags;
        this.totalWeight = totalWeight;
        // 对背包按单位重量价值从大到小排序
        Arrays.sort(bags, Collections.reverseOrder());
    }

    public void solve() {
        int tempWeight = totalWeight;

        for (int i = 0; i &lt; bags.length; i++) {
            //判断当前物品是否可以放入背包中，若不能则继续循环，查找下一个物品
            if (tempWeight - bags[i].getWeight() &lt; 0)
                continue;

            tempWeight -= bags[i].getWeight();
            bestValue += bags[i].getPrice();
        }
    }

    public int getBestValue() {
        return bestValue;
    }
}
</code></pre>
<p>最后写一个测试类</p>
<pre><code>public class Test {
    public static void main(String[] args) {

        TagObject[] bags = new TagObject[] { new TagObject(2, 13),
                new TagObject(1, 10), new TagObject(3, 24), new TagObject(2, 15),
                new TagObject(4, 28), new TagObject(5, 33), new TagObject(3, 20),
                new TagObject(1, 8) };
        int totalWeight = 12;

        TagKnapsackProblem problem = new TagKnapsackProblem(bags, totalWeight);
        problem.solve();

        System.out.println(problem.getBestValue()); //结果为85
    }
}

</code></pre>
<p>GreedyAlgo()函数是贪婪算法的主体结构，包括子问题的分解和选择策略的选择都在这个函数中。正如函数所展示的那样，它可以作为此类问题的一个通用解决思路。</p>
<h3 id="分治法">分治法</h3>
<ol>
<li>是</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[有一亿个keys要统计，应该用哪种集合？]]></title>
        <id>https://q456qq520.github.io/post/you-yi-yi-ge-keys-yao-tong-ji-ying-gai-yong-na-chong-ji-he/</id>
        <link href="https://q456qq520.github.io/post/you-yi-yi-ge-keys-yao-tong-ji-ying-gai-yong-na-chong-ji-he/">
        </link>
        <updated>2021-12-30T07:58:31.000Z</updated>
        <content type="html"><![CDATA[<p>通常情况下，我们面临的用户数量以及访问量都是巨大的，比如百万、千万级别的用户数量，或者千万级别、甚至亿级别的访问信息。所以，我们必须要选择能够非常高效地统计大量数据（例如亿级）的集合类型。</p>
<p><strong>要想选择合适的集合，我们就得了解常用的集合统计模式。<strong>集合类型常见的四种统计模式，包括</strong>聚合统计、排序统计、二值状态统计和基数统计</strong>。</p>
<h4 id="聚合统计">聚合统计</h4>
<p>所谓的聚合统计，就是指统计多个集合元素的聚合结果，包括：统计多个集合的共有元素（交集统计）；把两个集合相比，统计其中一个集合独有的元素（差集统计）；统计多个集合的所有元素（并集统计）。</p>
<h4 id="排序统计">排序统计</h4>
<p>在Redis常用的4个集合类型中（List、Hash、Set、Sorted Set），List和Sorted Set就属于有序集合。</p>
<p>List是按照元素进入List的顺序进行排序的，而Sorted Set可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入Sorted Set的时间确定权重值，先插入的元素权重小，后插入的元素权重大。</p>
<h4 id="二值状态统计">二值状态统计</h4>
<p>二值状态统计。这里的二值状态就是指集合元素的取值就只有0和1两种。在签到打卡的场景中，我们只用记录签到（1）或未签到（0），所以它就是非常典型的二值状态，</p>
<h4 id="基数统计">基数统计</h4>
<p>基数统计就是指统计一个集合中不重复的元素个数。</p>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/c0/6e/c0bb35d0d91a62ef4ca1bd939a9b136e.jpg" alt="likecat" title="统计" loading="lazy"></figure>
<p>Set和Sorted Set都支持多种聚合统计，不过，对于差集计算来说，只有Set支持。Bitmap也能做多个Bitmap间的聚合计算，包括与、或和异或操作。</p>
<p>当需要进行排序统计时，List中的元素虽然有序，但是一旦有新元素插入，原来的元素在List中的位置就会移动，那么，按位置读取的排序结果可能就不准确了。而Sorted Set本身是按照集合元素的权重排序，可以准确地按序获取结果</p>
<p>如果记录的数据只有0和1两个值的状态，Bitmap会是一个很好的选择，这主要归功于Bitmap对于一个数据只用1个bit记录，可以节省内存。</p>
<p>对于基数统计来说，如果集合元素量达到亿级别而且不需要精确统计时，建议使用HyperLogLog。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis FAQ]]></title>
        <id>https://q456qq520.github.io/post/redis-faq/</id>
        <link href="https://q456qq520.github.io/post/redis-faq/">
        </link>
        <updated>2021-12-17T08:35:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-和跟redis相比simplekv还缺少什么">1. 和跟Redis相比，SimpleKV还缺少什么？</h2>
<ul>
<li>数据结构：缺乏广泛的数据结构支持，比如支持范围查询的SkipList和Stream等数据结构。</li>
<li>高可用：缺乏哨兵或者master-slave模式的高可用设计；</li>
<li>横向扩展：缺乏集群和分片功能；</li>
<li>内存安全性：缺乏内存过载时的key淘汰算法的支持；</li>
<li>内存利用率：没有充分对数据结构进行优化，提高内存利用率，例如使用压缩性的数据结构；</li>
<li>功能扩展：需要具备后续功能的拓展；</li>
<li>不具备事务性：无法保证多个操作的原子性。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/67/36/67e77bea2568a4f0997c1853d9c60036.jpg" alt="likecat" title="FAQ" loading="lazy"></figure>
<h2 id="2-整数数组和压缩列表作为底层数据结构的优势是什么">2. 整数数组和压缩列表作为底层数据结构的优势是什么？</h2>
<p>整数数组和压缩列表的设计，充分体现了Redis“又快又省”特点中的“省”，也就是节省内存空间。整数数组和压缩列表都是在内存中分配一块地址连续的空间，然后把集合中的元素一个接一个地放在这块空间内，非常紧凑。因为元素是挨个连续放置的，我们不用再通过额外的指针把元素串接起来，这就避免了额外指针带来的空间开销。</p>
<p>整数数组和压缩列表中的entry都是实际的集合元素，它们一个挨一个保存，非常节省内存空间。</p>
<figure data-type="image" tabindex="2"><img src="https://static001.geekbang.org/resource/image/2c/2a/2c57cc1c548a0733bd1bf09f397f342a.jpg" alt="likecat" title="FAQ" loading="lazy"></figure>
<p>Redis之所以采用不同的数据结构，其实是在性能和内存使用效率之间进行的平衡。</p>
<h2 id="3-redis基本io模型中还有哪些潜在的性能瓶颈">3. Redis基本IO模型中还有哪些潜在的性能瓶颈？</h2>
<p>在Redis基本IO模型中，主要是主线程在执行操作，任何耗时的操作，例如bigkey、全量返回等操作，都是潜在的性能瓶颈。</p>
<h2 id="4-aof重写过程中有没有其他潜在的阻塞风险">4. AOF重写过程中有没有其他潜在的阻塞风险？</h2>
<p>风险一：Redis主线程fork创建bgrewriteaof子进程时，内核需要创建用于管理子进程的相关数据结构，这些数据结构在操作系统中通常叫作进程控制块（Process Control Block，简称为PCB）。内核要把主线程的PCB内容拷贝给子进程。这个创建和拷贝过程由内核执行，是会阻塞主线程的。而且，在拷贝过程中，子进程要拷贝父进程的页表，这个过程的耗时和Redis实例的内存大小有关。如果Redis实例内存大，页表就会大，fork执行时间就会长，这就会给主线程带来阻塞风险。</p>
<p>风险二：bgrewriteaof子进程会和主线程共享内存。当主线程收到新写或修改的操作时，主线程会申请新的内存空间，用来保存新写或修改的数据，如果操作的是bigkey，也就是数据量大的集合类型数据，那么，主线程会因为申请大空间而面临阻塞风险。因为操作系统在分配内存空间时，有查找和锁的开销，这就会导致阻塞。</p>
<h2 id="5-aof-重写为什么不共享使用-aof-本身的日志">5. AOF 重写为什么不共享使用 AOF 本身的日志？</h2>
<p>如果都用AOF日志的话，主线程要写，bgrewriteaof子进程也要写，这两者会竞争文件系统的锁，这就会对Redis主线程的性能造成影响。</p>
<h2 id="6-使用一个-2-核-cpu-4gb-内存-500gb-磁盘的云主机运行-redisredis-数据库的数据量大小差不多是-2gb-当时-redis主要以修改操作为主写读比例差不多在-82-左右也就是说如果有-100-个请求80-个请求执行的是修改操作-在这个场景下用-rdb-做持久化有什么风险吗">6. 使用一个 2 核 CPU、4GB 内存、500GB 磁盘的云主机运行 Redis，Redis 数据库的数据量大小差不多是 2GB。当时 Redis主要以修改操作为主，写读比例差不多在 8:2 左右，也就是说，如果有 100 个请求，80 个请求执行的是修改操作。在这个场景下，用 RDB 做持久化有什么风险吗？</h2>
<p>内存不足的风险：Redis fork一个bgsave子进程进行RDB写入，如果主线程再接收到写操作，就会采用写时复制。写时复制需要给写操作的数据分配新的内存空间。本问题中写的比例为80%，那么，在持久化过程中，为了保存80%写操作涉及的数据，写时复制机制会在实例内存中，为这些数据再分配新内存空间，分配的内存量相当于整个实例数据量的80%，大约是1.6GB，这样一来，整个系统内存的使用量就接近饱和了。此时，如果实例还有大量的新key写入或key修改，云主机内存很快就会被吃光。如果云主机开启了Swap机制，就会有一部分数据被换到磁盘上，当访问磁盘上的这部分数据时，性能会急剧下降。如果云主机没有开启Swap，会直接触发OOM，整个Redis实例会面临被系统kill掉的风险。</p>
<p>主线程和子进程竞争使用CPU的风险：生成RDB的子进程需要CPU核运行，主线程本身也需要CPU核运行，而且，如果Redis还启用了后台线程，此时，主线程、子进程和后台线程都会竞争CPU资源。由于云主机只有2核CPU，这就会影响到主线程处理请求的速度。</p>
<h2 id="6-为什么主从库间的复制不使用-aof">6. 为什么主从库间的复制不使用 AOF？</h2>
<p>RDB文件是二进制文件，无论是要把RDB写入磁盘，还是要通过网络传输RDB，IO效率都比记录和传输AOF的高。<br>
在从库端进行恢复时，用RDB的恢复效率要高于用AOF。</p>
<h2 id="7-在主从切换过程中客户端能否正常地进行请求操作呢">7. 在主从切换过程中，客户端能否正常地进行请求操作呢？</h2>
<p>主从集群一般是采用读写分离模式，当主库故障后，客户端仍然可以把读请求发送给从库，让从库服务。但是，对于写请求操作，客户端就无法执行了。</p>
<h2 id="8-如果想要应用程序不感知服务的中断还需要哨兵或客户端再做些什么吗">8. 如果想要应用程序不感知服务的中断，还需要哨兵或客户端再做些什么吗？</h2>
<p>一方面，客户端需要能缓存应用发送的写请求。只要不是同步写操作（Redis应用场景一般也没有同步写），写请求通常不会在应用程序的关键路径上，所以，客户端缓存写请求后，给应用程序返回一个确认就行。</p>
<p>另一方面，主从切换完成后，客户端要能和新主库重新建立连接，哨兵需要提供订阅频道，让客户端能够订阅到新主库的信息。同时，客户端也需要能主动和哨兵通信，询问新主库的信息。</p>
<h2 id="9-5个哨兵实例的集群quorum值设为2-在运行过程中如果有3个哨兵实例都发生故障了此时redis主库如果有故障还能正确地判断主库客观下线吗如果可以的话还能进行主从库自动切换吗">9. 5个哨兵实例的集群，quorum值设为2。在运行过程中，如果有3个哨兵实例都发生故障了，此时，Redis主库如果有故障，还能正确地判断主库“客观下线”吗？如果可以的话，还能进行主从库自动切换吗？</h2>
<p>因为判定主库“客观下线”的依据是，认为主库“主观下线”的哨兵个数要大于等于quorum值，现在还剩2个哨兵实例，个数正好等于quorum值，所以还能正常判断主库是否处于“客观下线”状态。如果一个哨兵想要执行主从切换，就要获到半数以上的哨兵投票赞成，也就是至少需要3个哨兵投票赞成。但是，现在只有2个哨兵了，所以就无法进行主从切换了。</p>
<h2 id="10-哨兵实例是不是越多越好呢如果同时调大down-after-milliseconds值对减少误判是不是也有好处">10. 哨兵实例是不是越多越好呢？如果同时调大down-after-milliseconds值，对减少误判是不是也有好处？</h2>
<p>哨兵实例越多，误判率会越低，但是在判定主库下线和选举Leader时，实例需要拿到的赞成票数也越多，等待所有哨兵投完票的时间可能也会相应增加，主从库切换的时间也会变长，客户端容易堆积较多的请求操作，可能会导致客户端请求溢出，从而造成请求丢失。如果业务层对Redis的操作有响应时间要求，就可能会因为新主库一直没有选定，新操作无法执行而发生超时报警。</p>
<p>调大down-after-milliseconds后，可能会导致这样的情况：主库实际已经发生故障了，但是哨兵过了很长时间才判断出来，这就会影响到Redis对业务的可用性。</p>
<h2 id="11-为什么redis不直接用一个表把键值对和实例的对应关系记录下来">11. 为什么Redis不直接用一个表，把键值对和实例的对应关系记录下来</h2>
<p>如果使用表记录键值对和实例的对应关系，一旦键值对和实例的对应关系发生了变化（例如实例有增减或者数据重新分布），就要修改表。如果是单线程操作表，那么所有操作都要串行执行，性能慢；如果是多线程操作表，就涉及到加锁开销。此外，如果数据量非常大，使用表记录键值对和实例的对应关系，需要的额外存储空间也会增加。</p>
<p>基于哈希槽计算时，虽然也要记录哈希槽和实例的对应关系，但是哈希槽的个数要比键值对的个数少很多，无论是修改哈希槽和实例的对应关系，还是使用额外空间存储哈希槽和实例的对应关系，都比直接记录键值对和实例的关系的开销小得多。</p>
<h2 id="12-rehash的触发时机和渐进式执行机制">12. rehash的触发时机和渐进式执行机制</h2>
<h4 id="1redis什么时候做rehash">1.Redis什么时候做rehash？</h4>
<p>Redis会使用装载因子（load factor）来判断是否需要做rehash。装载因子的计算方式是，哈希表中所有entry的个数除以哈希表的哈希桶个数。Redis会根据装载因子的两种情况，来触发rehash操作：</p>
<ul>
<li>装载因子≥1，同时，哈希表被允许进行rehash；</li>
<li>装载因子≥5。</li>
</ul>
<p>在第一种情况下，如果装载因子等于1，同时我们假设，所有键值对是平均分布在哈希表的各个桶中的，那么，此时，哈希表可以不用链式哈希，因为一个哈希桶正好保存了一个键值对。</p>
<p>但是，如果此时再有新的数据写入，哈希表就要使用链式哈希了，这会对查询性能产生影响。在进行RDB生成和AOF重写时，哈希表的rehash是被禁止的，这是为了避免对RDB和AOF重写造成影响。如果此时，Redis没有在生成RDB和重写AOF，那么，就可以进行rehash。否则的话，再有数据写入时，哈希表就要开始使用查询较慢的链式哈希了。</p>
<p>在第二种情况下，也就是装载因子大于等于5时，就表明当前保存的数据量已经远远大于哈希桶的个数，哈希桶里会有大量的链式哈希存在，性能会受到严重影响，此时，就立马开始做rehash。</p>
<p>如果装载因子小于1，或者装载因子大于1但是小于5，同时哈希表暂时不被允许进行rehash（例如，实例正在生成RDB或者重写AOF），此时，哈希表是不会进行rehash操作的。</p>
<h2 id="12-写时复制的底层实现机制">12. 写时复制的底层实现机制</h2>
<p>Redis在使用RDB方式进行持久化时，会用到写时复制机制。</p>
<p>对Redis来说，主线程fork出bgsave子进程后，bgsave子进程实际是复制了主线程的页表。这些页表中，就保存了在执行bgsave命令时，主线程的所有数据块在内存中的物理地址。这样一来，bgsave子进程生成RDB时，就可以根据页表读取这些数据，再写入磁盘中。如果此时，主线程接收到了新写或修改操作，那么，主线程会使用写时复制机制。具体来说，写时复制就是指，主线程在有写操作时，才会把这个新写或修改后的数据写入到一个新的物理地址中，并修改自己的页表映射。</p>
<p>借助下图中的例子，具体展示一下写时复制的底层机制。</p>
<p>bgsave子进程复制主线程的页表以后，假如主线程需要修改虚页7里的数据，那么，主线程就需要新分配一个物理页（假设是物理页53），然后把修改后的虚页7里的数据写到物理页53上，而虚页7里原来的数据仍然保存在物理页33上。这个时候，虚页7到物理页33的映射关系，仍然保留在bgsave子进程中。所以，bgsave子进程可以无误地把虚页7的原始数据写入RDB文件。</p>
<figure data-type="image" tabindex="3"><img src="https://static001.geekbang.org/resource/image/cc/eb/cc98dc9f65a1079f3638158aacf81aeb.jpg" alt="likecat" title="FAQ" loading="lazy"></figure>
<h2 id="13-replication-buffer和repl_backlog_buffer的区别">13. replication buffer和repl_backlog_buffer的区别</h2>
<p>replication buffer是主从库在进行全量复制时，主库上用于和从库连接的客户端的buffer，而repl_backlog_buffer是为了支持从库增量复制，主库上用于持续保存写操作的一块专用buffer。</p>
<p>Redis主从库在进行复制时，当主库要把全量复制期间的写操作命令发给从库时，主库会先创建一个客户端，用来连接从库，然后通过这个客户端，把写操作命令发给从库。在内存中，主库上的客户端就会对应一个buffer，这个buffer就被称为replication buffer。Redis通过client_buffer配置项来控制这个buffer的大小。主库会给每个从库建立一个客户端，所以replication buffer不是共享的，而是每个从库都有一个对应的客户端。</p>
<p>repl_backlog_buffer是一块专用buffer，在Redis服务器启动后，开始一直接收写操作命令，这是所有从库共享的。主库和从库会各自记录自己的复制进度，所以，不同的从库在进行恢复时，会把自己的复制进度（slave_repl_offset）发给主库，主库就可以和它独立同步。</p>
<figure data-type="image" tabindex="4"><img src="https://static001.geekbang.org/resource/image/7a/a8/7a1795yy4f6dc064f0d34ef1231203a8.jpg" alt="likecat" title="FAQ" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis切片集群]]></title>
        <id>https://q456qq520.github.io/post/redis-qie-pian-ji-qun/</id>
        <link href="https://q456qq520.github.io/post/redis-qie-pian-ji-qun/">
        </link>
        <updated>2021-12-17T08:09:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="定义">定义</h2>
<p>切片集群，也叫分片集群，就是指启动多个Redis实例组成一个集群，然后按照一定的规则，把收到的数据划分成多份，每一份用一个实例来保存。</p>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/79/26/793251ca784yyf6ac37fe46389094b26.jpg" alt="sdas" title="切片集群" loading="lazy"></figure>
<p>那么，在切片集群中，实例在为5GB数据生成RDB时，数据量就小了很多，fork子进程一般不会给主线程带来较长时间的阻塞。采用多个实例保存数据切片后，我们既能保存25GB数据，又避免了fork子进程阻塞主线程而导致的响应突然变慢。</p>
<h2 id="如何保存更多数据">如何保存更多数据？</h2>
<h4 id="纵向扩展scale-up">纵向扩展（scale up）</h4>
<p>升级单个Redis实例的资源配置，包括增加内存容量、增加磁盘容量、使用更高配置的CPU。就像下图中，原来的实例内存是8GB，硬盘是50GB，纵向扩展后，内存增加到24GB，磁盘增加到150GB。</p>
<h4 id="横向扩展scale-out">横向扩展（scale out）。</h4>
<p>横向增加当前Redis实例的个数，就像下图中，原来使用1个8GB内存、50GB磁盘的实例，现在使用三个相同配置的实例。</p>
<figure data-type="image" tabindex="2"><img src="https://static001.geekbang.org/resource/image/7a/1a/7a512fec7eba789c6d098b834929701a.jpg%22%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%22" alt="sdas" loading="lazy"></figure>
<p>纵向扩展的好处是，**实施起来简单、直接。**不过，这个方案也面临两个潜在的问题。</p>
<p>第一个问题是，当使用RDB对数据进行持久化时，如果数据量增加，需要的内存也会增加，主线程fork子进程时就可能会阻塞（比如刚刚的例子中的情况）。不过，如果你不要求持久化保存Redis数据，那么，纵向扩展会是一个不错的选择。</p>
<p>不过，这时，你还要面对第二个问题：**纵向扩展会受到硬件和成本的限制。**这很容易理解，毕竟，把内存从32GB扩展到64GB还算容易，但是，要想扩充到1TB，就会面临硬件容量和成本上的限制了。</p>
<p>与纵向扩展相比，横向扩展是一个扩展性更好的方案。这是因为，要想保存更多的数据，采用这种方案的话，只用增加Redis的实例个数就行了，不用担心单个实例的硬件和成本限制。<strong>在面向百万、千万级别的用户规模时，横向扩展的Redis切片集群会是一个非常好的选择。</strong></p>
<p>不过，在只使用单个实例的时候，数据存在哪儿，客户端访问哪儿，都是非常明确的，但是，切片集群不可避免地涉及到多个实例的分布式管理问题。要想把切片集群用起来，我们就需要解决两大问题：</p>
<ul>
<li>数据切片后，在多个实例之间如何分布？</li>
<li>客户端怎么确定想要访问的数据在哪个实例上？</li>
</ul>
<h2 id="数据切片和实例的对应分布关系">数据切片和实例的对应分布关系</h2>
<p>在切片集群中，数据需要分布在不同实例上，那么，数据和实例之间如何对应呢？这就和接下来我要讲的Redis Cluster方案有关了。不过，我们要先弄明白切片集群和Redis Cluster的联系与区别。</p>
<p>实际上，切片集群是一种保存大量数据的通用机制，这个机制可以有不同的实现方案。在Redis 3.0之前，官方并没有针对切片集群提供具体的方案。从3.0开始，官方提供了一个名为Redis Cluster的方案，用于实现切片集群。Redis Cluster方案中就规定了数据和实例的对应规则。</p>
<p>具体来说，Redis Cluster方案采用哈希槽（Hash Slot，接下来我会直接称之为Slot），来处理数据和实例之间的映射关系。在Redis Cluster方案中，一个切片集群共有16384个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的key，被映射到一个哈希槽中。</p>
<p>具体的映射过程分为两大步：首先根据键值对的key，按照<strong>CRC16算法</strong>计算一个16 bit的值；然后，再用这个16bit值对16384取模，得到0~16383范围内的模数，每个模数代表一个相应编号的哈希槽。</p>
<p>我们在部署Redis Cluster方案时，可以使用cluster create命令创建集群，此时，Redis会自动把这些槽平均分布在集群实例上。例如，如果集群中有N个实例，那么，每个实例上的槽个数为16384/N个。</p>
<p>当然， 我们也可以使用cluster meet命令手动建立实例间的连接，形成集群，再使用cluster addslots命令，指定每个实例上的哈希槽个数。</p>
<h2 id="客户端如何定位数据">客户端如何定位数据？</h2>
<p>在定位键值对数据时，它所处的哈希槽是可以通过计算得到的，这个计算可以在客户端发送请求时来执行。但是，要进一步定位到实例，还需要知道哈希槽分布在哪个实例上。</p>
<p>一般来说，客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端。但是，在集群刚刚创建的时候，每个实例只知道自己被分配了哪些哈希槽，是不知道其他实例拥有的哈希槽信息的。</p>
<p>那么，客户端为什么可以在访问任何一个实例时，都能获得所有的哈希槽信息呢？这是因为，Redis实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。</p>
<p>客户端收到哈希槽信息后，会把哈希槽信息缓存在本地。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。</p>
<p>但是，在集群中，实例和哈希槽的对应关系并不是一成不变的，最常见的变化有两个：</p>
<ul>
<li>在集群中，实例有新增或删除，Redis需要重新分配哈希槽；</li>
<li>为了负载均衡，Redis需要把哈希槽在所有实例上重新分布一遍。</li>
</ul>
<p>此时，实例之间还可以通过相互传递消息，获得最新的哈希槽分配信息，但是，客户端是无法主动感知这些变化的。这就会导致，它缓存的分配信息和最新的分配信息就不一致了，那该怎么办呢？</p>
<p>Redis Cluster方案提供了一种<strong>重定向机制</strong>，所谓的“重定向”，就是指，客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据，客户端要再给一个新实例发送操作命令。</p>
<p>那客户端又是怎么知道重定向时的新实例的访问地址呢？当客户端把一个键值对的操作请求发给一个实例时，如果这个实例上并没有这个键值对映射的哈希槽，那么，这个实例就会给客户端返回下面的MOVED命令响应结果，这个结果中就包含了新实例的访问地址。</p>
<p><code>GET hello:key (error) MOVED 13320 172.16.19.5:6379</code></p>
<p>MOVED命令表示，客户端请求的键值对所在的哈希槽13320，实际是在172.16.19.5这个实例上。通过返回的MOVED命令，就相当于把哈希槽所在的新实例的信息告诉给客户端了。这样一来，客户端就可以直接和172.16.19.5连接，并发送操作请求了。</p>
<p>MOVED重定向命令的使用方法。可以看到，由于负载均衡，Slot 2中的数据已经从实例2迁移到了实例3，但是，客户端缓存仍然记录着“Slot 2在实例2”的信息，所以会给实例2发送命令。实例2给客户端返回一条MOVED命令，把Slot 2的最新位置（也就是在实例3上），返回给客户端，客户端就会再次向实例3发送请求，同时还会更新本地缓存，把Slot 2与实例的对应关系更新过来。</p>
<figure data-type="image" tabindex="3"><img src="https://static001.geekbang.org/resource/image/35/09/350abedefcdbc39d6a8a8f1874eb0809.jpg%22%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%22" alt="sdas" loading="lazy"></figure>
<p>需要注意的是，在上图中，当客户端给实例2发送命令时，Slot 2中的数据已经全部迁移到了实例3。在实际应用时，如果Slot 2中的数据比较多，就可能会出现一种情况：客户端向实例2发送请求，但此时，Slot 2中的数据只有一部分迁移到了实例3，还有部分数据没有迁移。在这种迁移部分完成的情况下，客户端就会收到一条ASK报错信息，如下所示：</p>
<p><code>GET hello:key (error) ASK 13320 172.16.19.5:6379</code></p>
<p>这个结果中的ASK命令就表示，客户端请求的键值对所在的哈希槽13320，在172.16.19.5这个实例上，但是这个哈希槽正在迁移。此时，客户端需要先给172.16.19.5这个实例发送一个ASKING命令。这个命令的意思是，让这个实例允许执行客户端接下来发送的命令。然后，客户端再向这个实例发送GET命令，以读取数据。</p>
<p>在下图中，Slot 2正在从实例2往实例3迁移，key1和key2已经迁移过去，key3和key4还在实例2。客户端向实例2请求key2后，就会收到实例2返回的ASK命令。</p>
<p>ASK命令表示两层含义：第一，表明Slot数据还在迁移中；第二，ASK命令把客户端所请求数据的最新实例地址返回给客户端，此时，客户端需要给实例3发送ASKING命令，然后再发送操作命令。</p>
<figure data-type="image" tabindex="4"><img src="https://static001.geekbang.org/resource/image/e9/b0/e93ae7f4edf30724d58bf68yy714eeb0.jpg%22%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%22" alt="sdas" loading="lazy"></figure>
<p>和MOVED命令不同，<strong>ASK命令并不会更新客户端缓存的哈希槽分配信息</strong>。所以，在上图中，如果客户端再次请求Slot 2中的数据，它还是会给实例2发送请求。这也就是说，ASK命令的作用只是让客户端能给新实例发送一次请求，而不像MOVED命令那样，会更改本地缓存，让后续所有命令都发往新实例。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis哨兵模式]]></title>
        <id>https://q456qq520.github.io/post/redis-shao-bing-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/redis-shao-bing-mo-shi/">
        </link>
        <updated>2021-12-16T09:17:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="为何会有哨兵模式">为何会有哨兵模式？</h2>
<p>redis写操作是由主库控制，而读操作可以由从库支持。但是如果主库挂了，那还未来得及同步的数据将丢失，而且也无法提供写服务。所以，如果主库挂了，我们就需要运行一个新主库，比如说把一个从库切换为主库，把它当成主库。这就涉及到三个问题：</p>
<ul>
<li>主库真的挂了吗？</li>
<li>该选择哪个从库作为主库？</li>
<li>怎么把新主库的相关信息通知给从库和客户端呢？</li>
</ul>
<p>而哨兵机制就是解决以上三个问题。<br>
哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制模式下故障转移的这三个问题。<br>
<img src="https://static001.geekbang.org/resource/image/d8/20/d828d7eee133cec690dc140e99e26f20.jpg" alt="sdas" title="redis哨兵机制" loading="lazy"></p>
<h2 id="哨兵机制的基本流程">哨兵机制的基本流程</h2>
<p>哨兵就是一个运行在特殊模式下的Redis进程，主从库实例运行的同时，它也在运行。哨兵主要负责的就是三个任务：监控、选主（选择主库）和通知。</p>
<ul>
<li>
<p>监控是指哨兵进程在运行时，周期性地给所有的主从库发送PING命令，检测它们是否仍然在线运行。如果从库没有在规定时间内响应哨兵的PING命令，哨兵就会把它标记为“下线状态”；同样，如果主库也没有在规定时间内响应哨兵的PING命令，哨兵就会判定主库下线，然后开始自动切换主库的流程。</p>
</li>
<li>
<p>选主。主库挂了以后，哨兵就需要从很多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库。</p>
</li>
<li>
<p>通知。在执行通知任务时，哨兵会把新主库的连接信息发给其他从库，让它们执行replicaof命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/ef/a1/efcfa517d0f09d057be7da32a84cf2a1.jpg" alt="sdas" title="redis哨兵机制" loading="lazy"></figure>
<h2 id="哨兵判断主库是否下线">哨兵判断主库是否下线？</h2>
<h4 id="主观下线">主观下线</h4>
<p><strong>哨兵进程会使用PING命令检测它自己和主、从库的网络连接情况，用来判断实例的状态。</strong><br>
如果哨兵发现主库或从库对PING命令的响应超时了，那么，哨兵就会先把它标记为“主观下线”。</p>
<p>如果检测的是从库，那么，哨兵简单地把它标记为“主观下线”就行了，因为从库的下线影响一般不太大，集群的对外服务不会间断。</p>
<p>但是，如果检测的是主库，那么，哨兵还不能简单地把它标记为“主观下线”，开启主从切换。因为很有可能存在这么一个情况：那就是哨兵误判了，其实主库并没有故障。可是，一旦启动了主从切换，后续的选主和通知操作都会带来额外的计算和通信开销。<br>
为了避免这些不必要的开销，我们要特别注意误判的情况。</p>
<p>首先，我们要知道啥叫误判。很简单，就是主库实际并没有下线，但是哨兵误以为它下线了。误判一般会发生在集群网络压力较大、网络拥塞，或者是主库本身压力较大的情况下。</p>
<p>一旦哨兵判断主库下线了，就会开始选择新主库，并让从库和新主库进行数据同步，这个过程本身就会有开销，例如，哨兵要花时间选出新主库，从库也需要花时间和新主库同步。而在误判的情况下，主库本身根本就不需要进行切换的，所以这个过程的开销是没有价值的。正因为这样，我们需要判断是否有误判，以及减少误判。</p>
<p>那怎么减少误判呢？它通常会<strong>采用多实例组成的集群模式进行部署，这也被称为哨兵集群</strong>。引入多个哨兵实例一起来判断，就可以避免单个哨兵因为自身网络状况不好，而误判主库下线的情况。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低。</p>
<h4 id="客观下线">客观下线</h4>
<p>在判断主库是否下线时，不能由一个哨兵说了算，只有大多数的哨兵实例，都判断主库已经“主观下线”了，主库才会被标记为“客观下线”，这个叫法也是表明主库下线成为一个客观事实了。这个判断原则就是：少数服从多数。同时，这会进一步触发哨兵开始主从切换流程。</p>
<p>如下图所示，Redis主从集群有一个主库、三个从库，还有三个哨兵实例。在图片的左边，哨兵2判断主库为“主观下线”，但哨兵1和3却判定主库是上线状态，此时，主库仍然被判断为处于上线状态。在图片的右边，哨兵1和2都判断主库为“主观下线”，此时，即使哨兵3仍然判断主库为上线状态，主库也被标记为“客观下线”了。</p>
<p>简单来说，“客观下线”的标准就是，当有N个哨兵实例时，最好要有N/2 + 1个实例判断主库为“主观下线”，才能最终判定主库为“客观下线”。这样一来，就可以减少误判的概率，也能避免误判带来的无谓的主从库切换。</p>
<figure data-type="image" tabindex="2"><img src="https://static001.geekbang.org/resource/image/19/0d/1945703abf16ee14e2f7559873e4e60d.jpg" alt="sdas" title="redis哨兵机制" loading="lazy"></figure>
<h2 id="如何选定新主库">如何选定新主库？</h2>
<p>我把哨兵选择新主库的过程称为“筛选+打分”。简单来说，我们在多个从库中，先按照一定的筛选条件，把不符合条件的从库去掉。然后，我们再按照一定的规则，给剩下的从库逐个打分，将得分最高的从库选为新主库，如下图所示：</p>
<figure data-type="image" tabindex="3"><img src="https://static001.geekbang.org/resource/image/f2/4c/f2e9b8830db46d959daa6a39fbf4a14c.jpg" alt="sdas" title="redis哨兵机制" loading="lazy"></figure>
<p>一般情况下，我们肯定要先保证所选的从库仍然在线运行。不过，在选主时从库正常在线，这只能表示从库的现状良好，并不代表它就是最适合做主库的。</p>
<p>设想一下，如果在选主时，一个从库正常运行，我们把它选为新主库开始使用了。可是，很快它的网络出了故障，此时，我们就得重新选主了。这显然不是我们期望的结果。</p>
<p>所以，在选主时，除了要检查从库的当前在线状态，还要判断它之前的网络连接状态。如果从库总是和主库断连，而且断连次数超出了一定的阈值，我们就有理由相信，这个从库的网络状况并不是太好，就可以把这个从库筛掉了。</p>
<p>具体怎么判断呢？你使用配置项down-after-milliseconds * 10。其中，down-after-milliseconds是我们认定主从库断连的最大连接超时时间。如果在down-after-milliseconds毫秒内，主从节点都没有通过网络联系上，我们就可以认为主从节点断连了。如果发生断连的次数超过了10次，就说明这个从库的网络状况不好，不适合作为新主库。</p>
<p>接下来就要给剩余的从库打分了。我们可以分别按照三个规则依次进行三轮打分，这三个规则分别是<strong>从库优先级、从库复制进度以及从库ID号</strong>。只要在某一轮中，有从库得分最高，那么它就是主库了，选主过程到此结束。如果没有出现得分最高的从库，那么就继续进行下一轮。</p>
<p><strong>第一轮：优先级最高的从库得分高。</strong></p>
<p>用户可以通过<strong>slave-priority配置项</strong>，给不同的从库设置不同优先级。比如，你有两个从库，它们的内存大小不一样，你可以手动给内存大的实例设置一个高优先级。在选主时，哨兵会给优先级高的从库打高分，如果有一个从库优先级最高，那么它就是新主库了。如果从库的优先级都一样，那么哨兵开始第二轮打分。</p>
<p><strong>第二轮：和旧主库同步程度最接近的从库得分高。</strong></p>
<p>这个规则的依据是，如果选择和旧主库同步最接近的那个从库作为主库，那么，这个新主库上就有最新的数据。</p>
<p>主从库同步时有个命令传播的过程。在这个过程中，主库会用master_repl_offset记录当前的最新写操作在repl_backlog_buffer中的位置，而从库会用slave_repl_offset这个值记录当前的复制进度。</p>
<p>此时，我们想要找的从库，它的slave_repl_offset需要最接近master_repl_offset。如果在所有从库中，有从库的slave_repl_offset最接近master_repl_offset，那么它的得分就最高，可以作为新主库。</p>
<p>就像下图所示，旧主库的master_repl_offset是1000，从库1、2和3的slave_repl_offset分别是950、990和900，那么，从库2就应该被选为新主库。</p>
<figure data-type="image" tabindex="4"><img src="https://static001.geekbang.org/resource/image/62/df/626yy88853a2d15b5196b922367140df.jpg" alt="sdas" title="redis哨兵机制" loading="lazy"></figure>
<p>当然，如果有两个从库的slave_repl_offset值大小是一样的（例如，从库1和从库2的slave_repl_offset值都是990），我们就需要给它们进行第三轮打分了。</p>
<p><strong>第三轮：ID号小的从库得分高。</strong></p>
<p>每个实例都会有一个ID，这个ID就类似于这里的从库的编号。目前，Redis在选主库时，有一个默认的规定：<strong>在优先级和复制进度都相同的情况下，ID号最小的从库得分最高，会被选为新主库。</strong></p>
<h2 id="哨兵挂了主从库还能切换吗">哨兵挂了，主从库还能切换吗？</h2>
<p>一旦多个实例组成了哨兵集群，即使有哨兵实例出现故障挂掉了，其他哨兵还能继续协作完成主从库切换的工作，包括判定主库是不是处于下线状态，选择新主库，以及通知从库和客户端。</p>
<p>在配置哨兵的信息时，我们只需要用到下面的这个配置项，设置主库的IP和端口，并没有配置其他哨兵的连接信息。</p>
<p><code>sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</code></p>
<p>这些哨兵实例既然都不知道彼此的地址，又是怎么组成集群的呢？要弄明白这个问题，我们就需要学习一下哨兵集群的组成和运行机制了。</p>
<h2 id="基于pubsub机制的哨兵集群组成">基于pub/sub机制的哨兵集群组成</h2>
<p>哨兵实例之间可以相互发现，要归功于Redis提供的pub/sub机制，也就是发布/订阅机制。</p>
<p>哨兵只要和主库建立起了连接，就可以在主库上发布消息了，比如说发布它自己的连接信息（IP和端口）。同时，它也可以从主库上订阅消息，获得其他哨兵发布的连接信息。当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的IP地址和端口。</p>
<p>除了哨兵实例，我们自己编写的应用程序也可以通过Redis进行消息的发布和订阅。所以，为了区分不同应用的消息，Redis会以频道的形式，对这些消息进行分门别类的管理。所谓的频道，实际上就是消息的类别。当消息类别相同时，它们就属于同一个频道。反之，就属于不同的频道。<strong>只有订阅了同一个频道的应用，才能通过发布的消息进行信息交换</strong></p>
<p>在主从集群中，主库上有一个名为“<strong>sentinel</strong>:hello”的频道，不同哨兵就是通过它来相互发现，实现互相通信的。</p>
<p>我来举个例子，具体说明一下。在下图中，哨兵1把自己的IP（172.16.19.3）和端口（26579）发布到“<strong>sentinel</strong>:hello”频道上，哨兵2和3订阅了该频道。那么此时，哨兵2和3就可以从这个频道直接获取哨兵1的IP地址和端口号。</p>
<p>然后，哨兵2、3可以和哨兵1建立网络连接。通过这个方式，哨兵2和3也可以建立网络连接，这样一来，哨兵集群就形成了。它们相互间可以通过网络连接进行通信，比如说对主库有没有下线这件事儿进行判断和协商。</p>
<figure data-type="image" tabindex="5"><img src="https://static001.geekbang.org/resource/image/ca/b1/ca42698128aa4c8a374efbc575ea22b1.jpg" alt="sdas" title="redis哨兵机制" loading="lazy"></figure>
<p>哨兵除了彼此之间建立起连接形成集群外，还需要和从库建立连接。这是因为，在哨兵的监控任务中，它需要对主从库都进行心跳判断，而且在主从库切换完成后，它还需要通知从库，让它们和新主库进行同步。</p>
<p><strong>哨兵是如何知道从库的IP地址和端口的呢？</strong></p>
<p>这是由哨兵向主库发送INFO命令来完成的。就像下图所示，哨兵2给主库发送INFO命令，主库接受到这个命令后，就会把从库列表返回给哨兵。接着，哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控。哨兵1和3可以通过相同的方法和从库建立连接。</p>
<figure data-type="image" tabindex="6"><img src="https://static001.geekbang.org/resource/image/88/e0/88fdc68eb94c44efbdf7357260091de0.jpg%22redis%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%22" alt="sdas" loading="lazy"></figure>
<p>通过pub/sub机制，哨兵之间可以组成集群，同时，哨兵又通过INFO命令，获得了从库连接信息，也能和从库建立连接，并进行监控了。</p>
<p>但是，哨兵不能只和主、从库连接。因为，主从库切换后，客户端也需要知道新主库的连接信息，才能向新主库发送请求操作。所以，哨兵还需要完成把新主库的信息告诉客户端这个任务。</p>
<p>而且，在实际使用哨兵时，我们有时会遇到这样的问题：如何在客户端通过监控了解哨兵进行主从切换的过程呢？比如说，主从切换进行到哪一步了？这其实就是要求，客户端能够获取到哨兵集群在监控、选主、切换这个过程中发生的各种事件。</p>
<p>此时，我们仍然可以依赖pub/sub机制，来帮助我们完成哨兵和客户端间的信息同步。</p>
<h2 id="基于pubsub机制的客户端事件通知">基于pub/sub机制的客户端事件通知</h2>
<p>哨兵就是一个运行在特定模式下的Redis实例，只不过它并不服务请求操作，只是完成监控、选主和通知的任务。所以，每个哨兵实例也提供pub/sub机制，客户端可以从哨兵订阅消息。哨兵提供的消息订阅频道有很多，不同频道包含了主从库切换过程中的不同关键事件。</p>
<figure data-type="image" tabindex="7"><img src="https://static001.geekbang.org/resource/image/4e/25/4e9665694a9565abbce1a63cf111f725.jpg%22redis%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%22" alt="sdas" loading="lazy"></figure>
<p>知道了这些频道之后，你就可以让客户端从哨兵这里订阅消息了。具体的操作步骤是，客户端读取哨兵的配置文件后，可以获得哨兵的地址和端口，和哨兵建立网络连接。然后，我们可以在客户端执行订阅命令，来获取不同的事件消息。</p>
<ul>
<li>所有实例进入客观下线状态的事件 <code>SUBSCRIBE +odown</code></li>
<li>订阅所有的事件 <code>PSUBSCRIBE *</code></li>
</ul>
<p>当哨兵把新主库选择出来后，客户端就会看到下面的switch-master事件。这个事件表示主库已经切换了，新主库的IP地址和端口信息已经有了。这个时候，客户端就可以用这里面的新主库地址和端口进行通信了。</p>
<p><code>switch-master &lt;master name&gt; &lt;oldip&gt; &lt;oldport&gt; &lt;newip&gt; &lt;newport&gt;</code></p>
<p>有了这些事件通知，客户端不仅可以在主从切换后得到新主库的连接信息，还可以监控到主从库切换过程中发生的各个重要事件。这样，客户端就可以知道主从切换进行到哪一步了，有助于了解切换进度。</p>
<p>好了，有了pub/sub机制，哨兵和哨兵之间、哨兵和从库之间、哨兵和客户端之间就都能建立起连接了，再加上我们上节课介绍主库下线判断和选主依据，哨兵集群的监控、选主和通知三个任务就基本可以正常工作了。不过，我们还需要考虑一个问题：主库故障以后，哨兵集群有多个实例，那怎么确定由哪个哨兵来进行实际的主从切换呢？</p>
<h2 id="由哪个哨兵执行主从切换">由哪个哨兵执行主从切换？</h2>
<p>确定由哪个哨兵执行主从切换的过程，和主库“客观下线”的判断过程类似，也是一个“投票仲裁”的过程。在具体了解这个过程前，我们再来看下，判断“客观下线”的仲裁过程。</p>
<p>哨兵集群要判定主库“客观下线”，需要有一定数量的实例都认为该主库已经“主观下线”了。</p>
<p>任何一个实例只要自身判断主库“主观下线”后，就会给其他实例发送is-master-down-by-addr命令。接着，其他实例会根据自己和主库的连接情况，做出Y或N的响应，Y相当于赞成票，N相当于反对票。</p>
<figure data-type="image" tabindex="8"><img src="https://static001.geekbang.org/resource/image/e0/84/e0832d432c14c98066a94e0ef86af384.jpg%22redis%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%22" alt="sdas" loading="lazy"></figure>
<p>一个哨兵获得了仲裁所需的赞成票数后，就可以标记主库为“客观下线”。这个所需的赞成票数是通过哨兵配置文件中的quorum配置项设定的。例如，现在有5个哨兵，quorum配置的是3，那么，一个哨兵需要3张赞成票，就可以标记主库为“客观下线”了。这3张赞成票包括哨兵自己的一张赞成票和另外两个哨兵的赞成票。</p>
<p>此时，这个哨兵就可以再给其他哨兵发送命令，表明希望由自己来执行主从切换，并让所有其他哨兵进行投票。这个投票过程称为“Leader选举”。因为最终执行主从切换的哨兵称为Leader，投票过程就是确定Leader。</p>
<p>在投票过程中，任何一个想成为Leader的哨兵，要满足两个条件：第一，拿到半数以上的赞成票；第二，拿到的票数同时还需要大于等于哨兵配置文件中的quorum值。以3个哨兵为例，假设此时的quorum设置为2，那么，任何一个想成为Leader的哨兵只要拿到2张赞成票，就可以了。</p>
<figure data-type="image" tabindex="9"><img src="https://static001.geekbang.org/resource/image/5f/d9/5f6ceeb9337e158cc759e23c0f375fd9.jpg%22redis%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%22" alt="sdas" loading="lazy"></figure>
<p>在T1时刻，S1判断主库为“客观下线”，它想成为Leader，就先给自己投一张赞成票，然后分别向S2和S3发送命令，表示要成为Leader。</p>
<p>在T2时刻，S3判断主库为“客观下线”，它也想成为Leader，所以也先给自己投一张赞成票，再分别向S1和S2发送命令，表示要成为Leader。</p>
<p>在T3时刻，S1收到了S3的Leader投票请求。因为S1已经给自己投了一票Y，所以它不能再给其他哨兵投赞成票了，所以S1回复N表示不同意。同时，S2收到了T2时S3发送的Leader投票请求。因为S2之前没有投过票，它会给第一个向它发送投票请求的哨兵回复Y，给后续再发送投票请求的哨兵回复N，所以，在T3时，S2回复S3，同意S3成为Leader。</p>
<p>在T4时刻，S2才收到T1时S1发送的投票命令。因为S2已经在T3时同意了S3的投票请求，此时，S2给S1回复N，表示不同意S1成为Leader。发生这种情况，是因为S3和S2之间的网络传输正常，而S1和S2之间的网络传输可能正好拥塞了，导致投票请求传输慢了。</p>
<p>最后，在T5时刻，S1得到的票数是来自它自己的一票Y和来自S2的一票N。而S3除了自己的赞成票Y以外，还收到了来自S2的一票Y。此时，S3不仅获得了半数以上的Leader赞成票，也达到预设的quorum值（quorum为2），所以它最终成为了Leader。接着，S3会开始执行选主操作，而且在选定新主库后，会给其他从库和客户端通知新主库的信息。</p>
<p>如果S3没有拿到2票Y，那么这轮投票就不会产生Leader。哨兵集群会等待一段时间（也就是哨兵故障转移超时时间的2倍），再重新选举。这是因为，哨兵集群能够进行成功投票，很大程度上依赖于选举命令的正常网络传播。如果网络压力较大或有短时堵塞，就可能导致没有一个哨兵能拿到半数以上的赞成票。所以，等到网络拥塞好转之后，再进行投票选举，成功的概率就会增加。</p>
<p>需要注意的是，如果哨兵集群只有2个实例，此时，一个哨兵要想成为Leader，必须获得2票，而不是1票。所以，如果有个哨兵挂掉了，那么，此时的集群是无法进行主从库切换的。因此，通常我们至少会配置3个哨兵实例。</p>
<p><strong>要保证所有哨兵实例的配置是一致的，尤其是主观下线的判断值down-after-milliseconds。</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis数据同步]]></title>
        <id>https://q456qq520.github.io/post/redis-shu-ju-tong-bu/</id>
        <link href="https://q456qq520.github.io/post/redis-shu-ju-tong-bu/">
        </link>
        <updated>2021-12-13T09:08:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="主从库如何实现数据一致">主从库如何实现数据一致？</h2>
<p>AOF和RDB能够减少<strong>数据丢失</strong>带来袋损失，那如果单台应用服务器宕机时我们应该如何应对呢？<br>
Redis的做法就是增加副本冗余量，将一份数据同时保存在多个实例上。即使有一个实例出现了故障，需要过一段时间才能恢复，其他实例也可以对外提供服务，不会影响业务使用。</p>
<p>那么就会产生新的问题，多个副本之前如何保持数据同步呢（不管请求打在哪一台服务器上都能读取到一样都数据）？<br>
Redis提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。<br>
读操作：主库、从库都可以接收；<br>
写操作：首先到主库执行，然后，主库将写操作同步给从库。</p>
<p><img src="https://static001.geekbang.org/resource/image/80/2f/809d6707404731f7e493b832aa573a2f.jpg" alt="sdas" title="redis读写分离" loading="lazy"><br>
那么，为什么要采用读写分离的方式呢？</p>
<p>你可以设想一下，如果在上图中，不管是主库还是从库，都能接收客户端的写操作，那么，一个直接的问题就是：如果客户端对同一个数据（例如k1）前后修改了三次，每一次的修改请求都发送到不同的实例上，在不同的实例上执行，那么，这个数据在这三个实例上的副本就不一致了（分别是v1、v2和v3）。在读取这个数据的时候，就可能读取到旧的值。</p>
<p>如果我们非要保持这个数据在三个实例上一致，就要涉及到加锁、实例间协商是否完成修改等一系列操作，但这会带来巨额的开销，当然是不太能接受的。</p>
<p>而主从库模式一旦采用了读写分离，所有数据的修改只会在主库上进行，不用协调三个实例。主库有了最新的数据后，会同步给从库，这样，主从库的数据就是一致的。</p>
<hr>
<h2 id="主从库间如何进行第一次同步">主从库间如何进行第一次同步？</h2>
<p>当我们启动多个Redis实例的时候，它们相互之间就可以通过replicaof（Redis 5.0之前使用slaveof）命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。</p>
<p>例如，现在有实例1（ip：172.16.19.3）和实例2（ip：172.16.19.5），我们在实例2上执行以下这个命令后，实例2就变成了实例1的从库，并从实例1上复制数据：<code>replicaof 172.16.19.3 6379</code><br>
<img src="https://static001.geekbang.org/resource/image/63/a1/63d18fd41efc9635e7e9105ce1c33da1.jpg" alt="blockchain" title="第一次同步" loading="lazy"></p>
<p>第一阶段是主从库间建立连接、协商同步的过程，主要是为全量复制做准备。在这一步，从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。</p>
<p>具体来说，从库给主库发送psync命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync命令包含了主库的runID和复制进度offset两个参数。</p>
<ul>
<li>
<p>runID，是每个Redis实例启动时都会自动生成的一个随机ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的runID，所以将runID设为“？”。</p>
</li>
<li>
<p>offset，此时设为-1，表示第一次复制。</p>
<p>主库收到psync命令后，会用FULLRESYNC响应命令带上两个参数：主库runID和主库目前的复制进度offset，返回给从库。从库收到响应后，会记录下这两个参数。</p>
</li>
</ul>
<p><strong>FULLRESYNC响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库。</strong></p>
<p>在第二阶段，**主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。**这个过程依赖于内存快照生成的RDB文件。</p>
<p>具体来说，主库执行bgsave命令，生成RDB文件，接着将文件发给从库。从库接收到RDB文件后，会先清空当前数据库，然后加载RDB文件。这是因为从库在通过replicaof命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。</p>
<p>在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的RDB文件中。为了保证主从库的数据一致性，主库会在内存中用专门的replication buffer，记录RDB文件生成后收到的所有写操作。</p>
<p>最后，也就是第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。具体的操作是，当主库完成RDB文件发送后，就会把此时replication buffer中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。</p>
<h2 id="主从级联模式分担全量复制时的主库压力">主从级联模式分担全量复制时的主库压力</h2>
<p>通过分析主从库间第一次数据同步的过程，你可以看到，一次全量复制中，对于主库来说，需要完成两个耗时的操作：生成RDB文件和传输RDB文件。</p>
<p>如果从库数量很多，而且都要和主库进行全量复制的话，就会导致主库忙于fork子进程生成RDB文件，进行数据全量同步。fork这个操作会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢。此外，传输RDB文件也会占用主库的网络带宽，同样会给主库的资源使用带来压力。那么，有没有好的解决方法可以分担主库压力呢？</p>
<p>其实是有的，这就是“主-从-从”模式。</p>
<p>在刚才介绍的主从库模式中，所有的从库都是和主库连接，所有的全量复制也都是和主库进行的。现在，我们可以<strong>通过“主-从-从”模式将主库生成RDB和传输RDB的压力，以级联的方式分散到从库上</strong>。</p>
<p>简单来说，我们在部署主从集群的时候，可以手动选择一个从库（比如选择内存资源配置较高的从库），用于级联其他的从库。然后，我们可以再选择一些从库（例如三分之一的从库），在这些从库上执行如下命令，让它们和刚才所选的从库，建立起主从关系。</p>
<p><code>replicaof 所选从库的IP 6379</code></p>
<p>这样一来，这些从库就会知道，在进行同步时，不用再和主库进行交互了，只要和级联的从库进行写操作同步就行了，这就可以减轻主库上的压力，如下图所示：<br>
<img src="https://static001.geekbang.org/resource/image/40/45/403c2ab725dca8d44439f8994959af45.jpg" alt="blockchain" title="主从从同步" loading="lazy"><br>
一旦主从库完成了全量复制，它们之间就会一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为基于长连接的命令传播，可以避免频繁建立连接的开销。</p>
<p>新的问题诞生了，如果<strong>网络断连或阻塞</strong>主从库之间就无法进行命令传播了，从库的数据自然也就没办法和主库保持一致了，客户端就可能从从库读到旧数据。该怎么办呢？</p>
<h2 id="主从库间网络断了怎么办">主从库间网络断了怎么办？</h2>
<p>在Redis 2.8之前，如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。</p>
<p>从Redis 2.8开始，网络断了之后，主从库会采用增量复制的方式继续同步。听名字大概就可以猜到它和全量复制的不同：全量复制是同步所有数据，而增量复制只会把主从库网络断连期间主库收到的命令，同步给从库。</p>
<p>增量复制时，主从库之间具体是怎么保持同步的呢？redis中有一个<strong>repl_backlog_buffer</strong>环形缓冲区，<strong>主库会记录自己写到的位置，从库则会记录自己已经读到的位置</strong>。</p>
<p>刚开始的时候，主库和从库的写读位置在一起，这算是它们的起始位置。随着主库不断接收新的写操作，它在缓冲区中的写位置会逐步偏离起始位置，我们通常用偏移量来衡量这个偏移距离的大小，对主库来说，对应的偏移量就是master_repl_offset。主库接收的新写操作越多，这个值就会越大。</p>
<p>同样，从库在复制完写操作命令后，它在缓冲区中的读位置也开始逐步偏移刚才的起始位置，此时，从库已复制的偏移量slave_repl_offset也在不断增加。正常情况下，这两个偏移量基本相等。</p>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/13/37/13f26570a1b90549e6171ea24554b737.jpg" alt="blockchain" title="主从从同步" loading="lazy"></figure>
<p>主从库的连接恢复之后，从库首先会给主库发送psync命令，并把自己当前的slave_repl_offset发给主库，主库会判断自己的master_repl_offset和slave_repl_offset之间的差距。</p>
<p>在网络断连阶段，主库可能会收到新的写操作命令，所以，一般来说，master_repl_offset会大于slave_repl_offset。此时，主库只用把master_repl_offset和slave_repl_offset之间的命令操作同步给从库就行。<br>
<img src="https://static001.geekbang.org/resource/image/20/16/20e233bd30c3dacb0221yy0c77780b16.jpg" alt="blockchain" title="主从从同步" loading="lazy"><br>
就像刚刚示意图的中间部分，主库和从库之间相差了put d e和put d f两个操作，在增量复制时，主库只需要把它们同步给从库，就行了。</p>
<p>因为repl_backlog_buffer是一个环形缓冲区，所以在缓冲区写满后，主库会继续写入，此时，就会覆盖掉之前写入的操作。如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致。</p>
<p>一般而言，我们可以调整repl_backlog_size这个参数。这个参数和所需的缓冲空间大小有关。缓冲空间的计算公式是：缓冲空间大小 = 主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小。在实际应用中，考虑到可能存在一些突发的请求压力，我们通常需要把这个缓冲空间扩大一倍，即repl_backlog_size = 缓冲空间大小 * 2，这也就是repl_backlog_size的最终值。</p>
<p>举个例子，如果主库每秒写入2000个操作，每个操作的大小为2KB，网络每秒能传输1000个操作，那么，有1000个操作需要缓冲起来，这就至少需要2MB的缓冲空间。否则，新写的命令就会覆盖掉旧操作了。为了应对可能的突发压力，我们最终把repl_backlog_size设为4MB。</p>
<p>这样一来，增量复制时主从库的数据不一致风险就降低了。不过，如果并发请求量非常大，连两倍的缓冲空间都存不下新操作请求的话，此时，主从库数据仍然可能不一致。</p>
<p>针对这种情况，一方面，你可以根据Redis所在服务器的内存资源再适当增加repl_backlog_size值，比如说设置成缓冲空间大小的4倍，另一方面，你可以考虑使用切片集群来分担单个主库的请求压力。</p>
<p>总结来说，有三种模式：<strong>全量复制</strong>、<strong>基于长连接的命令传播</strong>，以及<strong>增量复制</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[原型模式]]></title>
        <id>https://q456qq520.github.io/post/yuan-xing-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/yuan-xing-mo-shi/">
        </link>
        <updated>2021-12-08T08:51:25.000Z</updated>
        <content type="html"><![CDATA[<h4 id="概念">概念</h4>
<p>原型模式是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。</p>
<h4 id="问题">问题</h4>
<p>如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中。</p>
<p>但有个小问题。 并非所有对象都能通过这种方式进行复制， 因为有些对象可能拥有私有成员变量， 它们在对象本身以外是不可见的。</p>
<p>直接复制还有另外一个问题。 因为你必须知道对象所属的类才能创建复制品， 所以代码必须依赖该类。 即使你可以接受额外的依赖性， 那还有另外一个问题： 有时你只知道对象所实现的接口， 而不知道其所属的具体类， 比如可向方法的某个参数传入实现了某个接口的任何对象。</p>
<h4 id="原型模式解决方案">原型模式解决方案</h4>
<p>原型模式将克隆过程委派给被克隆的实际对象。 模式为所有支持<strong>克隆</strong>的对象声明了一个通用接口， 该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合。 通常情况下， 这样的接口中仅包含一个 克隆方法。</p>
<p>所有的类对<strong>克隆</strong>方法的实现都非常相似。 该方法会创建一个当前类的对象， 然后将原始对象所有的成员变量值复制到新建的类中。 你甚至可以复制私有成员变量， 因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。</p>
<p>支持克隆的对象即为原型。 当你的对象有几十个成员变量和几百种类型时， 对其进行<strong>克隆</strong>甚至可以代替子类的构造。</p>
<p>其运作方式如下： 创建一系列不同类型的对象并不同的方式对其进行配置。 如果所需对象与预先配置的对象相同， 那么你只需克隆原型即可， 无需新建一个对象。</p>
<h4 id="原型模式结构">原型模式结构</h4>
<h5 id="基本实现">基本实现</h5>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/diagrams/prototype/structure-2x.png?id=ba75079f42f08028ae4c" alt="原型模式结构" title="原型模式结构" loading="lazy"></figure>
<p>其中几个名次解释如下：</p>
<ul>
<li><strong>原型 （Prototype）</strong> 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 clone克隆的方法。</li>
<li>** 具体原型 （Concrete Prototype）**  类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。</li>
<li>** 客户端 （Client）**  可以复制实现了原型接口的任何对象。</li>
</ul>
<h5 id="原型注册表实现">原型注册表实现</h5>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/prototype/structure-prototype-cache-2x.png?id=a1e4514bbcc9b10968b8" alt="原型注册表实现" title="原型注册表实现" loading="lazy"></figure>
<ul>
<li><strong>原型注册表 （Prototype Registry）</strong> 提供了一种访问常用原型的简单方法， 其中存储了一系列可供随时复制的预生成对象。 最简单的注册表原型是一个 名称 → 原型的哈希表。 但如果需要使用名称以外的条件进行搜索， 你可以创建更加完善的注册表版本。</li>
</ul>
<h4 id="原型模式适合应用场景">原型模式适合应用场景</h4>
<ul>
<li>如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。</li>
<li>如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。</li>
</ul>
<h4 id="实现方式">实现方式</h4>
<ol>
<li>创建原型接口， 并在其中声明<strong>克隆</strong>方法。 如果你已有类层次结构， 则只需在其所有类中添加该方法即可。</li>
<li>原型类必须另行定义一个以该类对象为参数的构造函数。 构造函数必须复制参数对象中的所有成员变量值到新建实体中。 如果你需要修改子类， 则必须调用父类构造函数， 让父类复制其私有成员变量值。</li>
<li>克隆方法通常只有一行代码： 使用<strong>new</strong>运算符调用原型版本的构造函数。 注意， 每个类都必须显式重写克隆方法并使用自身类名调用<strong>new</strong>运算符。 否则， 克隆方法可能会生成父类的对象。</li>
<li>你还可以创建一个中心化原型注册表， 用于存储常用原型。<br>
<em>你可以新建一个工厂类来实现注册表，或者在原型基类中添加一个获取原型的静态方法。 该方法必须能够根据客户端代码设定的条件进行搜索。 搜索条件可以是简单的字符串， 或者是一组复杂的搜索参数。 找到合适的原型后， 注册表应对原型进行克隆， 并将复制生成的对象返回给客户端。最后还要将对子类构造函数的直接调用替换为对原型注册表工厂方法的调用。</em>`</li>
</ol>
<h4 id="优缺点">优缺点</h4>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>你可以克隆对象， 而无需与它们所属的具体类相耦合。</td>
<td style="text-align:center">克隆包含循环引用的复杂对象可能会非常麻烦。</td>
</tr>
<tr>
<td>你可以克隆预生成原型， 避免反复运行初始化代码。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>你可以更方便地生成复杂对象。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>你可以用继承以外的方式来处理复杂对象的不同配置。</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="与其他模式的关系">与其他模式的关系</h4>
<ul>
<li>在许多设计工作的初期都会使用<strong>工厂方法模式 <strong>（较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用</strong>抽象工厂模式、 原型模式</strong>或**生成器模式 **（更灵活但更加复杂）。</li>
<li><strong>抽象工厂模式</strong>通常基于一组<strong>工厂方法</strong>， 但你也可以使用<strong>原型模式</strong>来生成这些类的方法。</li>
<li>原型可用于保存<strong>命令模式</strong>的历史记录。</li>
<li>大量使用<strong>组合模式</strong>和<strong>装饰模式</strong>的设计通常可从对于<strong>原型</strong>的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</li>
<li><strong>原型</strong>并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 <strong>工厂方法</strong>基于继承， 但是它不需要初始化步骤。</li>
<li>有时候<strong>原型</strong>可以作为<strong>备忘录模式的</strong>一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。</li>
<li><strong>抽象工厂</strong>、 <strong>生成器</strong>和<strong>原型</strong>都可以用<strong>单例模式</strong>来实现。</li>
</ul>
<h4 id="伪代码">伪代码</h4>
<p>使用示例： Java 的 Cloneable  （可克隆） 接口就是立即可用的原型模式。任何类都可通过实现该接口来实现可被克隆的性质。<br>
java.lang.Object#clone() （类必须实现 java.lang.Cloneable 接口）<br>
识别方法： 原型可以简单地通过 clone或 copy等方法来识别。</p>
<p>下面就是一个复制图形的例子</p>
<h5 id="shapes-形状列表">shapes: 形状列表</h5>
<h6 id="shapesshapejava-通用形状接口">shapes/Shape.java: 通用形状接口</h6>
<pre><code>package refactoring_guru.prototype.example.shapes;

import java.util.Objects;

public abstract class Shape {
    public int x;
    public int y;
    public String color;

    public Shape() {
    }

    public Shape(Shape target) {
        if (target != null) {
            this.x = target.x;
            this.y = target.y;
            this.color = target.color;
        }
    }

    public abstract Shape clone();

    @Override
    public boolean equals(Object object2) {
        if (!(object2 instanceof Shape)) return false;
        Shape shape2 = (Shape) object2;
        return shape2.x == x &amp;&amp; shape2.y == y &amp;&amp; Objects.equals(shape2.color, color);
    }
}
</code></pre>
<h6 id="shapescirclejava-简单形状">shapes/Circle.java: 简单形状</h6>
<pre><code> package refactoring_guru.prototype.example.shapes;

public class Circle extends Shape {
    public int radius;

    public Circle() {
    }

    public Circle(Circle target) {
        super(target);
        if (target != null) {
            this.radius = target.radius;
        }
    }

    @Override
    public Shape clone() {
        return new Circle(this);
    }

    @Override
    public boolean equals(Object object2) {
        if (!(object2 instanceof Circle) || !super.equals(object2)) return false;
        Circle shape2 = (Circle) object2;
        return shape2.radius == radius;
    }
}
</code></pre>
<h6 id="shapesrectanglejava-另一个形状">shapes/Rectangle.java: 另一个形状</h6>
<pre><code>  package refactoring_guru.prototype.example.shapes;

public class Rectangle extends Shape {
    public int width;
    public int height;

    public Rectangle() {
    }

    public Rectangle(Rectangle target) {
        super(target);
        if (target != null) {
            this.width = target.width;
            this.height = target.height;
        }
    }

    @Override
    public Shape clone() {
        return new Rectangle(this);
    }

    @Override
    public boolean equals(Object object2) {
        if (!(object2 instanceof Rectangle) || !super.equals(object2)) return false;
        Rectangle shape2 = (Rectangle) object2;
        return shape2.width == width &amp;&amp; shape2.height == height;
    }
}
</code></pre>
<h6 id="demojava-克隆示例">Demo.java: 克隆示例</h6>
<pre><code>package refactoring_guru.prototype.example;

import refactoring_guru.prototype.example.shapes.Circle;
import refactoring_guru.prototype.example.shapes.Rectangle;
import refactoring_guru.prototype.example.shapes.Shape;

import java.util.ArrayList;
import java.util.List;

public class Demo {
    public static void main(String[] args) {
        List&lt;Shape&gt; shapes = new ArrayList&lt;&gt;();
        List&lt;Shape&gt; shapesCopy = new ArrayList&lt;&gt;();

        Circle circle = new Circle();
        circle.x = 10;
        circle.y = 20;
        circle.radius = 15;
        circle.color = &quot;red&quot;;
        shapes.add(circle);

        Circle anotherCircle = (Circle) circle.clone();
        shapes.add(anotherCircle);

        Rectangle rectangle = new Rectangle();
        rectangle.width = 10;
        rectangle.height = 20;
        rectangle.color = &quot;blue&quot;;
        shapes.add(rectangle);

        cloneAndCompare(shapes, shapesCopy);
    }

    private static void cloneAndCompare(List&lt;Shape&gt; shapes, List&lt;Shape&gt; shapesCopy) {
        for (Shape shape : shapes) {
            shapesCopy.add(shape.clone());
        }

        for (int i = 0; i &lt; shapes.size(); i++) {
            if (shapes.get(i) != shapesCopy.get(i)) {
                System.out.println(i + &quot;: Shapes are different objects (yay!)&quot;);
                if (shapes.get(i).equals(shapesCopy.get(i))) {
                    System.out.println(i + &quot;: And they are identical (yay!)&quot;);
                } else {
                    System.out.println(i + &quot;: But they are not identical (booo!)&quot;);
                }
            } else {
                System.out.println(i + &quot;: Shape objects are the same (booo!)&quot;);
            }
        }
    }
}
</code></pre>
<h6 id="outputdemotxt-执行结果">OutputDemo.txt: 执行结果</h6>
<pre><code>0: Shapes are different objects (yay!)
0: And they are identical (yay!)
1: Shapes are different objects (yay!)
1: And they are identical (yay!)
2: Shapes are different objects (yay!)
2: And they are identical (yay!)
</code></pre>
<h5 id="原型注册站">原型注册站</h5>
<p>你可以实现中心化的原型注册站 （或工厂）， 其中包含一系列预定义的原型对象。 这样一来， 你就可以通过传递对象名称或其他参数的方式从工厂处获得新的对象。 工厂将搜索合适的原型， 然后对其进行克隆复制， 最后将副本返回给你。</p>
<h5 id="cache">cache</h5>
<h6 id="cachebundledshapecachejava-原型工厂">cache/BundledShapeCache.java: 原型工厂</h6>
<pre><code>package refactoring_guru.prototype.caching.cache;

import refactoring_guru.prototype.example.shapes.Circle;
import refactoring_guru.prototype.example.shapes.Rectangle;
import refactoring_guru.prototype.example.shapes.Shape;

import java.util.HashMap;
import java.util.Map;

public class BundledShapeCache {
    private Map&lt;String, Shape&gt; cache = new HashMap&lt;&gt;();

    public BundledShapeCache() {
        Circle circle = new Circle();
        circle.x = 5;
        circle.y = 7;
        circle.radius = 45;
        circle.color = &quot;Green&quot;;

        Rectangle rectangle = new Rectangle();
        rectangle.x = 6;
        rectangle.y = 9;
        rectangle.width = 8;
        rectangle.height = 10;
        rectangle.color = &quot;Blue&quot;;

        cache.put(&quot;Big green circle&quot;, circle);
        cache.put(&quot;Medium blue rectangle&quot;, rectangle);
    }

    public Shape put(String key, Shape shape) {
        cache.put(key, shape);
        return shape;
    }

    public Shape get(String key) {
        return cache.get(key).clone();
    }
}
</code></pre>
<h6 id="demojava-克隆示例-2">Demo.java: 克隆示例</h6>
<pre><code>package refactoring_guru.prototype.caching;

import refactoring_guru.prototype.caching.cache.BundledShapeCache;
import refactoring_guru.prototype.example.shapes.Shape;

public class Demo {
    public static void main(String[] args) {
        BundledShapeCache cache = new BundledShapeCache();

        Shape shape1 = cache.get(&quot;Big green circle&quot;);
        Shape shape2 = cache.get(&quot;Medium blue rectangle&quot;);
        Shape shape3 = cache.get(&quot;Medium blue rectangle&quot;);

        if (shape1 != shape2 &amp;&amp; !shape1.equals(shape2)) {
            System.out.println(&quot;Big green circle != Medium blue rectangle (yay!)&quot;);
        } else {
            System.out.println(&quot;Big green circle == Medium blue rectangle (booo!)&quot;);
        }

        if (shape2 != shape3) {
            System.out.println(&quot;Medium blue rectangles are two different objects (yay!)&quot;);
            if (shape2.equals(shape3)) {
                System.out.println(&quot;And they are identical (yay!)&quot;);
            } else {
                System.out.println(&quot;But they are not identical (booo!)&quot;);
            }
        } else {
            System.out.println(&quot;Rectangle objects are the same (booo!)&quot;);
        }
    }
}
</code></pre>
<h6 id="outputdemotxt-执行结果-2">OutputDemo.txt: 执行结果</h6>
<pre><code>Big green circle != Medium blue rectangle (yay!)
Medium blue rectangles are two different objects (yay!)
And they are identical (yay!)
</code></pre>
<p><a href="https://refactoringguru.cn/design-patterns/prototype">参考地址：https://refactoringguru.cn/design-patterns/prototype</a></p>
]]></content>
    </entry>
</feed>