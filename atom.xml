<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://q456qq520.github.io</id>
    <title>LIKE CAT</title>
    <updated>2022-03-08T01:52:13.894Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://q456qq520.github.io"/>
    <link rel="self" href="https://q456qq520.github.io/atom.xml"/>
    <subtitle>一条小咸鱼</subtitle>
    <logo>https://q456qq520.github.io/images/avatar.png</logo>
    <icon>https://q456qq520.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, LIKE CAT</rights>
    <entry>
        <title type="html"><![CDATA[ 分布式选举]]></title>
        <id>https://q456qq520.github.io/post/fen-bu-shi-xuan-ju/</id>
        <link href="https://q456qq520.github.io/post/fen-bu-shi-xuan-ju/">
        </link>
        <updated>2022-03-07T11:24:59.000Z</updated>
        <content type="html"><![CDATA[<h1 id="为什么要有分布式选举">为什么要有分布式选举？</h1>
<p>主节点，在一个分布式集群中负责对其他节点的协调和管理，也就是说，其他节点都必须听从主节点的安排。</p>
<p>主节点的存在，就可以保证其他节点的有序运行，以及数据库集群中的写入数据在每个节点上的一致性。这里的一致性是指，数据在每个集群节点中都是一样的，不存在不同的情况。当然，如果主故障了，集群就会天下大乱，就好比一个国家的皇帝驾崩了，国家大乱一样。比如，数据库集群中主节点故障后，可能导致每个节点上的数据会不一致。</p>
<p>这，就应了那句话“国不可一日无君”，对应到分布式系统中就是“集群不可一刻无主”。总结来说，选举的作用就是选出一个主节点，由它来协调和管理其他节点，以保证集群有序运行和节点间数据的一致性。</p>
<h1 id="分布式选举的算法">分布式选举的算法</h1>
<p>目前常见的选主方法有基于序号选举的算法（ 比如，Bully 算法）、多数派算法（比如，Raft 算法、ZAB 算法）等。</p>
<h1 id="bully-算法">Bully 算法</h1>
<p>Bully 算法是一种集群选主算法，因为它的选举原则是“长者”为大，即在所有活着的节点中，选取 ID 最大的节点作为主节点。</p>
<p>在 Bully 算法中，节点的角色有两种：普通节点和主节点。初始化时，所有节点都是平等的，都是普通节点，并且都有成为主的权利。但是，当选主成功后，有且仅有一个节点成为主节点，其他所有节点都是普通节点。当且仅当主节点故障或与其他节点失去联系后，才会重新选主。</p>
<p>Bully 算法在选举过程中，需要用到以下 3 种消息：</p>
<pre><code>1. Election 消息，用于发起选举；
2. Alive 消息，对 Election 消息的应答；
3. Victory 消息，竞选成功的主节点向其他节点发送的宣誓主权的消息。
</code></pre>
<p>Bully 算法选举的原则是“长者为大”，意味着它的假设条件是，集群中每个节点均知道其他节点的 ID。在此前提下，其具体的选举过程是：</p>
<ol>
<li>集群中每个节点判断自己的 ID 是否为当前活着的节点中 ID 最大的，如果是，则直接向其他节点发送 Victory 消息，宣誓自己的主权；</li>
<li>如果自己不是当前活着的节点中 ID 最大的，则向比自己 ID 大的所有节点发送Election 消息，并等待其他节点的回复；</li>
<li>若在给定的时间范围内，本节点没有收到其他节点回复的 Alive 消息，则认为自己成为主节点，并向其他节点发送 Victory 消息，宣誓自己成为主节点；若接收到来自比自己ID 大的节点的 Alive 消息，则等待其他节点发送 Victory 消息；</li>
<li>若本节点收到比自己 ID 小的节点发送的 Election 消息，则回复一个 Alive 消息，告知其他节点，我比你大，重新选举。</li>
</ol>
<p>目前已经有很多开源软件采用了 Bully 算法进行选主，比如 MongoDB 的副本集故障转移功能。MongoDB 的分布式选举中，采用节点的最后操作时间戳来表示 ID，时间戳最新的节点其 ID 最大，也就是说时间戳最新的、活着的节点是主节点。</p>
<p>小结一下。Bully 算法的选择特别霸道和简单，谁活着且谁的 ID 最大谁就是主节点，其他节点必须无条件服从。这种算法的优点是，选举速度快、算法复杂度低、简单易实现。</p>
<p>但这种算法的缺点在于，需要每个节点有全局的节点信息，因此额外信息存储较多；其次，任意一个比当前主节点 ID 大的新节点或节点故障后恢复加入集群的时候，都可能会触发重新选举，成为新的主节点，如果该节点频繁退出、加入集群，就会导致频繁切主。</p>
<h1 id="raft-算法">Raft 算法</h1>
<p>Raft 算法是典型的多数派投票选举算法，其选举机制与我们日常生活中的民主投票机制类似，核心思想是“<strong>少数服从多数</strong>”。也就是说，Raft 算法中，获得投票最多的节点成为主。</p>
<p>采用 Raft 算法选举，集群节点的角色有 3 种：</p>
<pre><code>- **Leader**，即主节点，同一时刻只有一个 Leader，负责协调和管理其他节点；

- **Candidate**，即候选者，每一个节点都可以成为 Candidate，节点在该角色下才可以被

    选为新的 Leader；

- **Follower**，Leader 的跟随者，不可以发起选举。
</code></pre>
<p>Raft 选举的流程，可以分为以下几步：</p>
<ol>
<li>初始化时，所有节点均为 Follower 状态。</li>
<li>开始选主时，所有节点的状态由 Follower 转化为 Candidate，并向其他节点发送选举请求。</li>
<li>其他节点根据接收到的选举请求的先后顺序，回复是否同意成为主。这里需要注意的<br>
是，在每一轮选举中，一个节点只能投出一张票。</li>
<li>若发起选举请求的节点获得超过一半的投票，则成为主节点，其状态转化为 Leader，<br>
其他节点的状态则由 Candidate 降为 Follower。Leader 节点与 Follower 节点之间会<br>
定期发送心跳包，以检测主节点是否活着。</li>
<li>当 Leader 节点的任期到了，即发现其他服务器开始下一轮选主周期时，Leader 节点<br>
的状态由 Leader 降级为 Follower，进入新一轮选主。</li>
</ol>
<p><strong>每一轮选举，每个节点只能投一次票。</strong></p>
<p>小结一下。Raft 算法具有选举速度快、算法复杂度低、易于实现的优点；缺点是，它要求系统内每个节点都可以相互通信，且需要获得过半的投票数才能选主成功，因此通信量大。该算法选举稳定性比 Bully 算法好，这是因为当有新节点加入或节点故障恢复后，会触发选主，但不一定会真正切主，除非新节点或故障后恢复的节点获得投票数过半，才会导致切主。</p>
<h2 id="扩展">扩展</h2>
<p>两主的情况出现在集群因为网络原因，被划分了两部分局部可通信的区域。下面的链接详细讲解了Raft算法，及双主出现后集群是如何恢复的。<br>
https://www.infoq.cn/article/coreos-analyse-etcd/</p>
<p>还有一个Raft算法动画链接<br>
http://thesecretlivesofdata.com/raft/#election</p>
<p>一文搞懂Raft算法<br>
https://www.cnblogs.com/xybaby/p/10124083.html</p>
<h1 id="具有优先级的民主投票zab-算法">具有优先级的民主投票：ZAB 算法</h1>
<p>ZAB（ZooKeeper Atomic Broadcast）选举算法是为 ZooKeeper 实现分布式协调功能而设计的。相较于 Raft 算法的投票机制，ZAB 算法增加了通过节点 ID 和数据 ID 作为参考进行选主，节点 ID 和数据 ID 越大，表示数据越新，优先成为主。相比较于 Raft 算法，ZAB 算法尽可能保证数据的最新性。所以，ZAB 算法可以说是对 Raft 算法的改进。</p>
<p>使用 ZAB 算法选举时，集群中每个节点拥有 3 种角色：</p>
<pre><code>- ** Leader**，主节点；
- **Follower**，跟随者节点；
- **Observer**，观察者，无投票权。
</code></pre>
<p>选举过程中，集群中的节点拥有 4 个状态：</p>
<pre><code>- **Looking**状态，即选举状态。当节点处于该状态时，它会认为当前集群中没有 Leader，因此自己进入选举状态。
- **Leading**状态，即领导者状态，表示已经选出主，且当前节点为 Leader。
- **Following**状态，即跟随者状态，集群中已经选出主后，其他非主节点状态更新为Following，表示对 Leader 的追随。
- **Observing**状态，即观察者状态，表示当前节点为 Observer，持观望态度，没有投票权和选举权。
</code></pre>
<p>投票过程中，每个节点都有一个唯一的三元组 (server_id, server_zxID, epoch)，其中server_id 表示本节点的唯一 ID；server_zxID 表示本节点存放的数据 ID，数据 ID 越大表示数据越新，选举权重越大；epoch 表示当前选取轮数，一般用逻辑时钟表示。</p>
<p>ZAB 选举算法的核心是“少数服从多数，ID 大的节点优先成为主”，因此选举过程中通过(vote_id, vote_zxID) 来表明投票给哪个节点，其中 vote_id 表示被投票节点的 ID，vote_zxID 表示被投票节点的服务器 zxID。ZAB 算法选主的原则是：<strong>server_zxID 最大者成为 Leader；若 server_zxID 相同，则 server_id 最大者成为 Leader。</strong></p>
<p>接下来，我以 3 个 Server 的集群为例，此处每个 Server 代表一个节点，与你介绍 ZAB 选主的过程。</p>
<p>第一步：当系统刚启动时，3 个服务器当前投票均为第一轮投票，即 epoch=1，且 zxID均为 0。此时每个服务器都推选自己，并将选票信息 &lt;epoch, vote_id, vote_zxID&gt; 广播出去。</p>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1646703805954.png" alt="zab1" loading="lazy"></figure>
<p>第二步：根据判断规则，由于 3 个 Server 的 epoch、zxID 都相同，因此比较 server_id，较大者即为推选对象，因此 Server 1 和 Server 2 将 vote_id 改为 3，更新自己的投票箱并重新广播自己的投票。</p>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1646703819106.png" alt="zab2" loading="lazy"></figure>
<p>第三步：此时系统内所有服务器都推选了 Server 3，因此 Server 3 当选 Leader，处于Leading 状态，向其他服务器发送心跳包并维护连接；Server1 和 Server2 处于Following 状态。</p>
<figure data-type="image" tabindex="3"><img src="https://q456qq520.github.io/post-images/1646703831617.png" alt="zab3" loading="lazy"></figure>
<p>小结一下。ZAB 算法性能高，对系统无特殊要求，采用广播方式发送信息，若节点中有 n个节点，每个节点同时广播，则集群中信息量为 n*(n-1) 个消息，容易出现广播风暴；且除了投票，还增加了对比节点 ID 和数据 ID，这就意味着还需要知道所有节点的 ID 和数据ID，所以选举时间相对较长。但该算法选举稳定性比较好，当有新节点加入或节点故障恢复后，会触发选主，但不一定会真正切主，除非新节点或故障后恢复的节点数据 ID 和节点ID 最大，且获得投票数过半，才会导致切主。</p>
<p>#三种选举算法的对比分析</p>
<figure data-type="image" tabindex="4"><img src="https://q456qq520.github.io/post-images/1646703947766.png" alt="算法对比1" loading="lazy"></figure>
<h1 id="为什么多数派选主算法通常采用奇数节点而不是偶数节点呢">为什么“多数派”选主算法通常采用奇数节点，而不是偶数节点呢？</h1>
<p>多数派选主算法的核心是少数服从多数，获得投票多的节点胜出。想象一下，如果现在采用偶数节点集群，当两个节点均获得一半投票时，到底应该选谁为主呢？</p>
<p>答案是，在这种情况下，无法选出主，必须重新投票选举。但即使重新投票选举，两个节点拥有相同投票数的概率也会很大。因此，多数派选主算法通常采用奇数节点。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分布式互斥]]></title>
        <id>https://q456qq520.github.io/post/fen-bu-shi-hu-chi/</id>
        <link href="https://q456qq520.github.io/post/fen-bu-shi-hu-chi/">
        </link>
        <updated>2022-03-07T06:49:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="有你没我有我没你">有你没我，有我没你</h1>
<h2 id="什么是分布式互斥">什么是分布式互斥?</h2>
<p>在分布式系统里，排他性的资源访问方式，叫作分布式互斥(Distributed Mutual Exclusion)，而被互斥访问的共享资源就叫作临界资源(Critical Resource)。</p>
<p>举个例子</p>
<p>想象一下，你正在一家餐厅使用自助咖啡机泡制咖啡，突然有个人过来挪走了你的杯子，开始泡制他自己的咖啡。你耐着性子等他操作完，继续泡制自己的咖啡。结果你开始没多久，他又回来中断了你泡制咖啡的过程。相信要不了几个回合，你和他就会上演一场“有你没我，有我没你”的格斗了。这样现实的问题也同样存在于分布式世界。就像我们使用自助咖啡机时不希望被打扰一样，对于同一共享资源，一个程序正在使用的时候也不希望被其他程序打扰。这，就要求同一时刻只能有一个程序能够访问这种资源。</p>
<h2 id="集中式算法">集中式算法</h2>
<p>对于前面提到的咖啡机问题，我们首先想到的就是，增加一个“协调者”来约束大家使用自助咖啡机，解决强行插入打断别人的问题。</p>
<p>类似地，我们引入一个协调者程序，得到一个分布式互斥算法。每个程序在需要访问临界资源时，先给协调发送一个请求。如果当前没有程序使用这个资源，协调者直接授权请求程序访问;否则，按照先来后到的顺序请求程序“排一个号”。如果有程序使用完资源，则通知协调者，协调者从“排号”的队列里取出排在最前面的请求，并给它发送授权消息。拿到授权消息的程序，可以直接去访问临界资源。</p>
<p>这个互斥算法，就是我们所说的集中式算法，也可以叫做中央服务器算法。之所以这么称 呼，是因为协调者代表着集中程序或中央服务器。</p>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1646640649977.png" alt="分布式集中式算法示意图" loading="lazy"></figure>
<p>如图所示，程序 1、2、3、4 为普通运行程序，另一个程序为协调者。当程序 2 和程序 4<br>
需要使用临界资源时，它们会向协调者发起申请，请求协调者授权。不巧的是，程序 3 正在使用临界资源。这时，协调者根据程序 2 和 4 的申请时间顺序，依次将它们放入等待队列。在这个案例里，程序 4 的申请时间早于程序 2，因此排在程序 2的前面。程序 3 使用完临界资源后，通知协调者释放授权。此时，协调者从等待队列中取出程序4，并给它发放授权。这时，程序 4 就可以使用临界资源了。</p>
<p>从上述流程可以看出，<strong>一个程序完成一次临界资源访问，需要如下几个流程和消息交互</strong>：</p>
<ol>
<li>向协调者发送请求授权信息，1 次消息交互；</li>
<li>协调者向程序发放授权信息，1 次消息交互；</li>
<li>程序使用完临界资源后，向协调者发送释放授权，1 次消息交互。</li>
</ol>
<p>因此，每个程序完成一次临界资源访问，需要进行 3 次消息交互。</p>
<p>不难看出，集中式算法的优点在于直观、简单、信息交互量少、易于实现，并且所有程序只需和协调者通信，程序之间无需通信。但是，这个算法的问题也出在了协调者身上。</p>
<p>一方面，协调者会成为系统的性能瓶颈。想象一下，如果有 100 个程序要访问临界资源，那么协调者要处理 100*3=300 条消息。也就是说，协调者处理的消息数量会随着需要访问临界资源的程序数量线性增加。另一方面，容易引发单点故障问题。协调者故障，会导致所有的程序均无法访问临界资源，导致整个系统不可用。</p>
<p>因此，在使用集中式算法的时候，一定要选择性能好、可靠性高的服务器来运行协调者。</p>
<p>小结一下：集中式算法具有简单、易于实现的特点，但可用性、性能易受协调者影响。在可靠性和性能有一定保障的情况下，比如中央服务器计算能力强、性能高、故障率低，或者中央服务器进行了主备备份，主故障后备可以立马升为主，且数据可恢复的情况下，集中式算法可以适用于比较广泛的应用场景。</p>
<h2 id="民主协商分布式算法">民主协商：分布式算法</h2>
<p>既然引入协调者会带来一些问题，这时你可能就会想，不用协调者是否可以实现对临界资源的互斥访问呢？想象一下，当你需要使用自助咖啡机的时候，是不是可以先去征求其他人的意见，在确认其他人都没在使用也暂时不会使用咖啡机时，你就可以放心大胆地去泡制自己的咖啡了呢？</p>
<p>同理，我们可以把这套算法用于分布式系统。当一个程序要访问临界资源时，先向系统中的其他程序发送一条请求消息，在接收到所有程序返回的同意消息后，才可以访问临界资源。其中，请求消息需要包含所请求的资源、请求者的 ID，以及发起请求的时间</p>
<p>这，就是<strong>民主协商法。在分布式领域中，我们称之为分布式算法</strong>，或者使用组播和逻辑时钟的算法。</p>
<p>如图所示，程序 1、2、3 需要访问共享资源 A。在时间戳为 8 的时刻，程序 1 想要使用资源 A，于是向程序 2 和 3 发起使用资源 A 的申请，希望得到它们的同意。在时间戳为 12的时刻，程序 3 想要使用资源 A，于是向程序 1 和 2 发起访问资源 A 的请求。</p>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1646642012370.png" alt="分布式算法1" loading="lazy"></figure>
<p>如图所示，此时程序 2 暂时不访问资源 A，因此同意了程序 1 和 3 的资源访问请求。对于程序 3 来说，由于程序 1 提出请求的时间更早，因此同意程序 1 先使用资源，并等待程序1 返回同意消息。</p>
<figure data-type="image" tabindex="3"><img src="https://q456qq520.github.io/post-images/1646642063633.png" alt="分布式算法2" loading="lazy"></figure>
<p>如图所示，程序 1 接收到其他所有程序的同意消息之后，开始使用资源 A。当程序 1 使用完资源 A 后，释放使用权限，向请求队列中需要使用资源 A 的程序 3 发送同意使用资源的消息，并将程序 3 从请求队列中删除。此时，程序 3 收到了其他所有程序的同意消息，获得了使用资源 A 的权限，开始使用临界资源 A 的旅程。</p>
<figure data-type="image" tabindex="4"><img src="https://q456qq520.github.io/post-images/1646642086375.png" alt="分布式算法3" loading="lazy"></figure>
<p>从上述流程可以看出，一个程序完成一次临界资源的访问，需要进行如下的信息交互：</p>
<ol>
<li>向其他 n-1 个程序发送访问临界资源的请求，总共需要 n-1 次消息交互；</li>
<li>需要接收到其他 n-1 个程序回复的同意消息，方可访问资源，总共需要 n-1 次消息交互。</li>
</ol>
<p>可以看出，一个程序要成功访问临界资源，至少需要 2*(n-1) 次消息交互。假设，现在系统中的 n 个程序都要访问临界资源，则会同时产生 2n(n-1) 条消息。总结来说，在大型系统中使用分布式算法，消息数量会随着需要访问临界资源的程序数量呈指数级增加，容易导致高昂的“沟通成本”。</p>
<p>从上述分析不难看出，分布式算法根据“先到先得”以及“投票全票通过”的机制，让每个程序按时间顺序公平地访问资源，简单粗暴、易于实现。但，这个算法可用性很低，主要包括两个方面的原因：</p>
<pre><code>当系统内需要访问临界资源的程序增多时，容易产生“信令风暴”，也就是程序收到的请求完全超过了自己的处理能力，而导致自己正常的业务无法开展。

一旦某一程序发生故障，无法发送同意消息，那么其他程序均处在等待回复的状态中，使得整个系统处于停滞状态，导致整个系统不可用。所以，相对于集中式算法的协调者故障，分布式算法的可用性更低。
</code></pre>
<p>针对可用性低的一种改进办法是，如果检测到一个程序故障，则直接忽略这个程序，无需再等待它的同意消息。这就好比在自助餐厅，一个人离开餐厅了，那你在使用咖啡机前，也无需征得他的同意。但这样的话，每个程序都需要对其他程序进行故障检测，这无疑带来了更大的复杂性。</p>
<p>因此，分布式算法适合节点数目少且变动不频繁的系统，且由于每个程序均需通信交互，因此适合 P2P 结构的系统。比如，运行在局域网中的分布式文件系统，具有 P2P 结构的系统等。</p>
<h2 id="轮值-ceo令牌环算法">轮值 CEO：令牌环算法</h2>
<p>程序访问临界资源问题也可按照轮值 CEO 的思路实现。 如下图所示，所有程序构成一个环结构，令牌按照顺时针（或逆时针）方向在程序之间传递，收到令牌的程序有权访问临界资源，访问完成后将令牌传送到下一个程序；若该程序不需要访问临界资源，则直接把令牌传送给下一个程序。</p>
<p>在分布式领域，这个算法叫作令牌环算法，也可以叫作基于环的算法。</p>
<figure data-type="image" tabindex="5"><img src="https://q456qq520.github.io/post-images/1646651760528.png" alt="" loading="lazy"></figure>
<p>因为在使用临界资源前，不需要像分布式算法那样挨个征求其他程序的意见了，所以相对而言，在令牌环算法里单个程序具有更高的通信效率。同时，在一个周期内，每个程序都能访问到临界资源，因此令牌环算法的公平性很好。</p>
<p>但是，不管环中的程序是否想要访问资源，都需要接收并传递令牌，所以也会带来一些无效通信。假设系统中有 100 个程序，那么程序 1 访问完资源后，即使其它 99 个程序不需要访问，也必须要等令牌在其他 99 个程序传递完后，才能重新访问资源，这就降低了系统的实时性。</p>
<p>综上，令牌环算法非常适合通信模式为令牌环方式的分布式系统，例如移动自组织网络系统。一个典型的应用场景就是无人机通信。</p>
<p>小结一下：令牌环算法的公平性高，在改进单点故障后，稳定性也很高，适用于系统规模较小，并且系统中每个程序使用临界资源的频率高且使用时间比较短的场景。</p>
<h2 id="知识扩展有适合大规模系统中的分布式互斥算法吗">知识扩展：有适合大规模系统中的分布式互斥算法吗？</h2>
<p>可以看到，上面提到的集中式、分布式和令牌环 3 个互斥算法，都不适用于规模过大、节点数量过多的系统。那么，什么样的互斥算法适用于大规模系统呢？</p>
<p>由于大规模系统的复杂性，我们很自然地想到要用一个相对复杂的互斥算法。时下有一个很流行的互斥算法，两层结构的分布式令牌环算法，把整个广域网系统中的节点组织成两层结构，可以用于节点数量较多的系统，或者是广域网系统。</p>
<p>我们知道，广域网由多个局域网组成，因此在该算法中，局域网是较低的层次，广域网是较高的层次。每个局域网中包含若干个局部进程和一个协调进程。局部进程在逻辑上组成一个环形结构，在每个环形结构上有一个局部令牌 T 在局部进程间传递。局域网与局域网之间通过各自的协调进程进行通信，这些协调进程同样组成一个环结构，这个环就是广域网中的全局环。在这个全局环上，有一个全局令牌在多个协调进程间传递。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql中的MDL]]></title>
        <id>https://q456qq520.github.io/post/mysql-zhong-de-mdl/</id>
        <link href="https://q456qq520.github.io/post/mysql-zhong-de-mdl/">
        </link>
        <updated>2022-03-07T03:54:23.000Z</updated>
        <content type="html"><![CDATA[<p>首先简单了解一下 mysql 的 sql 类型：</p>
<p>1、数据定义语言 DDL：Create、Drop、Alter 操作。用于定义库和表结构的。</p>
<p>2、数据查询语言 DQL：select。用于查询数据的。</p>
<p>3、数据操纵语言 DML：insert、update、delete。对行记录进行增删改操作。</p>
<p>4、数据控制语言 DCL：grant、revoke、commit、rollback。控制数据库的权限和事务。</p>
<h2 id="mdl">MDL</h2>
<p>MDL（MetaData Lock）就是针对于 DDL 与 DML、DQL 操作加锁，执行 DDL 自动添加写锁，执行 DML、DQL 自动添加读锁，也就是说 DML 语句可以同时执行（不考虑其他锁），而 DDL 间则会相互阻塞。</p>
<h4 id="为什么在执行-ddl-时会添加写锁">为什么在执行 DDL 时会添加写锁</h4>
<p>DDL 在执行会先创建一个临时表，先将表的数据全部移到这个临时表中，然后再将临时表替换当前表。在这个过程中如果出现读写操作就会影响最终结果出错。这个过程耗时主要在将原表的数据移到临时表的过程。</p>
<h2 id="执行">执行</h2>
<p>不同事务的执行是按队列顺序进行的，如果两个事务所执行的 MDL 添加的分别是读、写锁，那么就会互斥，后面的事务只有等到前面事务提交释放锁后才能执行。</p>
<p>例子：假设有四个会话：session1、session2、session3、session4 ，首先先依次开启事务，然后session1，session2 先执行查询操作（为了避免可能是可串行化级别导致加的写锁冲突，所以就使用查询操作），session1，session2 中的操作可以正常执行，session3执行 Alter 修改表结构，此时 session3 的操作就会阻塞（因为 MDL 的读写锁冲突），session4 再执行增删改查也会被阻塞，因为是在队列中，它位于 session3 后面，所以只有等到 session3 提交后其才能继续执行。</p>
<h2 id="online-ddl">Online DDL</h2>
<p>可以看到执行和显示顺序是图中标注的从1开始递增按顺序执行的。可以看到 session4 在 session2 提交后就立刻会执行，并且在 session4 提交后 session3 才能执行成功，这个和前面所说的理论就会冲突。这个原因是当前 mysql 版本是5.6，而在 mysql 5.6 支持 Online DDL。</p>
<p>Online DDL 是对 MDL 的一种优化，因为如果按照 MDL 的执行逻辑，像上面这种情况，一旦一些简单的读写操作比某一条 DDL 语句启动慢一些，就会陷入阻塞，如果 DDL 修改的是大表且是高频表，那么在这条语句执行时会阻塞所有的读写操作，很容易使数据库崩溃。而 Online DDL 优化思路就是在获取到锁之后先允许一段时间的读写操作，直到临时表的数据转移完成，再停止其他读写操作，而具体实现就主要分为下面几步，</p>
<ol>
<li>
<p>拿MDL写锁</p>
</li>
<li>
<p>降级成MDL读锁，接受读写操作，读操作直接正常返回，写操作会被记录下来，等待后面更新到临时表中。</p>
</li>
<li>
<p>真正做DDL，在 DDL 表记录向临时表转移完成并执行完记录的写操作后开始阻塞读写操作。</p>
</li>
<li>
<p>升级成MDL写锁，进行临时表的替换</p>
</li>
<li>
<p>释放MDL锁</p>
</li>
</ol>
<h4 id="注意点">注意点</h4>
<ol>
<li>Online DDL 整个过程是在 InnoDB 内部执行的，对于 Server 来说并没有什么操作，所以这个操作是 &quot;inplace&quot; 的，也就是说：</li>
</ol>
<p>Online 过程一定是 inplace 的，但 inplace 过程不一定是 Online 的。</p>
<ol start="2">
<li>5.6 开始因为支持 Online DDL，所以在向临时表迁移数据时可能会积攒一些写操作造成页分裂，同时在创建新表时每个数据页还会留 1/16 的空间用于更新操作，所以执行DDL后的表结构不一定是最 &quot;紧凑&quot; 的。</li>
<li>5 .6以后 ALGORITHM=INPLACE 这个参数不会表复制</li>
<li>例子：ALTER TABLE tbl_name ADD COLUMN column_name column_definition, ALGORITHM=INPLACE, LOCK=NONE;</li>
</ol>
<h2 id="mdl-引发的问题">MDL 引发的问题</h2>
<p>在上线项目中，如果需要对某个大表的字段进行删除，那么必然会阻塞该表的所有增删改查操作，如果该表存储了热点数据，那么就会阻塞大量的操作，最终导致数据库崩溃。</p>
<p><strong>解决</strong></p>
<p>1、查看当前是否存在长事务，如果存在，先尽快将其提交，防止长事务的MDL写锁阻塞<br>
2、为 DDL 的操作设置过期时间，如果时间内没有成功执行就取消。可以使用 Github 的开源工具 gh-ost。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-online-ddl.html">MDL</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[代理模式]]></title>
        <id>https://q456qq520.github.io/post/dai-li-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/dai-li-mo-shi/">
        </link>
        <updated>2022-03-07T01:37:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="意图">意图</h2>
<p><strong>代理模式</strong>是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。</p>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/content/proxy/proxy-2x.png" alt="likecat" loading="lazy"></figure>
<h2 id="问题">问题</h2>
<p>为什么要控制对于某个对象的访问呢？ 举个例子： 有这样一个消耗大量系统资源的巨型对象， 你只是偶尔需要使用它， 并非总是需要。</p>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/proxy/problem-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>你可以实现延迟初始化： 在实际有需要时再创建该对象。 对象的所有客户端都要执行延迟初始代码。 不幸的是， 这很可能会带来很多重复代码。</p>
<p>在理想情况下， 我们希望将代码直接放入对象的类中， 但这并非总是能实现： 比如类可能是第三方封闭库的一部分。</p>
<h2 id="解决方案">解决方案</h2>
<p>代理模式建议新建一个与原服务对象接口相同的代理类， 然后更新应用以将代理对象传递给所有原始对象客户端。 代理类接收到客户端请求后会创建实际的服务对象， 并将所有工作委派给它。</p>
<figure data-type="image" tabindex="3"><img src="https://refactoringguru.cn/images/patterns/diagrams/proxy/solution-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>这有什么好处呢？ 如果需要在类的主要业务逻辑前后执行一些工作， 你无需修改类就能完成这项工作。 由于代理实现的接口与原类相同， 因此你可将其传递给任何一个使用实际服务对象的客户端。</p>
<h2 id="代理模式结构">代理模式结构</h2>
<figure data-type="image" tabindex="4"><img src="https://refactoringguru.cn/images/patterns/diagrams/proxy/structure-2x.png" alt="likecat" loading="lazy"></figure>
<ol>
<li>
<p><strong>服务接口 （Service Interface）</strong> 声明了服务接口。 代理必须遵循该接口才能伪装成服务对象。</p>
</li>
<li>
<p><strong>服务 （Service）</strong> 类提供了一些实用的业务逻辑。</p>
</li>
<li>
<p><strong>代理 （Proxy）</strong> 类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。 通常情况下， 代理会对其服务对象的整个生命周期进行管理。</p>
</li>
<li>
<p>**客户端 （Client） **能通过同一接口与服务或代理进行交互， 所以你可在一切需要服务对象的代码中使用代理。</p>
</li>
</ol>
<h2 id="代理模式适合应用场景">代理模式适合应用场景</h2>
<ol>
<li>
<p>延迟初始化 （虚拟代理）。 如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。</p>
<p>你无需在程序启动时就创建该对象， 可将对象的初始化延迟到真正有需要的时候。</p>
</li>
<li>
<p>延迟初始化 （虚拟代理）。 如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。</p>
<p>你无需在程序启动时就创建该对象， 可将对象的初始化延迟到真正有需要的时候。</p>
</li>
<li>
<p>访问控制 （保护代理）。 如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。</p>
<p>代理可仅在客户端凭据满足要求时将请求传递给服务对象。</p>
</li>
<li>
<p>本地执行远程服务 （远程代理）。 适用于服务对象位于远程服务器上的情形。</p>
<p>在这种情形中， 代理通过网络传递客户端请求， 负责处理所有与网络相关的复杂细节。</p>
</li>
<li>
<p>记录日志请求 （日志记录代理）。 适用于当你需要保存对于服务对象的请求历史记录时。 代理可以在向服务传递请求前进行记录。</p>
<p>缓存请求结果 （缓存代理）。 适用于需要缓存客户请求结果并对缓存生命周期进行管理时， 特别是当返回结果的体积非常大时。</p>
<ul>
<li>代理可对重复请求所需的相同结果进行缓存， 还可使用请求参数作为索引缓存的键值。</li>
</ul>
</li>
<li>
<p>智能引用。 可在没有客户端使用某个重量级对象时立即销毁该对象。</p>
<p>代理会将所有获取了指向服务对象或其结果的客户端记录在案。 代理会时不时地遍历各个客户端， 检查它们是否仍在运行。 如果相应的客户端列表为空， 代理就会销毁该服务对象， 释放底层系统资源。</p>
<ul>
<li>代理还可以记录客户端是否修改了服务对象。 其他客户端还可以复用未修改的对象。</li>
</ul>
</li>
</ol>
<h2 id="实现方式">实现方式</h2>
<ol>
<li>
<p>如果没有现成的服务接口， 你就需要创建一个接口来实现代理和服务对象的可交换性。 从服务类中抽取接口并非总是可行的， 因为你需要对服务的所有客户端进行修改， 让它们使用接口。 备选计划是将代理作为服务类的子类， 这样代理就能继承服务的所有接口了。</p>
</li>
<li>
<p>创建代理类， 其中必须包含一个存储指向服务的引用的成员变量。 通常情况下， 代理负责创建服务并对其整个生命周期进行管理。 在一些特殊情况下， 客户端会通过构造函数将服务传递给代理。</p>
</li>
<li>
<p>根据需求实现代理方法。 在大部分情况下， 代理在完成一些任务后应将工作委派给服务对象。</p>
</li>
<li>
<p>可以考虑新建一个构建方法来判断客户端可获取的是代理还是实际服务。 你可以在代理类中创建一个简单的静态方法， 也可以创建一个完整的工厂方法。</p>
</li>
<li>
<p>可以考虑为服务对象实现延迟初始化。</p>
</li>
</ol>
<h2 id="代理模式优缺点">代理模式优缺点</h2>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>你可以在客户端毫无察觉的情况下控制服务对象。</td>
<td style="text-align:center">代码可能会变得复杂， 因为需要新建许多类。</td>
</tr>
<tr>
<td>如果客户端对服务对象的生命周期没有特殊要求， 你可以对生命周期进行管理。</td>
<td style="text-align:center">服务响应可能会延迟。</td>
</tr>
<tr>
<td>即使服务对象还未准备好或不存在， 代理也可以正常工作。</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>开闭原则。 你可以在不对服务或客户端做出修改的情况下创建新代理。</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h2 id="与其他模式的关系">与其他模式的关系</h2>
<ol>
<li>
<p><strong>适配器模式</strong>能为被封装对象提供不同的接口， <strong>代理模式</strong>能为对象提供相同的接口， 装饰模式则能为对象提供加强的接口。</p>
</li>
<li>
<p><strong>外观模式</strong>与<strong>代理</strong>的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。</p>
</li>
<li>
<p><strong>装饰</strong>和<strong>代理</strong>有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。</p>
</li>
</ol>
<h2 id="伪代码">伪代码</h2>
<h4 id="缓存代理">缓存代理</h4>
<p>在本例中， 代理模式有助于实现延迟初始化， 并对低效的第三方 YouTube 集成程序库进行缓存。</p>
<p>当你需要在无法修改代码的类上新增一些额外行为时， 代理模式的价值无可估量。</p>
<h6 id="视频文件">视频文件</h6>
<pre><code>package com.proxy;

/**
 * 视频文件
 * @author likecat
 * @version 1.0
 * @date 2022/3/7 11:35
 */
public class Video {
    public String id;
    public String title;
    public String data;

    Video(String id, String title) {
        this.id = id;
        this.title = title;
        this.data = &quot;Random video.&quot;;
    }
}

</code></pre>
<h6 id="远程服务接口">远程服务接口</h6>
<pre><code>package com.proxy;

import java.util.HashMap;

/**
 * 远程服务接口
 * @author likecat
 * @version 1.0
 * @date 2022/3/7 11:35
 */
public interface ThirdPartyYouTubeLib {
    HashMap&lt;String, Video&gt; popularVideos();

    Video getVideo(String videoId);
}


</code></pre>
<h6 id="远程服务实现">远程服务实现</h6>
<pre><code>package com.proxy;

import java.util.HashMap;

/**
 * 远程服务实现
 * @author likecat
 * @version 1.0
 * @date 2022/3/7 11:45
 */
public class ThirdPartyYouTubeClass implements ThirdPartyYouTubeLib{
    @Override
    public HashMap&lt;String, Video&gt; popularVideos() {
        connectToServer(&quot;http://www.youtube.com&quot;);
        return getRandomVideos();
    }

    @Override
    public Video getVideo(String videoId) {
        connectToServer(&quot;http://www.youtube.com/&quot; + videoId);
        return getSomeVideo(videoId);
    }

    // -----------------------------------------------------------------------
    // Fake methods to simulate network activity. They as slow as a real life.

    private int random(int min, int max) {
        return min + (int) (Math.random() * ((max - min) + 1));
    }

    private void experienceNetworkLatency() {
        int randomLatency = random(5, 10);
        for (int i = 0; i &lt; randomLatency; i++) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
        }
    }

    private void connectToServer(String server) {
        System.out.print(&quot;Connecting to &quot; + server + &quot;... &quot;);
        experienceNetworkLatency();
        System.out.print(&quot;Connected!&quot; + &quot;\n&quot;);
    }

    private HashMap&lt;String, Video&gt; getRandomVideos() {
        System.out.print(&quot;Downloading populars... &quot;);

        experienceNetworkLatency();
        HashMap&lt;String, Video&gt; hmap = new HashMap&lt;String, Video&gt;();
        hmap.put(&quot;catzzzzzzzzz&quot;, new Video(&quot;sadgahasgdas&quot;, &quot;Catzzzz.avi&quot;));
        hmap.put(&quot;mkafksangasj&quot;, new Video(&quot;mkafksangasj&quot;, &quot;Dog play with ball.mp4&quot;));
        hmap.put(&quot;dancesvideoo&quot;, new Video(&quot;asdfas3ffasd&quot;, &quot;Dancing video.mpq&quot;));
        hmap.put(&quot;dlsdk5jfslaf&quot;, new Video(&quot;dlsdk5jfslaf&quot;, &quot;Barcelona vs RealM.mov&quot;));
        hmap.put(&quot;3sdfgsd1j333&quot;, new Video(&quot;3sdfgsd1j333&quot;, &quot;Programing lesson#1.avi&quot;));

        System.out.print(&quot;Done!&quot; + &quot;\n&quot;);
        return hmap;
    }

    private Video getSomeVideo(String videoId) {
        System.out.print(&quot;Downloading video... &quot;);

        experienceNetworkLatency();
        Video video = new Video(videoId, &quot;Some video title&quot;);

        System.out.print(&quot;Done!&quot; + &quot;\n&quot;);
        return video;
    }

}

</code></pre>
<h6 id="缓存代理-2">缓存代理</h6>
<pre><code>package com.proxy;

import java.util.HashMap;

/**
 * 缓存代理
 * @author likecat
 * @version 1.0
 * @date 2022/3/7 11:47
 */
public class YouTubeCacheProxy implements ThirdPartyYouTubeLib{
    private ThirdPartyYouTubeLib youtubeService;
    private HashMap&lt;String, Video&gt; cachePopular = new HashMap&lt;String, Video&gt;();
    private HashMap&lt;String, Video&gt; cacheAll = new HashMap&lt;String, Video&gt;();

    public YouTubeCacheProxy() {
        this.youtubeService = new ThirdPartyYouTubeClass();
    }

    @Override
    public HashMap&lt;String, Video&gt; popularVideos() {
        if (cachePopular.isEmpty()) {
            cachePopular = youtubeService.popularVideos();
        } else {
            System.out.println(&quot;Retrieved list from cache.&quot;);
        }
        return cachePopular;
    }

    @Override
    public Video getVideo(String videoId) {
        Video video = cacheAll.get(videoId);
        if (video == null) {
            video = youtubeService.getVideo(videoId);
            cacheAll.put(videoId, video);
        } else {
            System.out.println(&quot;Retrieved video '&quot; + videoId + &quot;' from cache.&quot;);
        }
        return video;
    }

    public void reset() {
        cachePopular.clear();
        cacheAll.clear();
    }
}

</code></pre>
<h6 id="媒体下载应用">媒体下载应用</h6>
<pre><code>package com.proxy;

import java.util.HashMap;

/**
 * 媒体下载应用
 * @author likecat
 * @version 1.0
 * @date 2022/3/7 11:49
 */
public class YouTubeDownloader {
    private ThirdPartyYouTubeLib api;

    public YouTubeDownloader(ThirdPartyYouTubeLib api) {
        this.api = api;
    }

    public void renderVideoPage(String videoId) {
        Video video = api.getVideo(videoId);
        System.out.println(&quot;\n-------------------------------&quot;);
        System.out.println(&quot;Video page (imagine fancy HTML)&quot;);
        System.out.println(&quot;ID: &quot; + video.id);
        System.out.println(&quot;Title: &quot; + video.title);
        System.out.println(&quot;Video: &quot; + video.data);
        System.out.println(&quot;-------------------------------\n&quot;);
    }

    public void renderPopularVideos() {
        HashMap&lt;String, Video&gt; list = api.popularVideos();
        System.out.println(&quot;\n-------------------------------&quot;);
        System.out.println(&quot;Most popular videos on YouTube (imagine fancy HTML)&quot;);
        for (Video video : list.values()) {
            System.out.println(&quot;ID: &quot; + video.id + &quot; / Title: &quot; + video.title);
        }
        System.out.println(&quot;-------------------------------\n&quot;);
    }
}

</code></pre>
<p>######## 客户端代码</p>
<pre><code>package com.proxy;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/7 11:50
 */
public class Demo {
    public static void main(String[] args) {
        YouTubeDownloader naiveDownloader = new YouTubeDownloader(new ThirdPartyYouTubeClass());
        YouTubeDownloader smartDownloader = new YouTubeDownloader(new YouTubeCacheProxy());

        long naive = test(naiveDownloader);
        long smart = test(smartDownloader);
        System.out.print(&quot;Time saved by caching proxy: &quot; + (naive - smart) + &quot;ms&quot;);

    }

    private static long test(YouTubeDownloader downloader) {
        long startTime = System.currentTimeMillis();

        // User behavior in our app:
        downloader.renderPopularVideos();
        downloader.renderVideoPage(&quot;catzzzzzzzzz&quot;);
        downloader.renderPopularVideos();
        downloader.renderVideoPage(&quot;dancesvideoo&quot;);
        // Users might visit the same page quite often.
        downloader.renderVideoPage(&quot;catzzzzzzzzz&quot;);
        downloader.renderVideoPage(&quot;someothervid&quot;);

        long estimatedTime = System.currentTimeMillis() - startTime;
        System.out.print(&quot;Time elapsed: &quot; + estimatedTime + &quot;ms\n&quot;);
        return estimatedTime;
    }
}

</code></pre>
<h6 id="执行结果">执行结果</h6>
<pre><code>Connecting to http://www.youtube.com... Connected!
Downloading populars... Done!

-------------------------------
Most popular videos on YouTube (imagine fancy HTML)
ID: sadgahasgdas / Title: Catzzzz.avi
ID: asdfas3ffasd / Title: Dancing video.mpq
ID: 3sdfgsd1j333 / Title: Programing lesson#1.avi
ID: mkafksangasj / Title: Dog play with ball.mp4
ID: dlsdk5jfslaf / Title: Barcelona vs RealM.mov
-------------------------------

Connecting to http://www.youtube.com/catzzzzzzzzz... Connected!
Downloading video... Done!

-------------------------------
Video page (imagine fancy HTML)
ID: catzzzzzzzzz
Title: Some video title
Video: Random video.
-------------------------------

Connecting to http://www.youtube.com... Connected!
Downloading populars... Done!

-------------------------------
Most popular videos on YouTube (imagine fancy HTML)
ID: sadgahasgdas / Title: Catzzzz.avi
ID: asdfas3ffasd / Title: Dancing video.mpq
ID: 3sdfgsd1j333 / Title: Programing lesson#1.avi
ID: mkafksangasj / Title: Dog play with ball.mp4
ID: dlsdk5jfslaf / Title: Barcelona vs RealM.mov
-------------------------------

Connecting to http://www.youtube.com/dancesvideoo... Connected!
Downloading video... Done!

-------------------------------
Video page (imagine fancy HTML)
ID: dancesvideoo
Title: Some video title
Video: Random video.
-------------------------------

Connecting to http://www.youtube.com/catzzzzzzzzz... Connected!
Downloading video... Done!

-------------------------------
Video page (imagine fancy HTML)
ID: catzzzzzzzzz
Title: Some video title
Video: Random video.
-------------------------------

Connecting to http://www.youtube.com/someothervid... Connected!
Downloading video... Done!

-------------------------------
Video page (imagine fancy HTML)
ID: someothervid
Title: Some video title
Video: Random video.
-------------------------------

Time elapsed: 9354ms
Connecting to http://www.youtube.com... Connected!
Downloading populars... Done!

-------------------------------
Most popular videos on YouTube (imagine fancy HTML)
ID: sadgahasgdas / Title: Catzzzz.avi
ID: asdfas3ffasd / Title: Dancing video.mpq
ID: 3sdfgsd1j333 / Title: Programing lesson#1.avi
ID: mkafksangasj / Title: Dog play with ball.mp4
ID: dlsdk5jfslaf / Title: Barcelona vs RealM.mov
-------------------------------

Connecting to http://www.youtube.com/catzzzzzzzzz... Connected!
Downloading video... Done!

-------------------------------
Video page (imagine fancy HTML)
ID: catzzzzzzzzz
Title: Some video title
Video: Random video.
-------------------------------

Retrieved list from cache.

-------------------------------
Most popular videos on YouTube (imagine fancy HTML)
ID: sadgahasgdas / Title: Catzzzz.avi
ID: asdfas3ffasd / Title: Dancing video.mpq
ID: 3sdfgsd1j333 / Title: Programing lesson#1.avi
ID: mkafksangasj / Title: Dog play with ball.mp4
ID: dlsdk5jfslaf / Title: Barcelona vs RealM.mov
-------------------------------

Connecting to http://www.youtube.com/dancesvideoo... Connected!
Downloading video... Done!

-------------------------------
Video page (imagine fancy HTML)
ID: dancesvideoo
Title: Some video title
Video: Random video.
-------------------------------

Retrieved video 'catzzzzzzzzz' from cache.

-------------------------------
Video page (imagine fancy HTML)
ID: catzzzzzzzzz
Title: Some video title
Video: Random video.
-------------------------------

Connecting to http://www.youtube.com/someothervid... Connected!
Downloading video... Done!

-------------------------------
Video page (imagine fancy HTML)
ID: someothervid
Title: Some video title
Video: Random video.
-------------------------------

Time elapsed: 5875ms
Time saved by caching proxy: 3479ms
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[亨元模式]]></title>
        <id>https://q456qq520.github.io/post/heng-yuan-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/heng-yuan-mo-shi/">
        </link>
        <updated>2022-02-25T09:08:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="意图">意图</h2>
<p><strong>享元模式</strong>是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。</p>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/content/flyweight/flyweight-zh-2x.png" alt="likecat" loading="lazy"></figure>
<h2 id="问题">问题</h2>
<p>假如你希望在长时间工作后放松一下， 所以开发了一款简单的游戏： 玩家们在地图上移动并相互射击。 你决定实现一个真实的粒子系统， 并将其作为游戏的特色。 大量的子弹、 导弹和爆炸弹片会在整个地图上穿行， 为玩家提供紧张刺激的游戏体验。</p>
<p>开发完成后， 你推送提交了最新版本的程序， 并在编译游戏后将其发送给了一个朋友进行测试。 尽管该游戏在你的电脑上完美运行， 但是你的朋友却无法长时间进行游戏： 游戏总是会在他的电脑上运行几分钟后崩溃。 在研究了几个小时的调试消息记录后， 你发现导致游戏崩溃的原因是内存容量不足。 朋友的设备性能远比不上你的电脑， 因此游戏运行在他的电脑上时很快就会出现问题。</p>
<p>真正的问题与粒子系统有关。 每个粒子 （一颗子弹、 一枚导弹或一块弹片） 都由包含完整数据的独立对象来表示。 当玩家在游戏中鏖战进入高潮后的某一时刻， 游戏将无法在剩余内存中载入新建粒子， 于是程序就崩溃了。</p>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/flyweight/problem-zh-2x.png" alt="likecat" loading="lazy"></figure>
<h2 id="解决方案">解决方案</h2>
<p>仔细观察 粒子Particle类， 你可能会注意到颜色 （color） 和精灵图 （sprite）这两个成员变量所消耗的内存要比其他变量多得多。 更糟糕的是， 对于所有的粒子来说， 这两个成员变量所存储的数据几乎完全一样 （比如所有子弹的颜色和精灵图都一样）。</p>
<figure data-type="image" tabindex="3"><img src="https://refactoringguru.cn/images/patterns/diagrams/flyweight/solution1-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>每个粒子的另一些状态 （坐标、 移动矢量和速度） 则是不同的。 因为这些成员变量的数值会不断变化。 这些数据代表粒子在存续期间不断变化的情景， 但每个粒子的颜色和精灵图则会保持不变。</p>
<p>对象的常量数据通常被称为内在状态， 其位于对象中， 其他对象只能读取但不能修改其数值。 而对象的其他状态常常能被其他对象 “从外部” 改变， 因此被称为外在状态。</p>
<p>享元模式建议不在对象中存储外在状态， 而是将其传递给依赖于它的一个特殊方法。 程序只在对象中保存内在状态， 以方便在不同情景下重用。 这些对象的区别仅在于其内在状态 （与外在状态相比， 内在状态的变体要少很多）， 因此你所需的对象数量会大大削减。</p>
<figure data-type="image" tabindex="4"><img src="https://refactoringguru.cn/images/patterns/diagrams/flyweight/solution3-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>让我们回到游戏中。 假如能从粒子类中抽出外在状态， 那么我们只需三个不同的对象 （子弹、 导弹和弹片） 就能表示游戏中的所有粒子。 你现在很可能已经猜到了， 我们将这样一个仅存储内在状态的对象称为享元。</p>
<h4 id="外在状态存储">外在状态存储</h4>
<p>那么外在状态会被移动到什么地方呢？ 总得有类来存储它们， 对不对？ 在大部分情况中， 它们会被移动到容器对象中， 也就是我们应用享元模式前的聚合对象中。</p>
<p>在我们的例子中， 容器对象就是主要的 游戏Game对象， 其会将所有粒子存储在名为 粒子particles的成员变量中。 为了能将外在状态移动到这个类中， 你需要创建多个数组成员变量来存储每个粒子的坐标、 方向矢量和速度。 除此之外， 你还需要另一个数组来存储指向代表粒子的特定享元的引用。 这些数组必须保持同步， 这样你才能够使用同一索引来获取关于某个粒子的所有数据。</p>
<figure data-type="image" tabindex="5"><img src="https://refactoringguru.cn/images/patterns/diagrams/flyweight/solution2-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>更优雅的解决方案是创建独立的情景类来存储外在状态和对享元对象的引用。 在该方法中， 容器类只需包含一个数组。</p>
<p>稍等！ 这样的话情景对象数量不是会和不采用该模式时的对象数量一样多吗？ 的确如此， 但这些对象要比之前小很多。 消耗内存最多的成员变量已经被移动到很少的几个享元对象中了。 现在， 一个享元大对象会被上千个情境小对象复用， 因此无需再重复存储数千个大对象的数据。</p>
<h4 id="享元与不可变性">享元与不可变性</h4>
<p>由于享元对象可在不同的情景中使用， 你必须确保其状态不能被修改。 享元类的状态只能由构造函数的参数进行一次性初始化， 它不能对其他对象公开其设置器或公有成员变量。</p>
<h4 id="享元工厂">享元工厂</h4>
<p>为了能更方便地访问各种享元， 你可以创建一个工厂方法来管理已有享元对象的缓存池。 工厂方法从客户端处接收目标享元对象的内在状态作为参数， 如果它能在缓存池中找到所需享元， 则将其返回给客户端； 如果没有找到， 它就会新建一个享元， 并将其添加到缓存池中。</p>
<p>你可以选择在程序的不同地方放入该函数。 最简单的选择就是将其放置在享元容器中。 除此之外， 你还可以新建一个工厂类， 或者创建一个静态的工厂方法并将其放入实际的享元类中。</p>
<h2 id="享元模式结构">享元模式结构</h2>
<figure data-type="image" tabindex="6"><img src="https://refactoringguru.cn/images/patterns/diagrams/flyweight/structure-2x.png" alt="likecat" loading="lazy"></figure>
<ol>
<li>
<p>享元模式只是一种优化。 在应用该模式之前， 你要确定程序中存在与大量类似对象同时占用内存相关的内存消耗问题， 并且确保该问题无法使用其他更好的方式来解决。</p>
</li>
<li>
<p><strong>享元 （Flyweight</strong>） 类包含原始对象中部分能在多个对象中共享的状态。 同一享元对象可在许多不同情景中使用。 享元中存储的状态被称为 “内在状态”。 传递给享元方法的状态被称为 “外在状态”。</p>
</li>
<li>
<p>**情景 （Context） **类包含原始对象中各不相同的外在状态。 情景与享元对象组合在一起就能表示原始对象的全部状态。</p>
</li>
<li>
<p>通常情况下， 原始对象的行为会保留在享元类中。 因此调用享元方法必须提供部分外在状态作为参数。 但你也可将行为移动到情景类中， 然后将连入的享元作为单纯的数据对象。</p>
</li>
<li>
<p><strong>客户端 （Client）</strong> 负责计算或存储享元的外在状态。 在客户端看来， 享元是一种可在运行时进行配置的模板对象， 具体的配置方式为向其方法中传入一些情景数据参数。</p>
</li>
<li>
<p><strong>享元工厂 （Flyweight Factory）</strong> 会对已有享元的缓存池进行管理。 有了工厂后， 客户端就无需直接创建享元， 它们只需调用工厂并向其传递目标享元的一些内在状态即可。 工厂会根据参数在之前已创建的享元中进行查找， 如果找到满足条件的享元就将其返回； 如果没有找到就根据参数新建享元。</p>
</li>
</ol>
<h2 id="伪代码">伪代码</h2>
<h4 id="渲染一片森林">渲染一片森林</h4>
<p>本例中， 我们将渲染一片森林 （1,000,000 棵树）！ 每棵树都由包含一些状态的对象来表示 （坐标和纹理等）。 尽管程序能够完成其主要工作， 但很显然它需要消耗大量内存。</p>
<p>原因很简单： 太多树对象包含重复数据 （名称、 纹理和颜色）。 因此我们可用享元模式来将这些数值存储在单独的享元对象中 （ Tree­Type类）。 现在我们不再将相同数据存储在数千个 Tree对象中， 而是使用一组特殊的数值来引用其中一个享元对象。</p>
<p>客户端代码不会知道任何事情， 因为重用享元对象的复杂机制隐藏在了享元工厂中。</p>
<p>包含每棵树的独特状态</p>
<pre><code>package com.hengyuan;

import java.awt.*;

/**
 * 包含每棵树的独特状态
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 17:39
 */
public class Tree {
    private int x;
    private int y;
    private TreeType type;

    public Tree(int x, int y, TreeType type) {
        this.x = x;
        this.y = y;
        this.type = type;
    }

    public void draw(Graphics g) {
        type.draw(g, x, y);
    }
}

</code></pre>
<p>包含多棵树共享的状态</p>
<pre><code>package com.hengyuan;

import java.awt.*;

/**
 * 包含多棵树共享的状态
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 17:39
 */
public class TreeType {
    private String name;
    private Color color;
    private String otherTreeData;

    public TreeType(String name, Color color, String otherTreeData) {
        this.name = name;
        this.color = color;
        this.otherTreeData = otherTreeData;
    }

    public void draw(Graphics g, int x, int y) {
        g.setColor(Color.BLACK);
        g.fillRect(x - 1, y, 3, 5);
        g.setColor(color);
        g.fillOval(x - 5, y - 10, 10, 10);
    }
}


</code></pre>
<p>封装创建享元的复杂机制</p>
<pre><code>package com.hengyuan;

import java.awt.*;
import java.util.HashMap;
import java.util.Map;

/**
 * 封装创建享元的复杂机制
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 17:40
 */
public class TreeFactory {

    static Map&lt;String, TreeType&gt; treeTypes = new HashMap&lt;&gt;();

    public static TreeType getTreeType(String name, Color color, String otherTreeData) {
        TreeType result = treeTypes.get(name);
        if (result == null) {
            result = new TreeType(name, color, otherTreeData);
            treeTypes.put(name, result);
        }
        return result;
    }
}


</code></pre>
<p>我们绘制的森林</p>
<pre><code>package com.hengyuan;

import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;

/**
 * 我们绘制的森林
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 17:41
 */
public class Forest extends JFrame {
    private List&lt;Tree&gt; trees = new ArrayList&lt;&gt;();

    public void plantTree(int x, int y, String name, Color color, String otherTreeData) {
        TreeType type = TreeFactory.getTreeType(name, color, otherTreeData);
        Tree tree = new Tree(x, y, type);
        trees.add(tree);
    }

    @Override
    public void paint(Graphics graphics) {
        for (Tree tree : trees) {
            tree.draw(graphics);
        }
    }
}



</code></pre>
<p>客户端代码</p>
<pre><code>package com.hengyuan;

import java.awt.*;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 17:42
 */
public class Demo {
    static int CANVAS_SIZE = 500;
    static int TREES_TO_DRAW = 1000000;
    static int TREE_TYPES = 2;

    public static void main(String[] args) {
        Forest forest = new Forest();
        for (int i = 0; i &lt; Math.floor(TREES_TO_DRAW / TREE_TYPES); i++) {
            forest.plantTree(random(0, CANVAS_SIZE), random(0, CANVAS_SIZE),
                    &quot;Summer Oak&quot;, Color.GREEN, &quot;Oak texture stub&quot;);
            forest.plantTree(random(0, CANVAS_SIZE), random(0, CANVAS_SIZE),
                    &quot;Autumn Oak&quot;, Color.ORANGE, &quot;Autumn Oak texture stub&quot;);
        }
        forest.setSize(CANVAS_SIZE, CANVAS_SIZE);
        forest.setVisible(true);

        System.out.println(TREES_TO_DRAW + &quot; trees drawn&quot;);
        System.out.println(&quot;---------------------&quot;);
        System.out.println(&quot;Memory usage:&quot;);
        System.out.println(&quot;Tree size (8 bytes) * &quot; + TREES_TO_DRAW);
        System.out.println(&quot;+ TreeTypes size (~30 bytes) * &quot; + TREE_TYPES + &quot;&quot;);
        System.out.println(&quot;---------------------&quot;);
        System.out.println(&quot;Total: &quot; + ((TREES_TO_DRAW * 8 + TREE_TYPES * 30) / 1024 / 1024) +
                &quot;MB (instead of &quot; + ((TREES_TO_DRAW * 38) / 1024 / 1024) + &quot;MB)&quot;);
    }

    private static int random(int min, int max) {
        return min + (int) (Math.random() * ((max - min) + 1));
    }
}


</code></pre>
<p>执行结果<br>
<img src="https://refactoringguru.cn/images/patterns/examples/java/flyweight/OutputDemo.png%22%22" alt="likecat" loading="lazy"></p>
<p>内存使用统计</p>
<pre><code>1000000 trees drawn
---------------------
Memory usage:
Tree size (8 bytes) * 1000000
+ TreeTypes size (~30 bytes) * 2
---------------------
Total: 7MB (instead of 36MB)
</code></pre>
<h2 id="亨元模式适合应用场景">亨元模式适合应用场景</h2>
<ol>
<li>
<p>仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。</p>
<p>应用该模式所获的收益大小取决于使用它的方式和情景。 它在下列情况中最有效：</p>
<ul>
<li>程序需要生成数量巨大的相似对象</li>
<li>这将耗尽目标设备的所有内存</li>
<li>对象中包含可抽取且能在多个对象间共享的重复状态。</li>
</ul>
</li>
</ol>
<h2 id="实现方式">实现方式</h2>
<ol>
<li>
<p>将需要改写为享元的类成员变量拆分为两个部分：</p>
<ul>
<li>内在状态： 包含不变的、 可在许多对象中重复使用的数据的成员变量。</li>
<li>外在状态： 包含每个对象各自不同的情景数据的成员变量</li>
</ul>
</li>
<li>
<p>保留类中表示内在状态的成员变量， 并将其属性设置为不可修改。 这些变量仅可在构造函数中获得初始数值。</p>
</li>
<li>
<p>找到所有使用外在状态成员变量的方法， 为在方法中所用的每个成员变量新建一个参数， 并使用该参数代替成员变量。</p>
</li>
<li>
<p>你可以有选择地创建工厂类来管理享元缓存池， 它负责在新建享元时检查已有的享元。 如果选择使用工厂， 客户端就只能通过工厂来请求享元， 它们需要将享元的内在状态作为参数传递给工厂。</p>
</li>
<li>
<p>客户端必须存储和计算外在状态 （情景） 的数值， 因为只有这样才能调用享元对象的方法。 为了使用方便， 外在状态和引用享元的成员变量可以移动到单独的情景类中。</p>
</li>
</ol>
<h2 id="享元模式优缺点">享元模式优缺点</h2>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>如果程序中有很多相似对象， 那么你将可以节省大量内存。</td>
<td style="text-align:center">你可能需要牺牲执行速度来换取内存， 因为他人每次调用享元方法时都需要重新计算部分情景数据。</td>
</tr>
<tr>
<td>-</td>
<td style="text-align:center">代码会变得更加复杂。 团队中的新成员总是会问： ​ “为什么要像这样拆分一个实体的状态？”。</td>
</tr>
</tbody>
</table>
<h2 id="与其他模式的关系">与其他模式的关系</h2>
<ol>
<li>
<p>你可以使用<strong>享元模式</strong>实现<strong>组合模式</strong>树的共享叶节点以节省内存。</p>
</li>
<li>
<p><strong>享元</strong>展示了如何生成大量的小型对象， 外观模式则展示了如何用一个对象来代表整个子系统。</p>
</li>
<li>
<p>如果你能将对象的所有共享状态简化为一个享元对象， 那么<strong>享元</strong>就和<strong>单例模式</strong>类似了。 但这两个模式有两个根本性的不同。</p>
<p>只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。</p>
<p>单例对象可以是可变的。 享元对象是不可变的。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[外观模式]]></title>
        <id>https://q456qq520.github.io/post/wai-guan-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/wai-guan-mo-shi/">
        </link>
        <updated>2022-02-25T07:49:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="意图">意图</h2>
<p><strong>外观模式</strong>是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。</p>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/content/facade/facade-2x.png" alt="likecat" loading="lazy"></figure>
<h2 id="问题">问题</h2>
<p>假设你必须在代码中使用某个复杂的库或框架中的众多对象。 正常情况下， 你需要负责所有对象的初始化工作、 管理其依赖关系并按正确的顺序执行方法等。</p>
<p>最终， 程序中类的业务逻辑将与第三方类的实现细节紧密耦合， 使得理解和维护代码的工作很难进行。</p>
<h2 id="解决方案">解决方案</h2>
<p>外观类为包含许多活动部件的复杂子系统提供一个简单的接口。 与直接调用子系统相比， 外观提供的功能可能比较有限， 但它却包含了客户端真正关心的功能。</p>
<p>如果你的程序需要与包含几十种功能的复杂库整合， 但只需使用其中非常少的功能， 那么使用外观模式会非常方便，</p>
<p>例如， 上传猫咪搞笑短视频到社交媒体网站的应用可能会用到专业的视频转换库， 但它只需使用一个包含 encode­(filename, format)方法 （以文件名与文件格式为参数进行编码的方法） 的类即可。 在创建这个类并将其连接到视频转换库后， 你就拥有了自己的第一个外观。</p>
<h2 id="外观模式结构">外观模式结构</h2>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/facade/structure-2x.png" alt="likecat" loading="lazy"></figure>
<ol>
<li>
<p><strong>外观 （Facade）</strong> 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。</p>
</li>
<li>
<p>创建<strong>附加外观 （Additional Facade）</strong> 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。</p>
</li>
<li>
<p><strong>复杂子系统 （Complex Subsystem）</strong> 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。</p>
<p>子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。</p>
</li>
<li>
<p><strong>客户端 （Client）</strong> 使用外观代替对子系统对象的直接调用</p>
</li>
</ol>
<h2 id="伪代码">伪代码</h2>
<p>复杂视频转换库的简单接口</p>
<p>在本例中， 外观简化了复杂视频转换框架所进行的沟通工作。</p>
<p>外观提供了仅包含一个方法的类， 可用于处理对框架中所需类的配置与以正确格式获取结果的复杂工作。</p>
<p>复杂视频转换程序库</p>
<p>VideoFile</p>
<pre><code>package com.exterior;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:03
 */
public class VideoFile {
    private String name;
    private String codecType;

    public VideoFile(String name) {
        this.name = name;
        this.codecType = name.substring(name.indexOf(&quot;.&quot;) + 1);
    }

    public String getCodecType() {
        return codecType;
    }

    public String getName() {
        return name;
    }
}

</code></pre>
<p>Codec</p>
<pre><code>package com.exterior;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:05
 */
public interface Codec {
}

</code></pre>
<p>MPEG4CompressionCodec</p>
<pre><code>package com.exterior;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:06
 */
public class MPEG4CompressionCodec implements Codec{
    public String type = &quot;mp4&quot;;
}

</code></pre>
<p>OggCompressionCodec</p>
<pre><code>package com.exterior;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:06
 */
public class OggCompressionCodec implements Codec{
    public String type = &quot;ogg&quot;;
}


</code></pre>
<p>CodecFactory</p>
<pre><code>package com.exterior;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:07
 */
public class CodecFactory {
    public static Codec extract(VideoFile file) {
        String type = file.getCodecType();
        if (type.equals(&quot;mp4&quot;)) {
            System.out.println(&quot;CodecFactory: extracting mpeg audio...&quot;);
            return new MPEG4CompressionCodec();
        }
        else {
            System.out.println(&quot;CodecFactory: extracting ogg audio...&quot;);
            return new OggCompressionCodec();
        }
    }
}


</code></pre>
<p>BitrateReader</p>
<pre><code>package com.exterior;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:08
 */
public class BitrateReader {
    public static VideoFile read(VideoFile file, Codec codec) {
        System.out.println(&quot;BitrateReader: reading file...&quot;);
        return file;
    }

    public static VideoFile convert(VideoFile buffer, Codec codec) {
        System.out.println(&quot;BitrateReader: writing file...&quot;);
        return buffer;
    }
}
   
</code></pre>
<p>AudioMixer</p>
<pre><code>package com.exterior;

import java.io.File;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:09
 */
public class AudioMixer {
    public File fix(VideoFile result){
        System.out.println(&quot;AudioMixer: fixing audio...&quot;);
        return new File(&quot;tmp&quot;);
    }
}

</code></pre>
<p>VideoConversionFacade.java: 外观提供了进行视频转换的简单接口</p>
<pre><code>package com.exterior;

import java.io.File;

/**
 * 外观提供了进行视频转换的简单接口
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:10
 */
public class VideoConversionFacade {
    public File convertVideo(String fileName, String format) {
        System.out.println(&quot;VideoConversionFacade: conversion started.&quot;);
        VideoFile file = new VideoFile(fileName);
        Codec sourceCodec = CodecFactory.extract(file);
        Codec destinationCodec;
        if (format.equals(&quot;mp4&quot;)) {
            destinationCodec = new MPEG4CompressionCodec();
        } else {
            destinationCodec = new OggCompressionCodec();
        }
        VideoFile buffer = BitrateReader.read(file, sourceCodec);
        VideoFile intermediateResult = BitrateReader.convert(buffer, destinationCodec);
        File result = (new AudioMixer()).fix(intermediateResult);
        System.out.println(&quot;VideoConversionFacade: conversion completed.&quot;);
        return result;
    }
}

</code></pre>
<p>客户端代码</p>
<pre><code>package com.exterior;

import java.io.File;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:11
 */
public class Demo {
    public static void main(String[] args) {
        VideoConversionFacade converter = new VideoConversionFacade();
        File mp4Video = converter.convertVideo(&quot;youtubevideo.ogg&quot;, &quot;mp4&quot;);
        // ...
    }
}

</code></pre>
<p>执行结果</p>
<pre><code>VideoConversionFacade: conversion started.
CodecFactory: extracting ogg audio...
BitrateReader: reading file...
BitrateReader: writing file...
AudioMixer: fixing audio...
VideoConversionFacade: conversion completed.
</code></pre>
<h2 id="外观模式适合应用场景">外观模式适合应用场景</h2>
<ol>
<li>
<p>如果你需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。<br>
子系统通常会随着时间的推进变得越来越复杂。 即便是应用了设计模式， 通常你也会创建更多的类。 尽管在多种情形中子系统可能是更灵活或易于复用的， 但其所需的配置和样板代码数量将会增长得更快。 为了解决这个问题， 外观将会提供指向子系统中最常用功能的快捷方式， 能够满足客户端的大部分需求。</p>
</li>
<li>
<p>如果需要将子系统组织为多层结构， 可以使用外观。<br>
创建外观来定义子系统中各层次的入口。 你可以要求子系统仅使用外观来进行交互， 以减少子系统之间的耦合。</p>
<p>让我们回到视频转换框架的例子。 该框架可以拆分为两个层次： 音频相关和视频相关。 你可以为每个层次创建一个外观， 然后要求各层的类必须通过这些外观进行交互。 这种方式看上去与<strong>中介者模式</strong>非常相似。</p>
</li>
</ol>
<h2 id="实现方式">实现方式</h2>
<ol>
<li>
<p>考虑能否在现有子系统的基础上提供一个更简单的接口。 如果该接口能让客户端代码独立于众多子系统类， 那么你的方向就是正确的。</p>
</li>
<li>
<p>在一个新的外观类中声明并实现该接口。 外观应将客户端代码的调用重定向到子系统中的相应对象处。 如果客户端代码没有对子系统进行初始化， 也没有对其后续生命周期进行管理， 那么外观必须完成此类工作。</p>
</li>
<li>
<p>如果要充分发挥这一模式的优势， 你必须确保所有客户端代码仅通过外观来与子系统进行交互。 此后客户端代码将不会受到任何由子系统代码修改而造成的影响， 比如子系统升级后， 你只需修改外观中的代码即可。</p>
</li>
<li>
<p>如果外观变得过于臃肿， 你可以考虑将其部分行为抽取为一个新的专用外观类。</p>
</li>
</ol>
<h2 id="外观模式优缺点">外观模式优缺点</h2>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>你可以让自己的代码独立于复杂子系统。</td>
<td style="text-align:center">外观可能成为与程序中所有类都耦合的上帝对象。</td>
</tr>
</tbody>
</table>
<h2 id="与其他模式的关系">与其他模式的关系</h2>
<ol>
<li>
<p><strong>外观模式</strong>为现有对象定义了一个新接口， <strong>适配器模式</strong>则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。</p>
</li>
<li>
<p>当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用<strong>抽象工厂模式</strong>来代替外观。</p>
</li>
<li>
<p><strong>享元模式</strong>展示了如何生成大量的小型对象， 外观则展示了如何用一个对象来代表整个子系统。</p>
</li>
<li>
<p><strong>外观</strong>和<strong>中介者模式</strong>的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。</p>
<p>外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。</p>
<p>中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。</p>
</li>
<li>
<p><strong>外观类</strong>通常可以转换为<strong>单例模式类</strong>， 因为在大部分情况下一个外观对象就足够了。</p>
</li>
<li>
<p><strong>外观</strong>与<strong>代理模式</strong>的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《人人都是产品经理》]]></title>
        <id>https://q456qq520.github.io/post/lesslessren-ren-du-shi-chan-pin-jing-li-greatergreater/</id>
        <link href="https://q456qq520.github.io/post/lesslessren-ren-du-shi-chan-pin-jing-li-greatergreater/">
        </link>
        <updated>2022-02-25T06:33:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="好产品能改变世界">好产品能改变世界</h1>
<h1 id="一-什么是产品经理">一 什么是产品经理</h1>
<p>1 什么是产品</p>
<p>百度百科：<br>
产品是一组将输入转化为输出的相互关联或相互作用的活动”的结果，即“过程”的结果。在经济领域中，通常也可理解为组织制造的任何制品或制品的组合。产品的狭义概念：被生产出的物品；产品的广义概念：可以满足人们需求的载体。</p>
<p>也即：产品是用来解决某个问题的具体物质</p>
<p>2 为什么要有产品经理</p>
<p>产品经理的出现是为了适应公司发展的需要。随着企业越来越大，产品越来越多，越来越复杂，原来按职能划分部门的组织结构已经无法适应，所以出现了产品管理的矩阵型组织。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis数据类型-GEO]]></title>
        <id>https://q456qq520.github.io/post/redis-shu-ju-lei-xing-geo/</id>
        <link href="https://q456qq520.github.io/post/redis-shu-ju-lei-xing-geo/">
        </link>
        <updated>2022-02-21T09:33:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="面向lbs应用的geo数据类型">面向LBS应用的GEO数据类型</h2>
<p>在日常生活中，我们越来越依赖搜索“附近的餐馆”、在打车软件上叫车，这些都离不开基于位置信息服务（Location-Based Service，LBS）的应用。LBS应用访问的数据是和人或物关联的一组经纬度信息，而且要能查询相邻的经纬度范围，GEO就非常适合应用在LBS服务的场景中，我们来看一下它的底层结构。</p>
<h2 id="geo的底层结构">GEO的底层结构</h2>
<p>一般来说，在设计一个数据类型的底层结构时，我们首先需要知道，要处理的数据有什么访问特点。所以，我们需要先搞清楚位置信息到底是怎么被存取的。</p>
<p>我以叫车服务为例，来分析下LBS应用中经纬度的存取特点。</p>
<ol>
<li>每一辆网约车都有一个编号（例如33），网约车需要将自己的经度信息（例如116.034579）和纬度信息（例如39.000452 ）发给叫车应用。</li>
<li>用户在叫车的时候，叫车应用会根据用户的经纬度位置（例如经度116.054579，纬度39.030452），查找用户的附近车辆，并进行匹配。</li>
<li>等把位置相近的用户和车辆匹配上以后，叫车应用就会根据车辆的编号，获取车辆的信息，并返回给用户。</li>
</ol>
<p>可以看到，一辆车（或一个用户）对应一组经纬度，并且随着车（或用户）的位置移动，相应的经纬度也会变化。</p>
<p>这种数据记录模式属于一个key（例如车ID）对应一个value（一组经纬度）。当有很多车辆信息要保存时，就需要有一个集合来保存一系列的key和value。Hash集合类型可以快速存取一系列的key和value，正好可以用来记录一系列车辆ID和经纬度的对应关系，所以，我们可以把不同车辆的ID和它们对应的经纬度信息存在Hash集合中，如下图所示：</p>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/c8/0e/c8d3f1951874da0d916ed51ccdce9e0e.jpg" alt="likecat" loading="lazy"></figure>
<p>同时，Hash类型的HSET操作命令，会根据key来设置相应的value值，所以，我们可以用它来快速地更新车辆变化的经纬度信息。</p>
<p>到这里，Hash类型看起来是一个不错的选择。但问题是，对于一个LBS应用来说，除了记录经纬度信息，还需要根据用户的经纬度信息在车辆的Hash集合中进行范围查询。一旦涉及到范围查询，就意味着集合中的元素需要有序，但Hash类型的元素是无序的，显然不能满足我们的要求。</p>
<p>我们再来看看使用Sorted Set类型是不是合适。</p>
<p>Sorted Set类型也支持一个key对应一个value的记录模式，其中，key就是Sorted Set中的元素，而value则是元素的权重分数。更重要的是，Sorted Set可以根据元素的权重分数排序，支持范围查询。这就能满足LBS服务中查找相邻位置的需求了。</p>
<p>实际上，GEO类型的底层数据结构就是用Sorted Set来实现的。咱们还是借着叫车应用的例子来加深下理解。</p>
<p>用Sorted Set来保存车辆的经纬度信息时，Sorted Set的元素是车辆ID，元素的权重分数是经纬度信息，如下图所示：</p>
<figure data-type="image" tabindex="2"><img src="https://static001.geekbang.org/resource/image/a9/4e/a9a6bc78ea3bb652ef1404020dd2934e.jpg" alt="likecat" loading="lazy"></figure>
<p>这时问题来了，Sorted Set元素的权重分数是一个浮点数（float类型），而一组经纬度包含的是经度和纬度两个值，是没法直接保存为一个浮点数的，那具体该怎么进行保存呢？</p>
<p>这就要用到GEO类型中的GeoHash编码了。</p>
<h2 id="geohash的编码方法">GeoHash的编码方法</h2>
<p>为了能高效地对经纬度进行比较，Redis采用了业界广泛使用的GeoHash编码方法，这个方法的基本原理就是“<strong>二分区间，区间编码</strong>”。</p>
<p>当我们要对一组经纬度进行GeoHash编码时，我们要先对经度和纬度分别编码，然后再把经纬度各自的编码组合成一个最终编码。</p>
<p>首先，我们来看下经度和纬度的单独编码过程。</p>
<p>对于一个地理位置信息来说，它的经度范围是[-180,180]。GeoHash编码会把一个经度值编码成一个N位的二进制值，我们来对经度范围[-180,180]做N次的二分区操作，其中N可以自定义。</p>
<p>在进行第一次二分区时，经度范围[-180,180]会被分成两个子区间：[-180,0)和[0,180]（我称之为左、右分区）。此时，我们可以查看一下要编码的经度值落在了左分区还是右分区。如果是落在左分区，我们就用0表示；如果落在右分区，就用1表示。这样一来，每做完一次二分区，我们就可以得到1位编码值。</p>
<p>然后，我们再对经度值所属的分区再做一次二分区，同时再次查看经度值落在了二分区后的左分区还是右分区，按照刚才的规则再做1位编码。当做完N次的二分区后，经度值就可以用一个N bit的数来表示了。</p>
<p>举个例子，假设我们要编码的经度值是116.37，我们用5位编码值（也就是N=5，做5次分区）。</p>
<p>我们先做第一次二分区操作，把经度区间[-180,180]分成了左分区[-180,0)和右分区[0,180]，此时，经度值116.37是属于右分区[0,180]，所以，我们用1表示第一次二分区后的编码值。</p>
<p>接下来，我们做第二次二分区：把经度值116.37所属的[0,180]区间，分成[0,90)和[90, 180]。此时，经度值116.37还是属于右分区[90,180]，所以，第二次分区后的编码值仍然为1。等到第三次对[90,180]进行二分区，经度值116.37落在了分区后的左分区[90, 135)中，所以，第三次分区后的编码值就是0。</p>
<p>按照这种方法，做完5次分区后，我们把经度值116.37定位在[112.5, 123.75]这个区间，并且得到了经度值的5位编码值，即11010。这个编码过程如下表所示：</p>
<figure data-type="image" tabindex="3"><img src="https://static001.geekbang.org/resource/image/3c/f2/3cb007yy63c820d6dd2e4999608683f2.jpg" alt="likecat" loading="lazy"></figure>
<p>对纬度的编码方式，和对经度的一样，只是纬度的范围是[-90，90]，下面这张表显示了对纬度值39.86的编码过程。</p>
<figure data-type="image" tabindex="4"><img src="https://static001.geekbang.org/resource/image/65/6d/65f41469866cb94963b4c9afbf2b016d.jpg" alt="likecat" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[装饰模式]]></title>
        <id>https://q456qq520.github.io/post/zhuang-shi-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/zhuang-shi-mo-shi/">
        </link>
        <updated>2022-02-21T08:33:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="意图">意图</h2>
<p><strong>装饰模式</strong>是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</p>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/content/decorator/decorator-2x.png" alt="likecat" loading="lazy"></figure>
<h2 id="问题">问题</h2>
<p>假设你正在开发一个提供通知功能的库， 其他程序可使用它向用户发送关于重要事件的通知。</p>
<p>库的最初版本基于 通知器Notifier类， 其中只有很少的几个成员变量， 一个构造函数和一个 send发送方法。 该方法可以接收来自客户端的消息参数， 并将该消息发送给一系列的邮箱， 邮箱列表则是通过构造函数传递给通知器的。 作为客户端的第三方程序仅会创建和配置通知器对象一次， 然后在有重要事件发生时对其进行调用。</p>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/decorator/problem1-zh-2x.png" alt="likecat" title="程序可以使用通知器类向预定义的邮箱发送重要事件通知。" loading="lazy"></figure>
<!-- <div align=center>
<img width="400px" height="244px" title="韩孝周" src="https://refactoringguru.cn/images/patterns/diagrams/decorator/problem1-zh-2x.png"/>
</div> -->
<p>此后某个时刻， 你会发现库的用户希望使用除邮件通知之外的功能。 许多用户会希望接收关于紧急事件的手机短信， 还有些用户希望在微信上接收消息， 而公司用户则希望在 QQ 上接收消息。</p>
<figure data-type="image" tabindex="3"><img src="https://refactoringguru.cn/images/patterns/diagrams/decorator/problem2-zh-2x.png?id=269155b9fb40015e85ce" alt="likecat" loading="lazy"></figure>
<p>这有什么难的呢？ 首先扩展 通知器类， 然后在新的子类中加入额外的通知方法。 现在客户端要对所需通知形式的对应类进行初始化， 然后使用该类发送后续所有的通知消息。</p>
<p>但是很快有人会问： ​ “为什么不同时使用多种通知形式呢？ 如果房子着火了， 你大概会想在所有渠道中都收到相同的消息吧。”</p>
<p>你可以尝试创建一个特殊子类来将多种通知方法组合在一起以解决该问题。 但这种方式会使得代码量迅速膨胀， 不仅仅是程序库代码， 客户端代码也会如此。</p>
<figure data-type="image" tabindex="4"><img src="https://refactoringguru.cn/images/patterns/diagrams/decorator/problem3-zh-2x.png?id=4e4a0ce28a97ee56f47a" alt="likecat" loading="lazy"></figure>
<h2 id="解决方案">解决方案</h2>
<p>当你需要更改一个对象的行为时， 第一个跳入脑海的想法就是扩展它所属的类。 但是， 你不能忽视继承可能引发的几个严重问题。</p>
<p>继承是静态的。 你无法在运行时更改已有对象的行为， 只能使用由不同子类创建的对象来替代当前的整个对象。</p>
<p>子类只能有一个父类。 大部分编程语言不允许一个类同时继承多个类的行为。</p>
<p>其中一种方法是用聚合或组合 ， 而不是继承。 两者的工作方式几乎一模一样： 一个对象包含指向另一个对象的引用， 并将部分工作委派给引用对象； 继承中的对象则继承了父类的行为， 它们自己能够完成这些工作。</p>
<p>你可以使用这个新方法来轻松替换各种连接的 “小帮手” 对象， 从而能在运行时改变容器的行为。 一个对象可以使用多个类的行为， 包含多个指向其他对象的引用， 并将各种工作委派给引用对象。</p>
<p>聚合 （或组合） 组合是许多设计模式背后的关键原则 （包括装饰在内）。 记住这一点后， 让我们继续关于模式的讨论。</p>
<figure data-type="image" tabindex="5"><img src="https://refactoringguru.cn/images/patterns/diagrams/decorator/solution1-zh-2x.png?id=6e018cc1ce5d4987999f" alt="likecat" loading="lazy"></figure>
<p>封装器是装饰模式的别称， 这个称谓明确地表达了该模式的主要思想。 ​ “封装器” 是一个能与其他 “目标” 对象连接的对象。 封装器包含与目标对象相同的一系列方法， 它会将所有接收到的请求委派给目标对象。 但是， 封装器可以在将请求委派给目标前后对其进行处理， 所以可能会改变最终结果。</p>
<p>那么什么时候一个简单的封装器可以被称为是真正的装饰呢？ 正如之前提到的， 封装器实现了与其封装对象相同的接口。 因此从客户端的角度来看， 这些对象是完全一样的。 封装器中的引用成员变量可以是遵循相同接口的任意对象。 这使得你可以将一个对象放入多个封装器中， 并在对象中添加所有这些封装器的组合行为。</p>
<p>比如在消息通知示例中， 我们可以将简单邮件通知行为放在基类 通知器中， 但将所有其他通知方法放入装饰中。</p>
<figure data-type="image" tabindex="6"><img src="https://refactoringguru.cn/images/patterns/diagrams/decorator/solution2-zh-2x.png?id=2833359975d33419b2ec" alt="likecat" loading="lazy"></figure>
<p>客户端代码必须将基础通知器放入一系列自己所需的装饰中。 因此最后的对象将形成一个栈结构。</p>
<figure data-type="image" tabindex="7"><img src="https://refactoringguru.cn/images/patterns/diagrams/decorator/solution3-zh-2x.png?id=8c9f86759d233505d4be" alt="likecat" loading="lazy"></figure>
<p>实际与客户端进行交互的对象将是最后一个进入栈中的装饰对象。 由于所有的装饰都实现了与通知基类相同的接口， 客户端的其他代码并不在意自己到底是与 “纯粹” 的通知器对象， 还是与装饰后的通知器对象进行交互。</p>
<p>我们可以使用相同方法来完成其他行为 （例如设置消息格式或者创建接收人列表）。 只要所有装饰都遵循相同的接口， 客户端就可以使用任意自定义的装饰来装饰对象。</p>
<h2 id="装饰模式结构">装饰模式结构</h2>
<figure data-type="image" tabindex="8"><img src="https://refactoringguru.cn/images/patterns/diagrams/decorator/structure-2x.png?id=3cfa1f10417a4ef0c125" alt="likecat" loading="lazy"></figure>
<ol>
<li><strong>部件 （Component））</strong>  声明封装器和被封装对象的公用接口。</li>
<li><strong>具体部件 （Concrete Component））</strong>  类是被封装对象所属的类。 它定义了基础行为， 但装饰类可以改变这些行为。</li>
<li>**基础装饰 （Base Decorator） ** 类拥有一个指向被封装对象的引用成员变量。 该变量的类型应当被声明为通用部件接口， 这样它就可以引用具体的部件和装饰。 装饰基类会将所有操作委派给被封装的对象。</li>
<li><strong>具体装饰类 （Concrete Decorators）</strong> 定义了可动态添加到部件的额外行为。 具体装饰类会重写装饰基类的方法， 并在调用父类方法之前或之后进行额外的行为。</li>
<li>**客户端 （Client） ** 可以使用多层装饰来封装部件， 只要它能使用通用接口与所有对象互动即可。</li>
</ol>
<h2 id="伪代码">伪代码</h2>
<p>编码和压缩装饰</p>
<p>本例展示了如何在不更改对象代码的情况下调整其行为。</p>
<p>最初的业务逻辑类仅能读取和写入纯文本的数据。 此后， 我们创建了几个小的封装器类， 以便在执行标准操作后添加新的行为。</p>
<p>第一个封装器负责加密和解密数据， 而第二个则负责压缩和解压数据。</p>
<p>你甚至可以让这些封装器嵌套封装以将它们组合起来。</p>
<p>定义了读取和写入操作的通用数据接口</p>
<pre><code>package decorator;

/**
 * 定义了读取和写入操作的通用数据接口
 * @author likecat
 * @version 1.0
 * @date 2022/2/21 17:19
 */
public interface DataSource {
    void writeData(String data);

    String readData();
}

</code></pre>
<p>简单数据读写器</p>
<pre><code>package decorator;

import java.io.*;

/**
 * 简单数据读写器
 * @author likecat
 * @version 1.0
 * @date 2022/2/21 17:20
 */
public class FileDataSource implements DataSource{
    private String name;

    public FileDataSource(String name) {
        this.name = name;
    }

    @Override
    public void writeData(String data) {
        File file = new File(name);
        try (OutputStream fos = new FileOutputStream(file)) {
            fos.write(data.getBytes(), 0, data.length());
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }

    @Override
    public String readData() {
        char[] buffer = null;
        File file = new File(name);
        try (FileReader reader = new FileReader(file)) {
            buffer = new char[(int) file.length()];
            reader.read(buffer);
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
        return new String(buffer);
    }
}

</code></pre>
<p>抽象基础装饰</p>
<pre><code>package decorator;

/**
 * 抽象基础装饰
 * @author likecat
 * @version 1.0
 * @date 2022/2/21 17:22
 */
public class DataSourceDecorator implements DataSource{
    private DataSource wrappee;

    DataSourceDecorator(DataSource source) {
        this.wrappee = source;
    }

    @Override
    public void writeData(String data) {
        wrappee.writeData(data);
    }

    @Override
    public String readData() {
        return wrappee.readData();
    }
}


</code></pre>
<p>加密装饰</p>
<pre><code>package decorator;

import java.util.Base64;

/**
 * 加密装饰
 * @author likecat
 * @version 1.0
 * @date 2022/2/21 17:23
 */
public class EncryptionDecorator extends DataSourceDecorator {

    public EncryptionDecorator(DataSource source) {
        super(source);
    }

    @Override
    public void writeData(String data) {
        super.writeData(encode(data));
    }

    @Override
    public String readData() {
        return decode(super.readData());
    }

    private String encode(String data) {
        byte[] result = data.getBytes();
        for (int i = 0; i &lt; result.length; i++) {
            result[i] += (byte) 1;
        }
        return Base64.getEncoder().encodeToString(result);
    }

    private String decode(String data) {
        byte[] result = Base64.getDecoder().decode(data);
        for (int i = 0; i &lt; result.length; i++) {
            result[i] -= (byte) 1;
        }
        return new String(result);
    }
}

</code></pre>
<p>压缩装饰</p>
<pre><code>package decorator;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Base64;
import java.util.zip.Deflater;
import java.util.zip.DeflaterOutputStream;
import java.util.zip.InflaterInputStream;

/**
 * 压缩装饰
 * @author likecat
 * @version 1.0
 * @date 2022/2/21 17:24
 */
public class CompressionDecorator extends DataSourceDecorator {
    private int compLevel = 6;

    public CompressionDecorator(DataSource source) {
        super(source);
    }

    public int getCompressionLevel() {
        return compLevel;
    }

    public void setCompressionLevel(int value) {
        compLevel = value;
    }

    @Override
    public void writeData(String data) {
        super.writeData(compress(data));
    }

    @Override
    public String readData() {
        return decompress(super.readData());
    }

    private String compress(String stringData) {
        byte[] data = stringData.getBytes();
        try {
            ByteArrayOutputStream bout = new ByteArrayOutputStream(512);
            DeflaterOutputStream dos = new DeflaterOutputStream(bout, new Deflater(compLevel));
            dos.write(data);
            dos.close();
            bout.close();
            return Base64.getEncoder().encodeToString(bout.toByteArray());
        } catch (IOException ex) {
            return null;
        }
    }

    private String decompress(String stringData) {
        byte[] data = Base64.getDecoder().decode(stringData);
        try {
            InputStream in = new ByteArrayInputStream(data);
            InflaterInputStream iin = new InflaterInputStream(in);
            ByteArrayOutputStream bout = new ByteArrayOutputStream(512);
            int b;
            while ((b = iin.read()) != -1) {
                bout.write(b);
            }
            in.close();
            iin.close();
            bout.close();
            return new String(bout.toByteArray());
        } catch (IOException ex) {
            return null;
        }
    }
}

</code></pre>
<p>客户端代码</p>
<pre><code>package decorator;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/21 17:26
 */
public class Demo {
    public static void main(String[] args) {
        String salaryRecords = &quot;Name,Salary\nJohn Smith,100000\nSteven Jobs,912000&quot;;
        DataSourceDecorator encoded = new CompressionDecorator(
                new EncryptionDecorator(
                        new FileDataSource(&quot;out/OutputDemo.txt&quot;)));
        encoded.writeData(salaryRecords);
        DataSource plain = new FileDataSource(&quot;out/OutputDemo.txt&quot;);

        System.out.println(&quot;- Input ----------------&quot;);
        System.out.println(salaryRecords);
        System.out.println(&quot;- Encoded --------------&quot;);
        System.out.println(plain.readData());
        System.out.println(&quot;- Decoded --------------&quot;);
        System.out.println(encoded.readData());
    }
}

        
</code></pre>
<p>执行结果</p>
<pre><code>- Input ----------------
Name,Salary
John Smith,100000
Steven Jobs,912000
- Encoded --------------
Zkt7e1Q5eU8yUm1Qe0ZsdHJ2VXp6dDBKVnhrUHtUe0sxRUYxQkJIdjVLTVZ0dVI5Q2IwOXFISmVUMU5rcENCQmdxRlByaD4+
- Decoded --------------
Name,Salary
John Smith,100000
Steven Jobs,912000
</code></pre>
<h2 id="装饰模式适合应用场景">装饰模式适合应用场景</h2>
<ol>
<li>
<p>如果你希望在无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式。<br>
装饰能将业务逻辑组织为层次结构， 你可为各层创建一个装饰， 在运行时将各种不同逻辑组合成对象。 由于这些对象都遵循通用接口， 客户端代码能以相同的方式使用这些对象。</p>
</li>
<li>
<p>如果用继承来扩展对象行为的方案难以实现或者根本不可行， 你可以使用该模式。<br>
许多编程语言使用 final最终关键字来限制对某个类的进一步扩展。 复用最终类已有行为的唯一方法是使用装饰模式： 用封装器对其进行封装。</p>
</li>
</ol>
<h2 id="实现方式">实现方式</h2>
<ol>
<li>
<p>确保业务逻辑可用一个基本组件及多个额外可选层次表示。</p>
</li>
<li>
<p>找出基本组件和可选层次的通用方法。 创建一个组件接口并在其中声明这些方法。</p>
</li>
<li>
<p>创建一个具体组件类， 并定义其基础行为。</p>
</li>
<li>
<p>创建装饰基类， 使用一个成员变量存储指向被封装对象的引用。 该成员变量必须被声明为组件接口类型， 从而能在运行时连接具体组件和装饰。 装饰基类必须将所有工作委派给被封装的对象。</p>
</li>
<li>
<p>确保所有类实现组件接口。</p>
</li>
<li>
<p>将装饰基类扩展为具体装饰。 具体装饰必须在调用父类方法 （总是委派给被封装对象） 之前或之后执行自身的行为。</p>
</li>
<li>
<p>客户端代码负责创建装饰并将其组合成客户端所需的形式。</p>
</li>
</ol>
<h2 id="责任链模式优缺点">责任链模式优缺点</h2>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>你无需创建新子类即可扩展对象的行为。</td>
<td style="text-align:center">在封装器栈中删除特定封装器比较困难。</td>
</tr>
<tr>
<td>你可以在运行时添加或删除对象的功能。</td>
<td style="text-align:center">实现行为不受装饰栈顺序影响的装饰比较困难。</td>
</tr>
<tr>
<td>你可以用多个装饰封装对象来组合几种行为。</td>
<td style="text-align:center">各层的初始化配置代码看上去可能会很糟糕。</td>
</tr>
<tr>
<td>单一职责原则。 你可以将实现了许多不同行为的一个大类拆分为多个较小的类。</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h2 id="与其他模式的关系">与其他模式的关系</h2>
<ol>
<li>
<p><strong>适配器模式</strong>可以对已有对象的接口进行修改， <strong>装饰模式</strong>则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。</p>
</li>
<li>
<p><strong>适配器</strong>能为被封装对象提供不同的接口， <strong>代理模式</strong>能为对象提供相同的接口， <strong>装饰</strong>则能为对象提供加强的接口。</p>
</li>
<li>
<p><strong>责任链模式</strong>和<strong>装饰模式</strong>的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。</p>
<p><strong>责任链</strong>的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。</p>
</li>
<li>
<p><strong>组合模式</strong>和<strong>装饰</strong>的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。</p>
<p>装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。</p>
<p>但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。</p>
</li>
<li>
<p>大量使用<strong>组合</strong>和<strong>装饰</strong>的设计通常可从对于<strong>原型模式</strong>的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</p>
</li>
<li>
<p><strong>装饰</strong>可让你更改对象的外表， <strong>策略模式</strong>则让你能够改变其本质。</p>
</li>
<li>
<p><strong>装饰</strong>和<strong>代理</strong>有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[责任链模式]]></title>
        <id>https://q456qq520.github.io/post/ze-ren-lian-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/ze-ren-lian-mo-shi/">
        </link>
        <updated>2022-01-14T07:28:33.000Z</updated>
        <content type="html"><![CDATA[<h2 id="意图">意图</h2>
<p><strong>责任链模式</strong>是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。</p>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/content/chain-of-responsibility/chain-of-responsibility-2x.png" alt="likecat" loading="lazy"></figure>
<h2 id="问题">问题</h2>
<p>假如你正在开发一个在线订购系统。 你希望对系统访问进行限制， 只允许认证用户创建订单。 此外， 拥有管理权限的用户也拥有所有订单的完全访问权限。</p>
<p>简单规划后， 你会意识到这些检查必须依次进行。 只要接收到包含用户凭据的请求， 应用程序就可尝试对进入系统的用户进行认证。 但如果由于用户凭据不正确而导致认证失败， 那就没有必要进行后续检查了。</p>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/chain-of-responsibility/problem1-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>请求必须经过一系列检查后才能由订购系统来处理。</p>
<p>在接下来的几个月里， 你实现了后续的几个检查步骤。</p>
<ul>
<li>一位同事认为直接将原始数据传递给订购系统存在安全隐患。 因此你新增了额外的验证步骤来清理请求中的数据。</li>
<li>过了一段时间， 有人注意到系统无法抵御暴力密码破解方式的攻击。 为了防范这种情况， 你立刻添加了一个检查步骤来过滤来自同一 IP 地址的重复错误请求。</li>
<li>又有人提议你可以对包含同样数据的重复请求返回缓存中的结果， 从而提高系统响应速度。 因此， 你新增了一个检查步骤， 确保只有没有满足条件的缓存结果时请求才能通过并被发送给系统。</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://refactoringguru.cn/images/patterns/diagrams/chain-of-responsibility/problem2-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>代码变得越来越多， 也越来越混乱。</p>
<p>检查代码本来就已经混乱不堪， 而每次新增功能都会使其更加臃肿。 修改某个检查步骤有时会影响其他的检查步骤。 最糟糕的是， 当你希望复用这些检查步骤来保护其他系统组件时， 你只能复制部分代码， 因为这些组件只需部分而非全部的检查步骤。</p>
<p>系统会变得让人非常费解， 而且其维护成本也会激增。 你在艰难地和这些代码共处一段时间后， 有一天终于决定对整个系统进行重构。</p>
<h2 id="解决方案">解决方案</h2>
<p>与许多其他行为设计模式一样， 责任链会将特定行为转换为被称作处理者的独立对象。 在上述示例中， 每个检查步骤都可被抽取为仅有单个方法的类， 并执行检查操作。 请求及其数据则会被作为参数传递给该方法。</p>
<p>模式建议你将这些处理者连成一条链。 链上的每个处理者都有一个成员变量来保存对于下一处理者的引用。 除了处理请求外， 处理者还负责沿着链传递请求。 请求会在链上移动， 直至所有处理者都有机会对其进行处理。</p>
<p>最重要的是： 处理者可以决定不再沿着链传递请求， 这可高效地取消所有后续处理步骤。</p>
<p>在我们的订购系统示例中， 处理者会在进行请求处理工作后决定是否继续沿着链传递请求。 如果请求中包含正确的数据， 所有处理者都将执行自己的主要行为， 无论该行为是身份验证还是数据缓存。</p>
<figure data-type="image" tabindex="4"><img src="https://refactoringguru.cn/images/patterns/diagrams/chain-of-responsibility/solution1-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>处理者依次排列， 组成一条链。</p>
<p>不过还有一种稍微不同的方式 （也是更经典一种）， 那就是处理者接收到请求后自行决定是否能够对其进行处理。 如果自己能够处理， 处理者就不再继续传递请求。 因此在这种情况下， 每个请求要么最多有一个处理者对其进行处理， 要么没有任何处理者对其进行处理。 在处理图形用户界面元素栈中的事件时， 这种方式非常常见。</p>
<p>例如， 当用户点击按钮时， 按钮产生的事件将沿着 GUI 元素链进行传递， 最开始是按钮的容器 （如窗体或面板）， 直至应用程序主窗口。 链上第一个能处理该事件的元素会对其进行处理。 此外， 该例还有另一个值得我们关注的地方： 它表明我们总能从对象树中抽取出链来。</p>
<figure data-type="image" tabindex="5"><img src="https://refactoringguru.cn/images/patterns/diagrams/chain-of-responsibility/solution2-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>所有处理者类均实现同一接口是关键所在。 每个具体处理者仅关心下一个包含 execute执行方法的处理者。 这样一来， 你就可以在运行时使用不同的处理者来创建链， 而无需将相关代码与处理者的具体类进行耦合。</p>
<h2 id="责任链模式结构">责任链模式结构</h2>
<figure data-type="image" tabindex="6"><img src="https://refactoringguru.cn/images/patterns/diagrams/chain-of-responsibility/structure-2x.png" alt="likecat" loading="lazy"></figure>
<ol>
<li>
<p><strong>处理者 （Handler）</strong> 声明了所有具体处理者的通用接口。 该接口通常仅包含单个方法用于请求处理， 但有时其还会包含一个设置链上下个处理者的方法。</p>
</li>
<li>
<p><strong>基础处理者 （Base Handler）</strong> 是一个可选的类， 你可以将所有处理者共用的样本代码放置在其中。</p>
<p>通常情况下， 该类中定义了一个保存对于下个处理者引用的成员变量。 客户端可通过将处理者传递给上个处理者的构造函数或设定方法来创建链。 该类还可以实现默认的处理行为： 确定下个处理者存在后再将请求传递给它。</p>
</li>
<li>
<p><strong>具体处理者 （Concrete Handlers）</strong> 包含处理请求的实际代码。 每个处理者接收到请求后， 都必须决定是否进行处理， 以及是否沿着链传递请求。</p>
</li>
</ol>
<p>处理者通常是独立且不可变的， 需要通过构造函数一次性地获得所有必要地数据。</p>
<ol start="4">
<li><strong>客户端 （Client）</strong> 可根据程序逻辑一次性或者动态地生成链。 值得注意的是， 请求可发送给链上的任意一个处理者， 而非必须是第一个处理者。</li>
</ol>
<h2 id="伪代码">伪代码</h2>
<p>在本例中， 责任链模式负责为活动的 GUI 元素显示上下文帮助信息。<br>
<img src="https://refactoringguru.cn/images/patterns/diagrams/chain-of-responsibility/example-zh-2x.png" alt="likecat" loading="lazy"></p>
<p>GUI 类使用组合模式生成。 每个元素都链接到自己的容器元素。 你可随时构建从当前元素开始的、 遍历其所有容器的元素链。</p>
<p>使用案例之一是在 GUI 类中将事件向上传递给父组件。 另一个值得注意的使用案例是依次访问过滤器。</p>
<p>基础验证接口</p>
<pre><code>package com.middleware;

/**
 * 基础验证接口
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 16:13
 */
public abstract class Middleware {

    private Middleware next;

    /**
     * Builds chains of middleware objects.
     */
    public Middleware linkWith(Middleware next) {
        this.next = next;
        return next;
    }

    /**
     * Subclasses will implement this method with concrete checks.
     */
    public abstract boolean check(String email, String password);

    /**
     * Runs check on the next object in chain or ends traversing if we're in
     * last object in chain.
     */
    protected boolean checkNext(String email, String password) {
        if (next == null) {
            return true;
        }
        return next.check(email, password);
    }
}

</code></pre>
<p>检查请求数量限制</p>
<pre><code>package com.middleware;

/**
 * 检查请求数量限制
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 16:14
 */
public class ThrottlingMiddleware extends Middleware{
    private int requestPerMinute;
    private int request;
    private long currentTime;

    public ThrottlingMiddleware(int requestPerMinute) {
        this.requestPerMinute = requestPerMinute;
        this.currentTime = System.currentTimeMillis();
    }

    /**
     * Please, not that checkNext() call can be inserted both in the beginning
     * of this method and in the end.
     *
     * This gives much more flexibility than a simple loop over all middleware
     * objects. For instance, an element of a chain can change the order of
     * checks by running its check after all other checks.
     */
    public boolean check(String email, String password) {
        if (System.currentTimeMillis() &gt; currentTime + 60_000) {
            request = 0;
            currentTime = System.currentTimeMillis();
        }

        request++;

        if (request &gt; requestPerMinute) {
            System.out.println(&quot;Request limit exceeded!&quot;);
            Thread.currentThread().stop();
        }
        return checkNext(email, password);
    }
}

</code></pre>
<p>检查用户登录信息</p>
<pre><code>package com.middleware;


/**
 * 检查用户登录信息
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 16:15
 */
public class UserExistsMiddleware extends Middleware {
    private Server server;

    public UserExistsMiddleware(Server server) {
        this.server = server;
    }

    public boolean check(String email, String password) {
        if (!server.hasEmail(email)) {
            System.out.println(&quot;This email is not registered!&quot;);
            return false;
        }
        if (!server.isValidPassword(email, password)) {
            System.out.println(&quot;Wrong password!&quot;);
            return false;
        }
        return checkNext(email, password);
    }
}
</code></pre>
<p>检查用户角色</p>
<pre><code>package com.middleware;

/**
 * 检查用户角色
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 16:17
 */
public class RoleCheckMiddleware extends Middleware {
    public boolean check(String email, String password) {
        if (email.equals(&quot;admin@example.com&quot;)) {
            System.out.println(&quot;Hello, admin!&quot;);
            return true;
        }
        System.out.println(&quot;Hello, user!&quot;);
        return checkNext(email, password);
    }
}
</code></pre>
<p>授权目标</p>
<pre><code>package com.middleware;

import java.util.HashMap;
import java.util.Map;

/**
 * 授权目标
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 16:16
 */
public class Server {
    private Map&lt;String, String&gt; users = new HashMap&lt;&gt;();
    private Middleware middleware;

    /**
     * Client passes a chain of object to server. This improves flexibility and
     * makes testing the server class easier.
     */
    public void setMiddleware(Middleware middleware) {
        this.middleware = middleware;
    }

    /**
     * Server gets email and password from client and sends the authorization
     * request to the chain.
     */
    public boolean logIn(String email, String password) {
        if (middleware.check(email, password)) {
            System.out.println(&quot;Authorization have been successful!&quot;);

            // Do something useful here for authorized users.

            return true;
        }
        return false;
    }

    public void register(String email, String password) {
        users.put(email, password);
    }

    public boolean hasEmail(String email) {
        return users.containsKey(email);
    }

    public boolean isValidPassword(String email, String password) {
        return users.get(email).equals(password);
    }
}

</code></pre>
<p>客户端代码</p>
<pre><code>package com.middleware;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * 客户端代码
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 16:17
 */
public class Demo {
    private static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    private static Server server;

    private static void init() {
        server = new Server();
        server.register(&quot;admin@example.com&quot;, &quot;admin_pass&quot;);
        server.register(&quot;user@example.com&quot;, &quot;user_pass&quot;);

        // All checks are linked. Client can build various chains using the same
        // components.
        Middleware middleware = new ThrottlingMiddleware(2);
        middleware.linkWith(new UserExistsMiddleware(server))
                .linkWith(new RoleCheckMiddleware());

        // Server gets a chain from client code.
        server.setMiddleware(middleware);
    }

    public static void main(String[] args) throws IOException {
        init();

        boolean success;
        do {
            System.out.print(&quot;Enter email: &quot;);
            String email = reader.readLine();
            System.out.print(&quot;Input password: &quot;);
            String password = reader.readLine();
            success = server.logIn(email, password);
        } while (!success);
    }
}

</code></pre>
<p>执行结果</p>
<pre><code>Enter email: admin@example.com
Input password: admin_pass
Hello, admin!
Authorization have been successful!


Enter email: user@example.com
Input password: user_pass
Hello, user!
Authorization have been successful!
</code></pre>
<h2 id="责任链模式适合应用场景">责任链模式适合应用场景</h2>
<ol>
<li>
<p>当程序需要使用不同方式处理不同种类请求， 而且请求类型和顺序预先未知时， 可以使用责任链模式。<br>
该模式能将多个处理者连接成一条链。 接收到请求后， 它会 “询问” 每个处理者是否能够对其进行处理。 这样所有处理者都有机会来处理请求。</p>
</li>
<li>
<p>当必须按顺序执行多个处理者时， 可以使用该模式。<br>
无论你以何种顺序将处理者连接成一条链， 所有请求都会严格按照顺序通过链上的处理者。</p>
</li>
<li>
<p>如果所需处理者及其顺序必须在运行时进行改变， 可以使用责任链模式。<br>
如果在处理者类中有对引用成员变量的设定方法， 你将能动态地插入和移除处理者， 或者改变其顺序。</p>
</li>
</ol>
<h2 id="实现方式">实现方式</h2>
<ol>
<li>
<p>声明处理者接口并描述请求处理方法的签名。</p>
<p>确定客户端如何将请求数据传递给方法。 最灵活的方式是将请求转换为对象， 然后将其以参数的形式传递给处理函数。</p>
</li>
<li>
<p>为了在具体处理者中消除重复的样本代码， 你可以根据处理者接口创建抽象处理者基类。</p>
<p>该类需要有一个成员变量来存储指向链上下个处理者的引用。 你可以将其设置为不可变类。 但如果你打算在运行时对链进行改变， 则需要定义一个设定方法来修改引用成员变量的值。</p>
<p>为了使用方便， 你还可以实现处理方法的默认行为。 如果还有剩余对象， 该方法会将请求传递给下个对象。 具体处理者还能够通过调用父对象的方法来使用这一行为。</p>
</li>
<li>
<p>依次创建具体处理者子类并实现其处理方法。 每个处理者在接收到请求后都必须做出两个决定：</p>
<p>是否自行处理这个请求。</p>
<p>是否将该请求沿着链进行传递。</p>
</li>
<li>
<p>客户端可以自行组装链， 或者从其他对象处获得预先组装好的链。 在后一种情况下， 你必须实现工厂类以根据配置或环境设置来创建链。</p>
</li>
<li>
<p>客户端可以触发链中的任意处理者， 而不仅仅是第一个。 请求将通过链进行传递， 直至某个处理者拒绝继续传递， 或者请求到达链尾。</p>
</li>
<li>
<p>由于链的动态性， 客户端需要准备好处理以下情况：</p>
<p>链中可能只有单个链接。</p>
<p>部分请求可能无法到达链尾。</p>
<p>其他请求可能直到链尾都未被处理。</p>
</li>
</ol>
<h2 id="责任链模式优缺点">责任链模式优缺点</h2>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>你可以控制请求处理的顺序。</td>
<td style="text-align:center">部分请求可能未被处理。</td>
</tr>
<tr>
<td>单一职责原则。 你可对发起操作和执行操作的类进行解耦。</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>开闭原则。 你可以在不更改现有代码的情况下在程序中新增处理者。</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h2 id="与其他模式的关系">与其他模式的关系</h2>
<ol>
<li>
<p><strong>责任链模式</strong>、<strong>命令模式</strong>、 <strong>中介者模式</strong>和<strong>观察者模式</strong>用于处理请求发送者和接收者之间的不同连接方式：</p>
<ul>
<li>责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。</li>
<li>命令在发送者和请求者之间建立单向连接。</li>
<li>中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。</li>
<li>观察者允许接收者动态地订阅或取消接收请求。</li>
</ul>
</li>
<li>
<p><strong>责任链</strong>通常和<strong>组合模式</strong>结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。</p>
</li>
<li>
<p><strong>责任链</strong>的管理者可使用命令模式实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。</p>
<p>还有另外一种实现方式， 那就是请求自身就是一个命令对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。</p>
</li>
<li>
<p><strong>责任链</strong>和<strong>装饰模式</strong>的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。</p>
<p><strong>责任链</strong>的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。</p>
</li>
</ol>
]]></content>
    </entry>
</feed>