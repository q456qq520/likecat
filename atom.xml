<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://q456qq520.github.io</id>
    <title>LIKE CAT</title>
    <updated>2021-07-12T08:29:07.864Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://q456qq520.github.io"/>
    <link rel="self" href="https://q456qq520.github.io/atom.xml"/>
    <subtitle>一条小咸鱼</subtitle>
    <logo>https://q456qq520.github.io/images/avatar.png</logo>
    <icon>https://q456qq520.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, LIKE CAT</rights>
    <entry>
        <title type="html"><![CDATA[生成器模式]]></title>
        <id>https://q456qq520.github.io/post/scj/</id>
        <link href="https://q456qq520.github.io/post/scj/">
        </link>
        <updated>2021-07-12T07:35:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-什么是生成器模式">一、什么是生成器模式</h3>
<h5 id="1-使用相同的创建代码生成不同类型和形式的对象">1. 使用相同的创建代码生成不同类型和形式的对象。</h5>
<p>读起来有点拗口对吧，其实就是说给创建对象提供一个统一对入口，你不用去管内部发生了什么，只需要提取你所需要对结果。<br>
举个例子，你现在需要创建一个房子对象，假设第一栋房子需要四面墙和地板、门和窗，但是第二栋房子在次基础之上额外需要天然气、水、电等，按正常等逻辑我们是可以在前者基础上拓展基类，但是每新增一种房型就需要新增一个子类，要是新增一个参数那就更加麻烦了。还有一个比较简单等实现就是在房屋类上写一个涵盖所有属性等构造函数，但是对于绝大部分情况而言，很多参数都是不需要使用的，这样就会造成构造函数的臃肿。<br>
这个时候就可以使用生成器模式了。</p>
<h3 id="二-怎么实现生成器模式">二、怎么实现生成器模式</h3>
<h5 id="1-将对象构造代码从产品类中抽取出来-并将其放在一个名为生成器的独立对象中">1. 将对象构造代码从产品类中抽取出来， 并将其放在一个名为生成器的独立对象中。</h5>
<p>还是拿上面的例子来说，生成器模式可以将建造房子对象拆分成一组步骤，每次创建对象时， 你都需要通过生成器对象执行一系列步骤。 重点在于你无需调用所有步骤， 而只需调用创建特定对象配置所需的那些步骤即可。<br>
<img src="https://q456qq520.github.io/post-images/1626077781879.png" alt="" loading="lazy"><br>
当你需要创建不同形式的产品时， 其中的一些构造步骤可能需要不同的实现。 例如， 木屋的房门可能需要使用木头制造， 而城堡的房门则必须使用石头制造。<br>
在这种情况下， 你可以创建多个不同的生成器， 用不同方式实现一组相同的创建步骤。 然后你就可以在创建过程中使用这些生成器 （例如按顺序调用多个构造步骤） 来生成不同类型的对象。</p>
<h5 id="2-生成器模式中的主管">2. 生成器模式中的主管。</h5>
<p>你可以进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类。 主管类可定义创建步骤的执行顺序， 而生成器则提供这些步骤的实现。<br>
对于客户端代码来说， 主管类完全隐藏了产品构造细节。 客户端只需要将一个生成器与主管类关联， 然后使用主管类来构造产品， 就能从生成器处获得构造结果了。<br>
主管类不是必须的，取决与开发者自身。</p>
<h3 id="三-生成器模式结构">三、生成器模式结构</h3>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1626077964299.png" alt="" loading="lazy"></figure>
<ol>
<li>生成器 （Builder） 接口声明在所有类型生成器中通用的产品构造步骤。</li>
<li>具体生成器 （Concrete Builders） 提供构造过程的不同实现。 具体生成器也可以构造不遵循通用接口的产品。</li>
<li>产品 （Products） 是最终生成的对象。 由不同生成器构造的产品无需属于同一类层次结构或接口。</li>
<li>主管 （Director） 类定义调用构造步骤的顺序， 这样你就可以创建和复用特定的产品配置。</li>
<li>客户端 （Client） 必须将某个生成器对象与主管类关联。 一般情况下， 你只需通过主管类构造函数的参数进行一次性关联即可。 此后主管类就能使用生成器对象完成后续所有的构造任务。 但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。 在这种情况下， 你在使用主管类生产产品时每次都可以使用不同的生成器。</li>
</ol>
<h3 id="四-生成器模式适合应用场景">四、生成器模式适合应用场景</h3>
<h5 id="1使用生成器模式可避免-重叠构造函数-的出现">1.使用生成器模式可避免 “重叠构造函数）” 的出现。</h5>
<p><em>也就是上文所说的一个构造函数涵盖全部的属性行为</em></p>
<h5 id="2创建不同形式的产品">2.创建不同形式的产品</h5>
<p><em>如果你需要创建的各种形式的产品， 它们的制造过程相似且仅有细节上的差异， 此时可使用生成器模式。</em></p>
<h5 id="3使用生成器构造组合树或其他复杂对象">3.使用生成器构造组合树或其他复杂对象</h5>
<p><em>生成器模式让你能分步骤构造产品。 你可以延迟执行某些步骤而不会影响最终产品。 你甚至可以递归调用这些步骤， 这在创建对象树时非常方便。</em></p>
<h3 id="五-生成器模式优缺点">五、生成器模式优缺点</h3>
<h5 id="优点">优点</h5>
<ul>
<li>分步创建对象， 暂缓创建步骤或递归运行创建步骤。</li>
<li>生成不同形式的产品时，复用相同的制造代码。</li>
<li>单一职责原则。 将复杂构造代码从产品的业务逻辑中分离出来。</li>
</ul>
<h5 id="缺点">缺点</h5>
<ul>
<li>由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。</li>
</ul>
<h3 id="六-伪代码">六、伪代码</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单例模式]]></title>
        <id>https://q456qq520.github.io/post/Singleton/</id>
        <link href="https://q456qq520.github.io/post/Singleton/">
        </link>
        <updated>2021-07-09T09:18:24.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-什么是单例模式">一、什么是单例模式</h3>
<h5 id="1-只能保证类只有一个实例">1. 只能保证类只有一个实例。</h5>
<p><em>普通构造函数无法实现上述行为， 因为构造函数的设计决定了它必须总是返回一个新对象。</em></p>
<h5 id="2-为该实例提供一个全局访问节点">2.  为该实例提供一个全局访问节点。</h5>
<p><em>也就是对外部提供一个统一的获取实例的入口</em></p>
<h3 id="二-怎么实现单例模式">二、怎么实现单例模式</h3>
<h5 id="1-将默认构造函数设为私有-防止其他对象使用单例类的-new运算符">1. 将默认构造函数设为私有， 防止其他对象使用单例类的 new运算符。</h5>
<h5 id="2-新建一个静态构建方法作-该方法用来调用私有构造函数来创建对象-并将其保存在一个静态成员变量中-此后所有对于该函数的调用都将返回这一缓存对象">2. 新建一个静态构建方法作。该方法用来调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。</h5>
<p>下图是我从网上“偷”来的一张单例模式类图，从图中很明显的可以看出单例模式的结构模式<br>
<img src="https://q456qq520.github.io/post-images/1625823739270.png" alt="" loading="lazy"></p>
<h3 id="三-适用场景">三、适用场景</h3>
<h5 id="1-对于程序中的某个类全局共用一个实例">1. 对于程序中的某个类全局共用一个实例</h5>
<p>单例模式并不等同于全局变量，因为它只保证类存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。</p>
<h3 id="四-伪代码">四、伪代码</h3>
<h5 id="1-eager-initialization">1. Eager initialization</h5>
<p>这种模式下单例类的实例是在类加载时创建的，这是创建单例类的最简单方法，但它有一个缺点，即即使客户端应用程序可能不会使用它，也会创建实例。</p>
<pre><code class="language-Eager">public class EagerInitialization {
    public static final EagerInitialization eagerInitialization= new EagerInitialization();

    private EagerInitialization() {
    }

    public static EagerInitialization getInstance(){
        return eagerInitialization;
    }
}
</code></pre>
<h5 id="2-static-block-initialization">2. Static block initialization</h5>
<p>静态块初始化实现类似于预先初始化，不同之处在于类的实例是在静态块中创建的，</p>
<pre><code class="language-Static">public class StaticBlockSingleton {
    private static StaticBlockSingleton staticBlockSingleton;

    private StaticBlockSingleton() {
    }

    static{
        try{
            staticBlockSingleton = new StaticBlockSingleton();
        }catch(Exception e){
            throw new RuntimeException(&quot;creating singleton instance exception&quot;);
        }
    }

    public static StaticBlockSingleton getInstance(){
        return staticBlockSingleton;
    }
}
</code></pre>
<h5 id="3-lazy-initialization懒汉式">3. Lazy Initialization（懒汉式）</h5>
<p>实现单例模式的延迟初始化方法在全局访问方法中创建实例。并不会类加载时就创建实例，而时在客户端第一次访问时才会初始化。</p>
<pre><code class="language-Lazy">public class LazyInitializedSingleton {
    public static LazyInitializedSingleton lazyInitializedSingleton;

    private LazyInitializedSingleton() {
    }

    public static LazyInitializedSingleton getInstance(){
        if(lazyInitializedSingleton == null){
            lazyInitializedSingleton =  new LazyInitializedSingleton();
        }
        return lazyInitializedSingleton;
    }
}
</code></pre>
<p>在多线程环境下，上述生成单例模式是不安全的，下面会讲述几种线程安全的创建方式。</p>
<h5 id="4-thread-safe-singleton">4. Thread Safe Singleton</h5>
<p>最简单的是使全局访问方法同步，以便一次只有一个线程可以执行此方法。</p>
<pre><code class="language-Thread">public class ThreadSafeSingleton {
    public static ThreadSafeSingleton threadSafeSingleton;

    private ThreadSafeSingleton() {
    }

    public static synchronized ThreadSafeSingleton getInstance(){
        if(threadSafeSingleton == null){
            threadSafeSingleton =  new ThreadSafeSingleton();
        }
        return threadSafeSingleton;
    }
}
</code></pre>
<p>其实并不需要每次获取实例都进行锁，为了每次都避免这种额外的开销，还可以使用下面都双重校验锁都方式</p>
<pre><code class="language-UsingDoubleLocking">public static ThreadSafeSingleton getInstanceUsingDoubleLocking(){
    if(threadSafeSingleton == null){
        synchronized (ThreadSafeSingleton.class) {
             if(threadSafeSingleton == null){
                 threadSafeSingleton = new ThreadSafeSingleton();
             }
         }
    }
    return threadSafeSingleton;
 }
</code></pre>
<h5 id="5-bill-pugh-singleton-implementation静态内部类">5. Bill Pugh Singleton Implementation（静态内部类）</h5>
<p>当加载单例类时，<em>SingletonHelper</em>类不会加载到内存中，只有当有人调用getInstance方法时，才会加载这个类并创建单例类实例。</p>
<pre><code class="language-Bill">public class BillPughSingleton {

    private BillPughSingleton() {
    }

    private static class SingletonHelper{
        private static final BillPughSingleton INSTANCE = new BillPughSingleton();
    }

    public static BillPughSingleton getInstance(){
        return SingletonHelper.INSTANCE;
    }
}
</code></pre>
<h5 id="6-using-reflection-to-destroy-singleton-pattern反射">6. Using Reflection to destroy Singleton Pattern（反射）</h5>
<p>反射会破坏单例模式，下面例子生成的hashcode是不同的，感兴趣的可以试试。</p>
<pre><code class="language-Using"> public static void main(String[] args) {
        EagerInitialization instanceOne = EagerInitialization.getInstance();
        EagerInitialization instanceTwo = null;
        try {
            Constructor[] constructors = EagerInitialization.class.getDeclaredConstructors();
            for (Constructor constructor : constructors) {
                constructor.setAccessible(true);
                instanceTwo = (EagerInitialization) constructor.newInstance();
                break;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(instanceOne.hashCode());
        System.out.println(instanceTwo.hashCode());
    }
</code></pre>
<h5 id="7-enum-singleton枚举">7. Enum Singleton（枚举）</h5>
<p>Java 确保任何枚举值在 Java 程序中仅被实例化一次。由于Java 枚举值是全局可访问的，因此单例也是如此。缺点是枚举类型有点不灵活；例如，它不允许延迟初始化。</p>
<pre><code class="language-Enum">public enum EnumSingleton {
    INSTANCE;

    public static void doSomething(){
        //do something
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RocketMq消息及其应用]]></title>
        <id>https://q456qq520.github.io/post/rocketmq/</id>
        <link href="https://q456qq520.github.io/post/rocketmq/">
        </link>
        <updated>2021-07-09T04:42:00.000Z</updated>
        <content type="html"><![CDATA[<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">一</mi><mi mathvariant="normal">、</mi><mi mathvariant="normal">延</mi><mi mathvariant="normal">迟</mi><mi mathvariant="normal">消</mi><mi mathvariant="normal">息</mi></mrow><annotation encoding="application/x-tex">一、延迟消息</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">、</span><span class="mord cjk_fallback">延</span><span class="mord cjk_fallback">迟</span><span class="mord cjk_fallback">消</span><span class="mord cjk_fallback">息</span></span></span></span><br>
定时消息（延迟队列）是指消息发送到broker后，不会立即被消费，等待特定时间投递给真正的topic。</p>
<p>broker有配置项messageDelayLevel，默认值为“<s>1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</s>”，18个level。<br>
配置自定义messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 10m 15m 20m 30m 1h 3h 6h 12h 24h</p>
<p>注意，messageDelayLevel是broker的属性，不属于某个topic。<br>
发消息时，设置delayLevel等级即可。level有以下三种情况：</p>
<ul>
<li>level == 0，消息为非延迟消息</li>
<li>1&lt;=level&lt;=maxLevel，消息延迟特定时间，例如level==1，延迟1s</li>
<li>level &gt; maxLevel，则level== maxLevel，例如level==20，延迟24h</li>
</ul>
<p>定时消息会暂存在名为SCHEDULE_TOPIC_XXXX的topic中，并根据delayTimeLevel存入特定的queue，queueId = delayTimeLevel – 1，即一个queue只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。broker会调度地消费SCHEDULE_TOPIC_XXXX，将消息写入真实的topic。</p>
<p>需要注意的是，定时消息会在第一次写入和调度写入真实topic时都会计数，因此发送数量、tps都会变高。</p>
<pre><code class="language-java">/**
   * 重试次数--延迟级别对应关系
   */
    static ConcurrentHashMap&lt;Integer,Integer&gt; retryTimeDelayLevelMap = new ConcurrentHashMap&lt;&gt;();
    static{
        retryTimeDelayLevelMap.put(1,5);//1min
        retryTimeDelayLevelMap.put(4,14);//1h
        retryTimeDelayLevelMap.put(2,7);//3min
        retryTimeDelayLevelMap.put(3,10);//10min
    }
//发送延迟消息
public void sendDelayNotify(VideoStateChangeEvent event) {
        try{
            if(event.getRetryTimes()&gt;4 || event.getRetryTimes()&lt;1){
                LOG.warn(&quot;仅仅支持重发4次 retryTimes:{}&quot;,event.getRetryTimes());
                return;
            }
            org.springframework.messaging.Message mmm = MessageBuilder.withPayload(event).build();
            ResultDTO r = rocketMQTemplate.syncSendDelay(mediaCallbackTopic + &quot;:&quot; + event.getEventType(), mmm, retryTimeDelayLevelMap.get(event.getRetryTimes()));
        }catch(Exception e){
            //dosomething
        }
    }
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">二</mi><mi mathvariant="normal">、</mi><mi mathvariant="normal">重</mi><mi mathvariant="normal">试</mi><mi mathvariant="normal">消</mi><mi mathvariant="normal">息</mi></mrow><annotation encoding="application/x-tex">二、重试消息</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">、</span><span class="mord cjk_fallback">重</span><span class="mord cjk_fallback">试</span><span class="mord cjk_fallback">消</span><span class="mord cjk_fallback">息</span></span></span></span><br>
Consumer消费消息失败后，要提供一种重试机制，令消息再消费一次。Consumer消费消息失败通常可以认为有以下几种情况：</p>
<p>由于消息本身的原因，例如反序列化失败，消息数据本身无法处理（例如话费充值，当前消息的手机号被注销，无法充值）等。这种错误通常需要跳过这条消息，再消费其它消息，而这条失败的消息即使立刻重试消费，99%也不成功，所以最好提供一种定时重试机制，即过10秒后再重试。<br>
由于依赖的下游应用服务不可用，例如db连接不可用，外系统网络不可达等。遇到这种错误，即使跳过当前失败的消息，消费其他消息同样也会报错。这种情况建议应用sleep 30s，再消费下一条消息，这样可以减轻Broker重试消息的压力。<br>
RocketMQ会为每个消费组都设置一个Topic名称为“%RETRY%+consumerGroup”的重试队列（这里需要注意的是，这个Topic的重试队列是针对消费组，而不是针对每个Topic设置的），用于暂时保存因为各种异常而导致Consumer端无法消费的消息。考虑到异常恢复起来需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有与之对应的重新投递延时，重试次数越多投递延时就越大。RocketMQ对于重试消息的处理是先保存至Topic名称为“SCHEDULE_TOPIC_XXXX”的延迟队列中，后台定时任务按照对应的时间进行Delay后重新保存至“%RETRY%+consumerGroup”的重试队列中。</p>
<pre><code class="language-java">/**
 * 消费者
 */
@Service
@RocketMQMessageListener(
        consumerGroup = &quot;${consumer}&quot;,
        topic = &quot;${topic}&quot;,
        selectorExpression = &quot;*&quot;)
public class CallbackTopicConsumer implements RocketMQListener&lt;MessageExt&gt;{(CallbackTopicConsumer.class);
    @Override
    public void onMessage(MessageExt msg) {
        try {
            byte[] bytes = msg.getBody();
            //dosomething
        }catch (MediaStorePlatformException e1){
            //对于特定异常类型，如果异常被catch后，没有往外抛，client认为消息已经被消费。
            //此时，消息会丢弃
          //dosomething
        }catch (Exception e) {
            //dosomething
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git冲突相关解决方案]]></title>
        <id>https://q456qq520.github.io/post/git/</id>
        <link href="https://q456qq520.github.io/post/git/">
        </link>
        <updated>2021-07-07T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>拉取远程分支失败，如果是git未忽略文件，可以cd至该工程目录下使用   <code>git rm --cached xxx.iml</code>删除完后再次尝试拉取。</p>
]]></content>
    </entry>
</feed>