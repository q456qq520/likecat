<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://q456qq520.github.io</id>
    <title>LIKE CAT</title>
    <updated>2021-12-16T09:37:12.767Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://q456qq520.github.io"/>
    <link rel="self" href="https://q456qq520.github.io/atom.xml"/>
    <subtitle>一条小咸鱼</subtitle>
    <logo>https://q456qq520.github.io/images/avatar.png</logo>
    <icon>https://q456qq520.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, LIKE CAT</rights>
    <entry>
        <title type="html"><![CDATA[Redis哨兵模式]]></title>
        <id>https://q456qq520.github.io/post/redis-shao-bing-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/redis-shao-bing-mo-shi/">
        </link>
        <updated>2021-12-16T09:17:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="为何会有哨兵模式">为何会有哨兵模式？</h2>
<p>redis写操作是由主库控制，而读操作可以由从库支持。但是如果主库挂了，那还未来得及同步的数据将丢失，而且也无法提供写服务。所以，如果主库挂了，我们就需要运行一个新主库，比如说把一个从库切换为主库，把它当成主库。这就涉及到三个问题：</p>
<ul>
<li>主库真的挂了吗？</li>
<li>该选择哪个从库作为主库？</li>
<li>怎么把新主库的相关信息通知给从库和客户端呢？</li>
</ul>
<p>而哨兵机制就是解决以上三个问题。<br>
哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制模式下故障转移的这三个问题。<br>
<img src="https://static001.geekbang.org/resource/image/d8/20/d828d7eee133cec690dc140e99e26f20.jpg" alt="sdas" title="redis哨兵机制" loading="lazy"></p>
<h2 id="哨兵机制的基本流程">哨兵机制的基本流程</h2>
<p>哨兵就是一个运行在特殊模式下的Redis进程，主从库实例运行的同时，它也在运行。哨兵主要负责的就是三个任务：监控、选主（选择主库）和通知。</p>
<ul>
<li>
<p>监控是指哨兵进程在运行时，周期性地给所有的主从库发送PING命令，检测它们是否仍然在线运行。如果从库没有在规定时间内响应哨兵的PING命令，哨兵就会把它标记为“下线状态”；同样，如果主库也没有在规定时间内响应哨兵的PING命令，哨兵就会判定主库下线，然后开始自动切换主库的流程。</p>
</li>
<li>
<p>选主。主库挂了以后，哨兵就需要从很多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库。</p>
</li>
<li>
<p>通知。在执行通知任务时，哨兵会把新主库的连接信息发给其他从库，让它们执行replicaof命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis数据同步]]></title>
        <id>https://q456qq520.github.io/post/redis-shu-ju-tong-bu/</id>
        <link href="https://q456qq520.github.io/post/redis-shu-ju-tong-bu/">
        </link>
        <updated>2021-12-13T09:08:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="主从库如何实现数据一致">主从库如何实现数据一致？</h2>
<p>AOF和RDB能够减少<strong>数据丢失</strong>带来袋损失，那如果单台应用服务器宕机时我们应该如何应对呢？<br>
Redis的做法就是增加副本冗余量，将一份数据同时保存在多个实例上。即使有一个实例出现了故障，需要过一段时间才能恢复，其他实例也可以对外提供服务，不会影响业务使用。</p>
<p>那么就会产生新的问题，多个副本之前如何保持数据同步呢（不管请求打在哪一台服务器上都能读取到一样都数据）？<br>
Redis提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。<br>
读操作：主库、从库都可以接收；<br>
写操作：首先到主库执行，然后，主库将写操作同步给从库。</p>
<p><img src="https://static001.geekbang.org/resource/image/80/2f/809d6707404731f7e493b832aa573a2f.jpg" alt="sdas" title="redis读写分离" loading="lazy"><br>
那么，为什么要采用读写分离的方式呢？</p>
<p>你可以设想一下，如果在上图中，不管是主库还是从库，都能接收客户端的写操作，那么，一个直接的问题就是：如果客户端对同一个数据（例如k1）前后修改了三次，每一次的修改请求都发送到不同的实例上，在不同的实例上执行，那么，这个数据在这三个实例上的副本就不一致了（分别是v1、v2和v3）。在读取这个数据的时候，就可能读取到旧的值。</p>
<p>如果我们非要保持这个数据在三个实例上一致，就要涉及到加锁、实例间协商是否完成修改等一系列操作，但这会带来巨额的开销，当然是不太能接受的。</p>
<p>而主从库模式一旦采用了读写分离，所有数据的修改只会在主库上进行，不用协调三个实例。主库有了最新的数据后，会同步给从库，这样，主从库的数据就是一致的。</p>
<hr>
<h2 id="主从库间如何进行第一次同步">主从库间如何进行第一次同步？</h2>
<p>当我们启动多个Redis实例的时候，它们相互之间就可以通过replicaof（Redis 5.0之前使用slaveof）命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。</p>
<p>例如，现在有实例1（ip：172.16.19.3）和实例2（ip：172.16.19.5），我们在实例2上执行以下这个命令后，实例2就变成了实例1的从库，并从实例1上复制数据：<code>replicaof 172.16.19.3 6379</code><br>
<img src="https://static001.geekbang.org/resource/image/63/a1/63d18fd41efc9635e7e9105ce1c33da1.jpg" alt="blockchain" title="第一次同步" loading="lazy"></p>
<p>第一阶段是主从库间建立连接、协商同步的过程，主要是为全量复制做准备。在这一步，从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。</p>
<p>具体来说，从库给主库发送psync命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync命令包含了主库的runID和复制进度offset两个参数。</p>
<ul>
<li>
<p>runID，是每个Redis实例启动时都会自动生成的一个随机ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的runID，所以将runID设为“？”。</p>
</li>
<li>
<p>offset，此时设为-1，表示第一次复制。</p>
<p>主库收到psync命令后，会用FULLRESYNC响应命令带上两个参数：主库runID和主库目前的复制进度offset，返回给从库。从库收到响应后，会记录下这两个参数。</p>
</li>
</ul>
<p><strong>FULLRESYNC响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库。</strong></p>
<p>在第二阶段，**主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。**这个过程依赖于内存快照生成的RDB文件。</p>
<p>具体来说，主库执行bgsave命令，生成RDB文件，接着将文件发给从库。从库接收到RDB文件后，会先清空当前数据库，然后加载RDB文件。这是因为从库在通过replicaof命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。</p>
<p>在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的RDB文件中。为了保证主从库的数据一致性，主库会在内存中用专门的replication buffer，记录RDB文件生成后收到的所有写操作。</p>
<p>最后，也就是第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。具体的操作是，当主库完成RDB文件发送后，就会把此时replication buffer中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。</p>
<h2 id="主从级联模式分担全量复制时的主库压力">主从级联模式分担全量复制时的主库压力</h2>
<p>通过分析主从库间第一次数据同步的过程，你可以看到，一次全量复制中，对于主库来说，需要完成两个耗时的操作：生成RDB文件和传输RDB文件。</p>
<p>如果从库数量很多，而且都要和主库进行全量复制的话，就会导致主库忙于fork子进程生成RDB文件，进行数据全量同步。fork这个操作会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢。此外，传输RDB文件也会占用主库的网络带宽，同样会给主库的资源使用带来压力。那么，有没有好的解决方法可以分担主库压力呢？</p>
<p>其实是有的，这就是“主-从-从”模式。</p>
<p>在刚才介绍的主从库模式中，所有的从库都是和主库连接，所有的全量复制也都是和主库进行的。现在，我们可以<strong>通过“主-从-从”模式将主库生成RDB和传输RDB的压力，以级联的方式分散到从库上</strong>。</p>
<p>简单来说，我们在部署主从集群的时候，可以手动选择一个从库（比如选择内存资源配置较高的从库），用于级联其他的从库。然后，我们可以再选择一些从库（例如三分之一的从库），在这些从库上执行如下命令，让它们和刚才所选的从库，建立起主从关系。</p>
<p><code>replicaof 所选从库的IP 6379</code></p>
<p>这样一来，这些从库就会知道，在进行同步时，不用再和主库进行交互了，只要和级联的从库进行写操作同步就行了，这就可以减轻主库上的压力，如下图所示：<br>
<img src="https://static001.geekbang.org/resource/image/40/45/403c2ab725dca8d44439f8994959af45.jpg" alt="blockchain" title="主从从同步" loading="lazy"><br>
一旦主从库完成了全量复制，它们之间就会一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为基于长连接的命令传播，可以避免频繁建立连接的开销。</p>
<p>新的问题诞生了，如果<strong>网络断连或阻塞</strong>主从库之间就无法进行命令传播了，从库的数据自然也就没办法和主库保持一致了，客户端就可能从从库读到旧数据。该怎么办呢？</p>
<h2 id="主从库间网络断了怎么办">主从库间网络断了怎么办？</h2>
<p>在Redis 2.8之前，如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。</p>
<p>从Redis 2.8开始，网络断了之后，主从库会采用增量复制的方式继续同步。听名字大概就可以猜到它和全量复制的不同：全量复制是同步所有数据，而增量复制只会把主从库网络断连期间主库收到的命令，同步给从库。</p>
<p>增量复制时，主从库之间具体是怎么保持同步的呢？redis中有一个<strong>repl_backlog_buffer</strong>环形缓冲区，<strong>主库会记录自己写到的位置，从库则会记录自己已经读到的位置</strong>。</p>
<p>刚开始的时候，主库和从库的写读位置在一起，这算是它们的起始位置。随着主库不断接收新的写操作，它在缓冲区中的写位置会逐步偏离起始位置，我们通常用偏移量来衡量这个偏移距离的大小，对主库来说，对应的偏移量就是master_repl_offset。主库接收的新写操作越多，这个值就会越大。</p>
<p>同样，从库在复制完写操作命令后，它在缓冲区中的读位置也开始逐步偏移刚才的起始位置，此时，从库已复制的偏移量slave_repl_offset也在不断增加。正常情况下，这两个偏移量基本相等。</p>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/13/37/13f26570a1b90549e6171ea24554b737.jpg" alt="blockchain" title="主从从同步" loading="lazy"></figure>
<p>主从库的连接恢复之后，从库首先会给主库发送psync命令，并把自己当前的slave_repl_offset发给主库，主库会判断自己的master_repl_offset和slave_repl_offset之间的差距。</p>
<p>在网络断连阶段，主库可能会收到新的写操作命令，所以，一般来说，master_repl_offset会大于slave_repl_offset。此时，主库只用把master_repl_offset和slave_repl_offset之间的命令操作同步给从库就行。<br>
<img src="https://static001.geekbang.org/resource/image/20/16/20e233bd30c3dacb0221yy0c77780b16.jpg" alt="blockchain" title="主从从同步" loading="lazy"><br>
就像刚刚示意图的中间部分，主库和从库之间相差了put d e和put d f两个操作，在增量复制时，主库只需要把它们同步给从库，就行了。</p>
<p>因为repl_backlog_buffer是一个环形缓冲区，所以在缓冲区写满后，主库会继续写入，此时，就会覆盖掉之前写入的操作。如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致。</p>
<p>一般而言，我们可以调整repl_backlog_size这个参数。这个参数和所需的缓冲空间大小有关。缓冲空间的计算公式是：缓冲空间大小 = 主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小。在实际应用中，考虑到可能存在一些突发的请求压力，我们通常需要把这个缓冲空间扩大一倍，即repl_backlog_size = 缓冲空间大小 * 2，这也就是repl_backlog_size的最终值。</p>
<p>举个例子，如果主库每秒写入2000个操作，每个操作的大小为2KB，网络每秒能传输1000个操作，那么，有1000个操作需要缓冲起来，这就至少需要2MB的缓冲空间。否则，新写的命令就会覆盖掉旧操作了。为了应对可能的突发压力，我们最终把repl_backlog_size设为4MB。</p>
<p>这样一来，增量复制时主从库的数据不一致风险就降低了。不过，如果并发请求量非常大，连两倍的缓冲空间都存不下新操作请求的话，此时，主从库数据仍然可能不一致。</p>
<p>针对这种情况，一方面，你可以根据Redis所在服务器的内存资源再适当增加repl_backlog_size值，比如说设置成缓冲空间大小的4倍，另一方面，你可以考虑使用切片集群来分担单个主库的请求压力。</p>
<p>总结来说，有三种模式：<strong>全量复制</strong>、<strong>基于长连接的命令传播</strong>，以及<strong>增量复制</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[原型模式]]></title>
        <id>https://q456qq520.github.io/post/yuan-xing-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/yuan-xing-mo-shi/">
        </link>
        <updated>2021-12-08T08:51:25.000Z</updated>
        <content type="html"><![CDATA[<h4 id="概念">概念</h4>
<p>原型模式是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。</p>
<h4 id="问题">问题</h4>
<p>如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中。</p>
<p>但有个小问题。 并非所有对象都能通过这种方式进行复制， 因为有些对象可能拥有私有成员变量， 它们在对象本身以外是不可见的。</p>
<p>直接复制还有另外一个问题。 因为你必须知道对象所属的类才能创建复制品， 所以代码必须依赖该类。 即使你可以接受额外的依赖性， 那还有另外一个问题： 有时你只知道对象所实现的接口， 而不知道其所属的具体类， 比如可向方法的某个参数传入实现了某个接口的任何对象。</p>
<h4 id="原型模式解决方案">原型模式解决方案</h4>
<p>原型模式将克隆过程委派给被克隆的实际对象。 模式为所有支持<strong>克隆</strong>的对象声明了一个通用接口， 该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合。 通常情况下， 这样的接口中仅包含一个 克隆方法。</p>
<p>所有的类对<strong>克隆</strong>方法的实现都非常相似。 该方法会创建一个当前类的对象， 然后将原始对象所有的成员变量值复制到新建的类中。 你甚至可以复制私有成员变量， 因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。</p>
<p>支持克隆的对象即为原型。 当你的对象有几十个成员变量和几百种类型时， 对其进行<strong>克隆</strong>甚至可以代替子类的构造。</p>
<p>其运作方式如下： 创建一系列不同类型的对象并不同的方式对其进行配置。 如果所需对象与预先配置的对象相同， 那么你只需克隆原型即可， 无需新建一个对象。</p>
<h4 id="原型模式结构">原型模式结构</h4>
<h5 id="基本实现">基本实现</h5>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/diagrams/prototype/structure-2x.png?id=ba75079f42f08028ae4c" alt="原型模式结构" title="原型模式结构" loading="lazy"></figure>
<p>其中几个名次解释如下：</p>
<ul>
<li><strong>原型 （Prototype）</strong> 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 clone克隆的方法。</li>
<li>** 具体原型 （Concrete Prototype）**  类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。</li>
<li>** 客户端 （Client）**  可以复制实现了原型接口的任何对象。</li>
</ul>
<h5 id="原型注册表实现">原型注册表实现</h5>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/prototype/structure-prototype-cache-2x.png?id=a1e4514bbcc9b10968b8" alt="原型注册表实现" title="原型注册表实现" loading="lazy"></figure>
<ul>
<li><strong>原型注册表 （Prototype Registry）</strong> 提供了一种访问常用原型的简单方法， 其中存储了一系列可供随时复制的预生成对象。 最简单的注册表原型是一个 名称 → 原型的哈希表。 但如果需要使用名称以外的条件进行搜索， 你可以创建更加完善的注册表版本。</li>
</ul>
<h4 id="原型模式适合应用场景">原型模式适合应用场景</h4>
<ul>
<li>如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。</li>
<li>如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。</li>
</ul>
<h4 id="实现方式">实现方式</h4>
<ol>
<li>创建原型接口， 并在其中声明<strong>克隆</strong>方法。 如果你已有类层次结构， 则只需在其所有类中添加该方法即可。</li>
<li>原型类必须另行定义一个以该类对象为参数的构造函数。 构造函数必须复制参数对象中的所有成员变量值到新建实体中。 如果你需要修改子类， 则必须调用父类构造函数， 让父类复制其私有成员变量值。</li>
<li>克隆方法通常只有一行代码： 使用<strong>new</strong>运算符调用原型版本的构造函数。 注意， 每个类都必须显式重写克隆方法并使用自身类名调用<strong>new</strong>运算符。 否则， 克隆方法可能会生成父类的对象。</li>
<li>你还可以创建一个中心化原型注册表， 用于存储常用原型。<br>
<em>你可以新建一个工厂类来实现注册表，或者在原型基类中添加一个获取原型的静态方法。 该方法必须能够根据客户端代码设定的条件进行搜索。 搜索条件可以是简单的字符串， 或者是一组复杂的搜索参数。 找到合适的原型后， 注册表应对原型进行克隆， 并将复制生成的对象返回给客户端。最后还要将对子类构造函数的直接调用替换为对原型注册表工厂方法的调用。</em>`</li>
</ol>
<h4 id="优缺点">优缺点</h4>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>你可以克隆对象， 而无需与它们所属的具体类相耦合。</td>
<td style="text-align:center">克隆包含循环引用的复杂对象可能会非常麻烦。</td>
</tr>
<tr>
<td>你可以克隆预生成原型， 避免反复运行初始化代码。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>你可以更方便地生成复杂对象。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>你可以用继承以外的方式来处理复杂对象的不同配置。</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="与其他模式的关系">与其他模式的关系</h4>
<ul>
<li>在许多设计工作的初期都会使用<strong>工厂方法模式 <strong>（较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用</strong>抽象工厂模式、 原型模式</strong>或**生成器模式 **（更灵活但更加复杂）。</li>
<li><strong>抽象工厂模式</strong>通常基于一组<strong>工厂方法</strong>， 但你也可以使用<strong>原型模式</strong>来生成这些类的方法。</li>
<li>原型可用于保存<strong>命令模式</strong>的历史记录。</li>
<li>大量使用<strong>组合模式</strong>和<strong>装饰模式</strong>的设计通常可从对于<strong>原型</strong>的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</li>
<li><strong>原型</strong>并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 <strong>工厂方法</strong>基于继承， 但是它不需要初始化步骤。</li>
<li>有时候<strong>原型</strong>可以作为<strong>备忘录模式的</strong>一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。</li>
<li><strong>抽象工厂</strong>、 <strong>生成器</strong>和<strong>原型</strong>都可以用<strong>单例模式</strong>来实现。</li>
</ul>
<h4 id="伪代码">伪代码</h4>
<p>使用示例： Java 的 Cloneable  （可克隆） 接口就是立即可用的原型模式。任何类都可通过实现该接口来实现可被克隆的性质。<br>
java.lang.Object#clone() （类必须实现 java.lang.Cloneable 接口）<br>
识别方法： 原型可以简单地通过 clone或 copy等方法来识别。</p>
<p>下面就是一个复制图形的例子</p>
<h5 id="shapes-形状列表">shapes: 形状列表</h5>
<h6 id="shapesshapejava-通用形状接口">shapes/Shape.java: 通用形状接口</h6>
<pre><code>package refactoring_guru.prototype.example.shapes;

import java.util.Objects;

public abstract class Shape {
    public int x;
    public int y;
    public String color;

    public Shape() {
    }

    public Shape(Shape target) {
        if (target != null) {
            this.x = target.x;
            this.y = target.y;
            this.color = target.color;
        }
    }

    public abstract Shape clone();

    @Override
    public boolean equals(Object object2) {
        if (!(object2 instanceof Shape)) return false;
        Shape shape2 = (Shape) object2;
        return shape2.x == x &amp;&amp; shape2.y == y &amp;&amp; Objects.equals(shape2.color, color);
    }
}
</code></pre>
<h6 id="shapescirclejava-简单形状">shapes/Circle.java: 简单形状</h6>
<pre><code> package refactoring_guru.prototype.example.shapes;

public class Circle extends Shape {
    public int radius;

    public Circle() {
    }

    public Circle(Circle target) {
        super(target);
        if (target != null) {
            this.radius = target.radius;
        }
    }

    @Override
    public Shape clone() {
        return new Circle(this);
    }

    @Override
    public boolean equals(Object object2) {
        if (!(object2 instanceof Circle) || !super.equals(object2)) return false;
        Circle shape2 = (Circle) object2;
        return shape2.radius == radius;
    }
}
</code></pre>
<h6 id="shapesrectanglejava-另一个形状">shapes/Rectangle.java: 另一个形状</h6>
<pre><code>  package refactoring_guru.prototype.example.shapes;

public class Rectangle extends Shape {
    public int width;
    public int height;

    public Rectangle() {
    }

    public Rectangle(Rectangle target) {
        super(target);
        if (target != null) {
            this.width = target.width;
            this.height = target.height;
        }
    }

    @Override
    public Shape clone() {
        return new Rectangle(this);
    }

    @Override
    public boolean equals(Object object2) {
        if (!(object2 instanceof Rectangle) || !super.equals(object2)) return false;
        Rectangle shape2 = (Rectangle) object2;
        return shape2.width == width &amp;&amp; shape2.height == height;
    }
}
</code></pre>
<h6 id="demojava-克隆示例">Demo.java: 克隆示例</h6>
<pre><code>package refactoring_guru.prototype.example;

import refactoring_guru.prototype.example.shapes.Circle;
import refactoring_guru.prototype.example.shapes.Rectangle;
import refactoring_guru.prototype.example.shapes.Shape;

import java.util.ArrayList;
import java.util.List;

public class Demo {
    public static void main(String[] args) {
        List&lt;Shape&gt; shapes = new ArrayList&lt;&gt;();
        List&lt;Shape&gt; shapesCopy = new ArrayList&lt;&gt;();

        Circle circle = new Circle();
        circle.x = 10;
        circle.y = 20;
        circle.radius = 15;
        circle.color = &quot;red&quot;;
        shapes.add(circle);

        Circle anotherCircle = (Circle) circle.clone();
        shapes.add(anotherCircle);

        Rectangle rectangle = new Rectangle();
        rectangle.width = 10;
        rectangle.height = 20;
        rectangle.color = &quot;blue&quot;;
        shapes.add(rectangle);

        cloneAndCompare(shapes, shapesCopy);
    }

    private static void cloneAndCompare(List&lt;Shape&gt; shapes, List&lt;Shape&gt; shapesCopy) {
        for (Shape shape : shapes) {
            shapesCopy.add(shape.clone());
        }

        for (int i = 0; i &lt; shapes.size(); i++) {
            if (shapes.get(i) != shapesCopy.get(i)) {
                System.out.println(i + &quot;: Shapes are different objects (yay!)&quot;);
                if (shapes.get(i).equals(shapesCopy.get(i))) {
                    System.out.println(i + &quot;: And they are identical (yay!)&quot;);
                } else {
                    System.out.println(i + &quot;: But they are not identical (booo!)&quot;);
                }
            } else {
                System.out.println(i + &quot;: Shape objects are the same (booo!)&quot;);
            }
        }
    }
}
</code></pre>
<h6 id="outputdemotxt-执行结果">OutputDemo.txt: 执行结果</h6>
<pre><code>0: Shapes are different objects (yay!)
0: And they are identical (yay!)
1: Shapes are different objects (yay!)
1: And they are identical (yay!)
2: Shapes are different objects (yay!)
2: And they are identical (yay!)
</code></pre>
<h5 id="原型注册站">原型注册站</h5>
<p>你可以实现中心化的原型注册站 （或工厂）， 其中包含一系列预定义的原型对象。 这样一来， 你就可以通过传递对象名称或其他参数的方式从工厂处获得新的对象。 工厂将搜索合适的原型， 然后对其进行克隆复制， 最后将副本返回给你。</p>
<h5 id="cache">cache</h5>
<h6 id="cachebundledshapecachejava-原型工厂">cache/BundledShapeCache.java: 原型工厂</h6>
<pre><code>package refactoring_guru.prototype.caching.cache;

import refactoring_guru.prototype.example.shapes.Circle;
import refactoring_guru.prototype.example.shapes.Rectangle;
import refactoring_guru.prototype.example.shapes.Shape;

import java.util.HashMap;
import java.util.Map;

public class BundledShapeCache {
    private Map&lt;String, Shape&gt; cache = new HashMap&lt;&gt;();

    public BundledShapeCache() {
        Circle circle = new Circle();
        circle.x = 5;
        circle.y = 7;
        circle.radius = 45;
        circle.color = &quot;Green&quot;;

        Rectangle rectangle = new Rectangle();
        rectangle.x = 6;
        rectangle.y = 9;
        rectangle.width = 8;
        rectangle.height = 10;
        rectangle.color = &quot;Blue&quot;;

        cache.put(&quot;Big green circle&quot;, circle);
        cache.put(&quot;Medium blue rectangle&quot;, rectangle);
    }

    public Shape put(String key, Shape shape) {
        cache.put(key, shape);
        return shape;
    }

    public Shape get(String key) {
        return cache.get(key).clone();
    }
}
</code></pre>
<h6 id="demojava-克隆示例-2">Demo.java: 克隆示例</h6>
<pre><code>package refactoring_guru.prototype.caching;

import refactoring_guru.prototype.caching.cache.BundledShapeCache;
import refactoring_guru.prototype.example.shapes.Shape;

public class Demo {
    public static void main(String[] args) {
        BundledShapeCache cache = new BundledShapeCache();

        Shape shape1 = cache.get(&quot;Big green circle&quot;);
        Shape shape2 = cache.get(&quot;Medium blue rectangle&quot;);
        Shape shape3 = cache.get(&quot;Medium blue rectangle&quot;);

        if (shape1 != shape2 &amp;&amp; !shape1.equals(shape2)) {
            System.out.println(&quot;Big green circle != Medium blue rectangle (yay!)&quot;);
        } else {
            System.out.println(&quot;Big green circle == Medium blue rectangle (booo!)&quot;);
        }

        if (shape2 != shape3) {
            System.out.println(&quot;Medium blue rectangles are two different objects (yay!)&quot;);
            if (shape2.equals(shape3)) {
                System.out.println(&quot;And they are identical (yay!)&quot;);
            } else {
                System.out.println(&quot;But they are not identical (booo!)&quot;);
            }
        } else {
            System.out.println(&quot;Rectangle objects are the same (booo!)&quot;);
        }
    }
}
</code></pre>
<h6 id="outputdemotxt-执行结果-2">OutputDemo.txt: 执行结果</h6>
<pre><code>Big green circle != Medium blue rectangle (yay!)
Medium blue rectangles are two different objects (yay!)
And they are identical (yay!)
</code></pre>
<p><a href="https://refactoringguru.cn/design-patterns/prototype">参考地址：https://refactoringguru.cn/design-patterns/prototype</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jedis连接池]]></title>
        <id>https://q456qq520.github.io/post/jedis-lian-jie-chi/</id>
        <link href="https://q456qq520.github.io/post/jedis-lian-jie-chi/">
        </link>
        <updated>2021-10-25T06:32:56.000Z</updated>
        <content type="html"><![CDATA[<h5 id="一-为什么使用-jedis-连接池">一 为什么使用 Jedis 连接池</h5>
<pre><code>   当使用 Jedis 直连 Redis 的时候，存在每次新建、关闭连接的开销，极端情况可能出现连接泄漏的问题。而使用连接池是说在一个池子里面对连接进行管理，当请求过来之后先从连接池里面借用连接，用完之后再次归还连接。连接池的连接可以得到复用，有利于降低系统开销，提升系统性能。
</code></pre>
<h5 id="二-jedis-使用连接池">二 Jedis 使用连接池</h5>
<h3 id="21-jedispool-代码">2.1 JedisPool 代码</h3>
<p>(```)</p>
<p>@Configuration<br>
public class JedisClient {</p>
<pre><code>private int minIdle = 1;
private int maxIdle = 8;
private int maxTotal = 256;
private int maxWait = 50;

@Bean
public JedisPoolConfig jedisPoolConfig() {
    JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
    jedisPoolConfig.setMinIdle(minIdle);
    jedisPoolConfig.setMaxIdle(maxIdle);
    jedisPoolConfig.setMaxTotal(maxTotal);
    jedisPoolConfig.setTestOnBorrow(true);
    jedisPoolConfig.setTestOnReturn(true);
    jedisPoolConfig.setBlockWhenExhausted(true);
    jedisPoolConfig.setMaxWaitMillis(maxWait);
    jedisPoolConfig.setFairness(false);
    return jedisPoolConfig;
}
</code></pre>
<p>}<br>
(```)</p>
<h3 id="22-genericobjectpoolconfig-参数配置说明">2.2 GenericObjectPoolConfig 参数配置说明</h3>
<ul>
<li>maxIdle ：连接池中最大的空闲连接数，默认为 8。</li>
<li>minIdle：连接池中最少空闲连接数，默认为 0。</li>
<li>maxTotal：连接池中最大连接数，默认为 8。</li>
<li>maxWaitMillis：当连接池资源用尽后，调用者的最大等待时间（单位为毫秒），一般不建议使用默认值，该默认值为-1，表示永远不超时，一直等待。</li>
<li>testOnBorrow：向连接池借用连接时是否做连接有效性检测（ping），无效连接会被移除，每次借用多执行一次 ping 命令，默认值为 false。</li>
<li>testOnReturn：向连接池归还连接时是否做连接有效性检测（ping），无效连接会被移除，每次归还多执行一次 ping 命令，默认值为 false。</li>
<li>testOWhileIdle：向连接池借用连接时是否做连接空闲检测，空闲超时的连接会被移除，默认值为 false。</li>
<li>blockWhenExhausted：当连接池用尽后，调用者是否要等待，这个参数是和 maxWaitMillis 对应的，只有当此参数为 true 时，maxWaitMillis 才会生效。默认值为 true。</li>
<li>minEvictableIdleTimeMillis：连接的最小空闲时间，达到此值后空闲连接将被移除，默认值 30 分钟。</li>
<li>timeBetweenEvictionRunsMillis：空闲连接的检测周期（单位为毫秒），默认值为 -1，表示不做检测。</li>
<li>numTestsPerEvictionRun：做空闲连接检测时，每次的采样数，默认为 3。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis内存模型]]></title>
        <id>https://q456qq520.github.io/post/redis-nei-cun-mo-xing/</id>
        <link href="https://q456qq520.github.io/post/redis-nei-cun-mo-xing/">
        </link>
        <updated>2021-10-08T08:40:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="基本数据类型">基本数据类型</h3>
<p>String（字符串）、List（列表）、Hash（哈希）、Set（集合）和Sorted Set（有序集合）</p>
<h3 id="底层数据结构">底层数据结构</h3>
<p>动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组</p>
<p><img src="https://static001.geekbang.org/resource/image/f2/2d/f204bdcf37f31c7abcee065daed8dd2d.jpg" alt="底层数据结构" title="底层数据结构" loading="lazy"><br>
可以看到String类型下只要一种数据结构，但是List（列表）、Hash（哈希）、Set（集合）和Sorted Set（有序集合）每个都有2种数据结构，所以也被称之为集合类型。它们均是<strong>一个键对应了一个集合的数据</strong></p>
<h3 id="redis中kv如何保存">Redis中KV如何保存</h3>
<ol>
<li>
<h4 id="一个哈希表来保存所有键值对">一个哈希表来保存所有键值对。</h4>
一个哈希表，也是一个数组，数组的每个元素称为一个哈希桶。一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。<br>
但是哈希表中保存对键值对并不是真实保存对数据，而是指向数据的指针。这样一来不管是字符串还是聚合类型查找所需的时间复杂度均是O(1)。</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/8d/54/8dfc3abd55a2262049b9b77394186554.jpg" alt="redis哈希表" title="redis哈希表" loading="lazy"></figure>
<ol start="2">
<li>
<h4 id="哈希冲突">哈希冲突</h4>
<p>一般来说，哈希桶的个数通常要少于key的数量，这也就是说，难免会有一些key的哈希值对应到了同一个哈希桶中。<br>
当数据量越来越大时，哈希冲突是不可避免的问题。<br>
Redis解决哈希冲突的方式，就是链式哈希。就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。<br>
<img src="https://static001.geekbang.org/resource/image/a5/16/a5cf457ef10cc97b60521ba6caf3d016.jpg" alt="哈希冲突" title="哈希冲突" loading="lazy"><br>
使用链式哈希也有一定当缺陷，就是当链表越来越长时，查询速度也会极具下降。</p>
</li>
<li>
<h4 id="rehash">Rehash</h4>
<p>为了解决上述带来当问题，Redis会对哈希表做rehash操作。rehash也就是增加现有的哈希桶数量，让逐渐增多的entry元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。<br>
Redis默认使用了两个全局哈希表：哈希表1和哈希表2。一开始，当你刚插入数据时，默认使用哈希表1，此时的哈希表2并没有被分配空间。随着数据逐步增多，Redis开始执行rehash，这个过程分为三步：</p>
<ul>
<li>给哈希表2分配更大的空间，例如是当前哈希表1大小的两倍；</li>
<li>把哈希表1中的数据重新映射并拷贝到哈希表2中；</li>
<li>释放哈希表1的空间。<br>
这样就完成了从哈希表1切换到哈希表2，用增大的哈希表2保存更多数据，而原来的哈希表1留作下一次rehash扩容备用。</li>
</ul>
<hr>
<p>但是如果一次性拷贝全部数据会带来线程阻塞，这样就无法正常提供服务了。所以redis采取了<strong>渐进式rehash</strong>。也就是当请求进来时，从哈希表1中依次把这个哈希桶链表下的元素复制到哈希表2中（一个请求一次）。<br>
<img src="https://static001.geekbang.org/resource/image/d0/88/d05c0yy6af25088175a0ac9cdbe2de88.jpg" alt="渐进式rehash" title="渐进式rehash" loading="lazy"><br>
对于String类型来说，找到哈希桶就能直接增删改查了，所以，哈希表的O(1)操作复杂度也就是它的复杂度了。<br>
但是，对于集合类型来说，即使找到哈希桶了，还要在集合中再进一步操作。</p>
</li>
<li>
<h4 id="集合数据操作效率">集合数据操作效率</h4>
<p>集合数据中到数据结构主要有5种：双向链表、压缩列表、哈希表、跳表和整数数组<br>
和String类型不同，一个集合类型的值，第一步是通过全局哈希表找到对应的哈希桶位置，第二步是在集合中再增删改查。<br>
哈希表就是数组加链表，整数数组和双向链表也很常见，它们的操作特征都是顺序读写，也就是通过数组下标或者链表的指针逐个元素访问，操作复杂度基本是O(N)，<br>
压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段zlbytes(列表长度)、zltail(列表尾的偏移量)和zllen(列表中的entry个数)，压缩列表在表尾还有一个zlend，表示列表结束。<br>
在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是O(1)。而查找其他元素时，只能逐个查找，复杂度就是O(N)了。<br>
<img src="https://static001.geekbang.org/resource/image/5d/22/5df168dcafa0db242b0221ab10114e22.jpg" alt="压缩列表" title="压缩列表" loading="lazy"></p>
<p>有序链表只能逐一查找元素，导致操作起来非常缓慢，于是就出现了跳表。具体来说，跳表<strong>在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位</strong>，跳表的查找复杂度为O(logN)。<br>
<img src="https://static001.geekbang.org/resource/image/4e/11/4ecf630ea2bce0b11ecc0397487b3111.jpg" alt="跳表" title="跳表" loading="lazy"></p>
</li>
<li>
<h4 id="数据结构时间复杂度">数据结构时间复杂度</h4>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">数据结构类型</th>
<th style="text-align:center">时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">哈希表</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center">跳表</td>
<td style="text-align:center">O(logN)</td>
</tr>
<tr>
<td style="text-align:center">双向链表</td>
<td style="text-align:center">O(N)</td>
</tr>
<tr>
<td style="text-align:center">压缩列表</td>
<td style="text-align:center">O(N)</td>
</tr>
<tr>
<td style="text-align:center">整数数组</td>
<td style="text-align:center">O(N)</td>
</tr>
</tbody>
</table>
<ol start="6">
<li>
<h4 id="不同操作的复杂度">不同操作的复杂度</h4>
</li>
</ol>
<p>集合类型的操作类型很多，有读写单个集合元素的，例如HGET、HSET，也有操作多个元素的，例如SADD，还有对整个集合进行遍历操作的，例如SMEMBERS。这么多操作，它们的复杂度也各不相同。而复杂度的高低又是选择集合类型的重要依据。</p>
<p>第一，单元素操作，是指每一种集合类型对单个数据实现的增删改查操作。例如，Hash类型的HGET、HSET和HDEL，Set类型的SADD、SREM、SRANDMEMBER等。这些操作的复杂度由集合采用的数据结构决定，例如，HGET、HSET和HDEL是对哈希表做操作，所以它们的复杂度都是O(1)；Set类型用哈希表作为底层数据结构时，它的SADD、SREM、SRANDMEMBER复杂度也是O(1)。</p>
<p>这里，有个地方你需要注意一下，集合类型支持同时对多个元素进行增删改查，例如Hash类型的HMGET和HMSET，Set类型的SADD也支持同时增加多个元素。此时，这些操作的复杂度，就是由单个元素操作复杂度和元素个数决定的。例如，HMSET增加M个元素时，复杂度就从O(1)变成O(M)了。</p>
<p>第二，范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据，比如Hash类型的HGETALL和Set类型的SMEMBERS，或者返回一个范围内的部分数据，比如List类型的LRANGE和ZSet类型的ZRANGE。这类操作的复杂度一般是O(N)，比较耗时，我们应该尽量避免。</p>
<p>不过，Redis从2.8版本开始提供了SCAN系列操作（包括HSCAN，SSCAN和ZSCAN），这类操作实现了渐进式遍历，每次只返回有限数量的数据。这样一来，相比于HGETALL、SMEMBERS这类操作来说，就避免了一次性返回所有元素而导致的Redis阻塞。</p>
<p>第三，统计操作，是指集合类型对集合中所有元素个数的记录，例如LLEN和SCARD。这类操作复杂度只有O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。</p>
<p>第四，例外情况，是指某些数据结构的特殊记录，例如压缩列表和双向链表都会记录表头和表尾的偏移量。这样一来，对于List类型的LPOP、RPOP、LPUSH、RPUSH这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有O(1)，可以实现快速操作。</p>
<p>Redis之所以能快速操作键值对，一方面是因为O(1)复杂度的哈希表被广泛使用，包括String、Hash和Set，它们的操作复杂度基本由哈希表决定，另一方面，Sorted Set也采用了O(logN)复杂度的跳表。不过，集合类型的范围操作，因为要遍历底层数据结构，复杂度通常是O(N)。这里，我的建议是：用其他命令来替代，例如可以用SCAN来代替，避免在Redis内部产生费时的全集合遍历操作。<br>
当然，我们不能忘了复杂度较高的List类型，它的两种底层实现结构：双向链表和压缩列表的操作复杂度都是O(N)。因此，我的建议是：因地制宜地使用List类型。例如，既然它的POP/PUSH效率很高，那么就将它主要用于FIFO队列场景，而不是作为一个可以随机读写的集合。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Springboot中tomcat的启动流程]]></title>
        <id>https://q456qq520.github.io/post/spcat/</id>
        <link href="https://q456qq520.github.io/post/spcat/">
        </link>
        <updated>2021-07-13T09:16:41.000Z</updated>
        <content type="html"><![CDATA[<h5 id="一">一、</h5>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[生成器模式]]></title>
        <id>https://q456qq520.github.io/post/scj/</id>
        <link href="https://q456qq520.github.io/post/scj/">
        </link>
        <updated>2021-07-12T07:35:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-什么是生成器模式">一、什么是生成器模式</h3>
<h5 id="1-使用相同的创建代码生成不同类型和形式的对象">1. 使用相同的创建代码生成不同类型和形式的对象。</h5>
<p>读起来有点拗口对吧，其实就是说给创建对象提供一个统一对入口，你不用去管内部发生了什么，只需要提取你所需要对结果。<br>
举个例子，你现在需要创建一个房子对象，假设第一栋房子需要四面墙和地板、门和窗，但是第二栋房子在次基础之上额外需要天然气、水、电等，按正常等逻辑我们是可以在前者基础上拓展基类，但是每新增一种房型就需要新增一个子类，要是新增一个参数那就更加麻烦了。还有一个比较简单等实现就是在房屋类上写一个涵盖所有属性等构造函数，但是对于绝大部分情况而言，很多参数都是不需要使用的，这样就会造成构造函数的臃肿。<br>
这个时候就可以使用生成器模式了。</p>
<h3 id="二-怎么实现生成器模式">二、怎么实现生成器模式</h3>
<h5 id="1-将对象构造代码从产品类中抽取出来-并将其放在一个名为生成器的独立对象中">1. 将对象构造代码从产品类中抽取出来， 并将其放在一个名为生成器的独立对象中。</h5>
<p>还是拿上面的例子来说，生成器模式可以将建造房子对象拆分成一组步骤，每次创建对象时， 你都需要通过生成器对象执行一系列步骤。 重点在于你无需调用所有步骤， 而只需调用创建特定对象配置所需的那些步骤即可。<br>
<img src="https://q456qq520.github.io/post-images/1626077781879.png" alt="" loading="lazy"><br>
当你需要创建不同形式的产品时， 其中的一些构造步骤可能需要不同的实现。 例如， 木屋的房门可能需要使用木头制造， 而城堡的房门则必须使用石头制造。<br>
在这种情况下， 你可以创建多个不同的生成器， 用不同方式实现一组相同的创建步骤。 然后你就可以在创建过程中使用这些生成器 （例如按顺序调用多个构造步骤） 来生成不同类型的对象。</p>
<h5 id="2-生成器模式中的主管">2. 生成器模式中的主管。</h5>
<p>你可以进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类。 主管类可定义创建步骤的执行顺序， 而生成器则提供这些步骤的实现。<br>
对于客户端代码来说， 主管类完全隐藏了产品构造细节。 客户端只需要将一个生成器与主管类关联， 然后使用主管类来构造产品， 就能从生成器处获得构造结果了。<br>
主管类不是必须的，取决与开发者自身。</p>
<h3 id="三-生成器模式结构">三、生成器模式结构</h3>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1626077964299.png" alt="" loading="lazy"></figure>
<ol>
<li>生成器 （Builder） 接口声明在所有类型生成器中通用的产品构造步骤。</li>
<li>具体生成器 （Concrete Builders） 提供构造过程的不同实现。 具体生成器也可以构造不遵循通用接口的产品。</li>
<li>产品 （Products） 是最终生成的对象。 由不同生成器构造的产品无需属于同一类层次结构或接口。</li>
<li>主管 （Director） 类定义调用构造步骤的顺序， 这样你就可以创建和复用特定的产品配置。</li>
<li>客户端 （Client） 必须将某个生成器对象与主管类关联。 一般情况下， 你只需通过主管类构造函数的参数进行一次性关联即可。 此后主管类就能使用生成器对象完成后续所有的构造任务。 但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。 在这种情况下， 你在使用主管类生产产品时每次都可以使用不同的生成器。</li>
</ol>
<h3 id="四-生成器模式适合应用场景">四、生成器模式适合应用场景</h3>
<h5 id="1使用生成器模式可避免-重叠构造函数-的出现">1.使用生成器模式可避免 “重叠构造函数）” 的出现。</h5>
<p><em>也就是上文所说的一个构造函数涵盖全部的属性行为</em></p>
<h5 id="2创建不同形式的产品">2.创建不同形式的产品</h5>
<p><em>如果你需要创建的各种形式的产品， 它们的制造过程相似且仅有细节上的差异， 此时可使用生成器模式。</em></p>
<h5 id="3使用生成器构造组合树或其他复杂对象">3.使用生成器构造组合树或其他复杂对象</h5>
<p><em>生成器模式让你能分步骤构造产品。 你可以延迟执行某些步骤而不会影响最终产品。 你甚至可以递归调用这些步骤， 这在创建对象树时非常方便。</em></p>
<h3 id="五-生成器模式优缺点">五、生成器模式优缺点</h3>
<h5 id="优点">优点</h5>
<ul>
<li>分步创建对象， 暂缓创建步骤或递归运行创建步骤。</li>
<li>生成不同形式的产品时，复用相同的制造代码。</li>
<li>单一职责原则。 将复杂构造代码从产品的业务逻辑中分离出来。</li>
</ul>
<h5 id="缺点">缺点</h5>
<ul>
<li>由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。</li>
</ul>
<h3 id="六-伪代码">六、伪代码</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单例模式]]></title>
        <id>https://q456qq520.github.io/post/Singleton/</id>
        <link href="https://q456qq520.github.io/post/Singleton/">
        </link>
        <updated>2021-07-09T09:18:24.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-什么是单例模式">一、什么是单例模式</h3>
<h5 id="1-只能保证类只有一个实例">1. 只能保证类只有一个实例。</h5>
<p><em>普通构造函数无法实现上述行为， 因为构造函数的设计决定了它必须总是返回一个新对象。</em></p>
<h5 id="2-为该实例提供一个全局访问节点">2.  为该实例提供一个全局访问节点。</h5>
<p><em>也就是对外部提供一个统一的获取实例的入口</em></p>
<h3 id="二-怎么实现单例模式">二、怎么实现单例模式</h3>
<h5 id="1-将默认构造函数设为私有-防止其他对象使用单例类的-new运算符">1. 将默认构造函数设为私有， 防止其他对象使用单例类的 new运算符。</h5>
<h5 id="2-新建一个静态构建方法作-该方法用来调用私有构造函数来创建对象-并将其保存在一个静态成员变量中-此后所有对于该函数的调用都将返回这一缓存对象">2. 新建一个静态构建方法作。该方法用来调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。</h5>
<p>下图是我从网上“偷”来的一张单例模式类图，从图中很明显的可以看出单例模式的结构模式<br>
<img src="https://q456qq520.github.io/post-images/1625823739270.png" alt="" loading="lazy"></p>
<h3 id="三-适用场景">三、适用场景</h3>
<h5 id="1-对于程序中的某个类全局共用一个实例">1. 对于程序中的某个类全局共用一个实例</h5>
<p>单例模式并不等同于全局变量，因为它只保证类存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。</p>
<h3 id="四-伪代码">四、伪代码</h3>
<h5 id="1-eager-initialization">1. Eager initialization</h5>
<p>这种模式下单例类的实例是在类加载时创建的，这是创建单例类的最简单方法，但它有一个缺点，即即使客户端应用程序可能不会使用它，也会创建实例。</p>
<pre><code class="language-Eager">public class EagerInitialization {
    public static final EagerInitialization eagerInitialization= new EagerInitialization();

    private EagerInitialization() {
    }

    public static EagerInitialization getInstance(){
        return eagerInitialization;
    }
}
</code></pre>
<h5 id="2-static-block-initialization">2. Static block initialization</h5>
<p>静态块初始化实现类似于预先初始化，不同之处在于类的实例是在静态块中创建的，</p>
<pre><code class="language-Static">public class StaticBlockSingleton {
    private static StaticBlockSingleton staticBlockSingleton;

    private StaticBlockSingleton() {
    }

    static{
        try{
            staticBlockSingleton = new StaticBlockSingleton();
        }catch(Exception e){
            throw new RuntimeException(&quot;creating singleton instance exception&quot;);
        }
    }

    public static StaticBlockSingleton getInstance(){
        return staticBlockSingleton;
    }
}
</code></pre>
<h5 id="3-lazy-initialization懒汉式">3. Lazy Initialization（懒汉式）</h5>
<p>实现单例模式的延迟初始化方法在全局访问方法中创建实例。并不会类加载时就创建实例，而时在客户端第一次访问时才会初始化。</p>
<pre><code class="language-Lazy">public class LazyInitializedSingleton {
    public static LazyInitializedSingleton lazyInitializedSingleton;

    private LazyInitializedSingleton() {
    }

    public static LazyInitializedSingleton getInstance(){
        if(lazyInitializedSingleton == null){
            lazyInitializedSingleton =  new LazyInitializedSingleton();
        }
        return lazyInitializedSingleton;
    }
}
</code></pre>
<p>在多线程环境下，上述生成单例模式是不安全的，下面会讲述几种线程安全的创建方式。</p>
<h5 id="4-thread-safe-singleton">4. Thread Safe Singleton</h5>
<p>最简单的是使全局访问方法同步，以便一次只有一个线程可以执行此方法。</p>
<pre><code class="language-Thread">public class ThreadSafeSingleton {
    public static ThreadSafeSingleton threadSafeSingleton;

    private ThreadSafeSingleton() {
    }

    public static synchronized ThreadSafeSingleton getInstance(){
        if(threadSafeSingleton == null){
            threadSafeSingleton =  new ThreadSafeSingleton();
        }
        return threadSafeSingleton;
    }
}
</code></pre>
<p>其实并不需要每次获取实例都进行锁，为了每次都避免这种额外的开销，还可以使用下面都双重校验锁都方式</p>
<pre><code class="language-UsingDoubleLocking">public static ThreadSafeSingleton getInstanceUsingDoubleLocking(){
    if(threadSafeSingleton == null){
        synchronized (ThreadSafeSingleton.class) {
             if(threadSafeSingleton == null){
                 threadSafeSingleton = new ThreadSafeSingleton();
             }
         }
    }
    return threadSafeSingleton;
 }
</code></pre>
<h5 id="5-bill-pugh-singleton-implementation静态内部类">5. Bill Pugh Singleton Implementation（静态内部类）</h5>
<p>当加载单例类时，<em>SingletonHelper</em>类不会加载到内存中，只有当有人调用getInstance方法时，才会加载这个类并创建单例类实例。</p>
<pre><code class="language-Bill">public class BillPughSingleton {

    private BillPughSingleton() {
    }

    private static class SingletonHelper{
        private static final BillPughSingleton INSTANCE = new BillPughSingleton();
    }

    public static BillPughSingleton getInstance(){
        return SingletonHelper.INSTANCE;
    }
}
</code></pre>
<h5 id="6-using-reflection-to-destroy-singleton-pattern反射">6. Using Reflection to destroy Singleton Pattern（反射）</h5>
<p>反射会破坏单例模式，下面例子生成的hashcode是不同的，感兴趣的可以试试。</p>
<pre><code class="language-Using"> public static void main(String[] args) {
        EagerInitialization instanceOne = EagerInitialization.getInstance();
        EagerInitialization instanceTwo = null;
        try {
            Constructor[] constructors = EagerInitialization.class.getDeclaredConstructors();
            for (Constructor constructor : constructors) {
                constructor.setAccessible(true);
                instanceTwo = (EagerInitialization) constructor.newInstance();
                break;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(instanceOne.hashCode());
        System.out.println(instanceTwo.hashCode());
    }
</code></pre>
<h5 id="7-enum-singleton枚举">7. Enum Singleton（枚举）</h5>
<p>Java 确保任何枚举值在 Java 程序中仅被实例化一次。由于Java 枚举值是全局可访问的，因此单例也是如此。缺点是枚举类型有点不灵活；例如，它不允许延迟初始化。</p>
<pre><code class="language-Enum">public enum EnumSingleton {
    INSTANCE;

    public static void doSomething(){
        //do something
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RocketMq消息及其应用]]></title>
        <id>https://q456qq520.github.io/post/rocketmq/</id>
        <link href="https://q456qq520.github.io/post/rocketmq/">
        </link>
        <updated>2021-07-09T04:42:00.000Z</updated>
        <content type="html"><![CDATA[<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">一</mi><mi mathvariant="normal">、</mi><mi mathvariant="normal">延</mi><mi mathvariant="normal">迟</mi><mi mathvariant="normal">消</mi><mi mathvariant="normal">息</mi></mrow><annotation encoding="application/x-tex">一、延迟消息</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">、</span><span class="mord cjk_fallback">延</span><span class="mord cjk_fallback">迟</span><span class="mord cjk_fallback">消</span><span class="mord cjk_fallback">息</span></span></span></span><br>
定时消息（延迟队列）是指消息发送到broker后，不会立即被消费，等待特定时间投递给真正的topic。</p>
<p>broker有配置项messageDelayLevel，默认值为“<s>1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</s>”，18个level。<br>
配置自定义messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 10m 15m 20m 30m 1h 3h 6h 12h 24h</p>
<p>注意，messageDelayLevel是broker的属性，不属于某个topic。<br>
发消息时，设置delayLevel等级即可。level有以下三种情况：</p>
<ul>
<li>level == 0，消息为非延迟消息</li>
<li>1&lt;=level&lt;=maxLevel，消息延迟特定时间，例如level==1，延迟1s</li>
<li>level &gt; maxLevel，则level== maxLevel，例如level==20，延迟24h</li>
</ul>
<p>定时消息会暂存在名为SCHEDULE_TOPIC_XXXX的topic中，并根据delayTimeLevel存入特定的queue，queueId = delayTimeLevel – 1，即一个queue只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。broker会调度地消费SCHEDULE_TOPIC_XXXX，将消息写入真实的topic。</p>
<p>需要注意的是，定时消息会在第一次写入和调度写入真实topic时都会计数，因此发送数量、tps都会变高。</p>
<pre><code class="language-java">/**
   * 重试次数--延迟级别对应关系
   */
    static ConcurrentHashMap&lt;Integer,Integer&gt; retryTimeDelayLevelMap = new ConcurrentHashMap&lt;&gt;();
    static{
        retryTimeDelayLevelMap.put(1,5);//1min
        retryTimeDelayLevelMap.put(4,14);//1h
        retryTimeDelayLevelMap.put(2,7);//3min
        retryTimeDelayLevelMap.put(3,10);//10min
    }
//发送延迟消息
public void sendDelayNotify(VideoStateChangeEvent event) {
        try{
            if(event.getRetryTimes()&gt;4 || event.getRetryTimes()&lt;1){
                LOG.warn(&quot;仅仅支持重发4次 retryTimes:{}&quot;,event.getRetryTimes());
                return;
            }
            org.springframework.messaging.Message mmm = MessageBuilder.withPayload(event).build();
            ResultDTO r = rocketMQTemplate.syncSendDelay(mediaCallbackTopic + &quot;:&quot; + event.getEventType(), mmm, retryTimeDelayLevelMap.get(event.getRetryTimes()));
        }catch(Exception e){
            //dosomething
        }
    }
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">二</mi><mi mathvariant="normal">、</mi><mi mathvariant="normal">重</mi><mi mathvariant="normal">试</mi><mi mathvariant="normal">消</mi><mi mathvariant="normal">息</mi></mrow><annotation encoding="application/x-tex">二、重试消息</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">、</span><span class="mord cjk_fallback">重</span><span class="mord cjk_fallback">试</span><span class="mord cjk_fallback">消</span><span class="mord cjk_fallback">息</span></span></span></span><br>
Consumer消费消息失败后，要提供一种重试机制，令消息再消费一次。Consumer消费消息失败通常可以认为有以下几种情况：</p>
<p>由于消息本身的原因，例如反序列化失败，消息数据本身无法处理（例如话费充值，当前消息的手机号被注销，无法充值）等。这种错误通常需要跳过这条消息，再消费其它消息，而这条失败的消息即使立刻重试消费，99%也不成功，所以最好提供一种定时重试机制，即过10秒后再重试。<br>
由于依赖的下游应用服务不可用，例如db连接不可用，外系统网络不可达等。遇到这种错误，即使跳过当前失败的消息，消费其他消息同样也会报错。这种情况建议应用sleep 30s，再消费下一条消息，这样可以减轻Broker重试消息的压力。<br>
RocketMQ会为每个消费组都设置一个Topic名称为“%RETRY%+consumerGroup”的重试队列（这里需要注意的是，这个Topic的重试队列是针对消费组，而不是针对每个Topic设置的），用于暂时保存因为各种异常而导致Consumer端无法消费的消息。考虑到异常恢复起来需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有与之对应的重新投递延时，重试次数越多投递延时就越大。RocketMQ对于重试消息的处理是先保存至Topic名称为“SCHEDULE_TOPIC_XXXX”的延迟队列中，后台定时任务按照对应的时间进行Delay后重新保存至“%RETRY%+consumerGroup”的重试队列中。</p>
<pre><code class="language-java">/**
 * 消费者
 */
@Service
@RocketMQMessageListener(
        consumerGroup = &quot;${consumer}&quot;,
        topic = &quot;${topic}&quot;,
        selectorExpression = &quot;*&quot;)
public class CallbackTopicConsumer implements RocketMQListener&lt;MessageExt&gt;{(CallbackTopicConsumer.class);
    @Override
    public void onMessage(MessageExt msg) {
        try {
            byte[] bytes = msg.getBody();
            //dosomething
        }catch (MediaStorePlatformException e1){
            //对于特定异常类型，如果异常被catch后，没有往外抛，client认为消息已经被消费。
            //此时，消息会丢弃
          //dosomething
        }catch (Exception e) {
            //dosomething
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git冲突相关解决方案]]></title>
        <id>https://q456qq520.github.io/post/git/</id>
        <link href="https://q456qq520.github.io/post/git/">
        </link>
        <updated>2021-07-07T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>拉取远程分支失败，如果是git未忽略文件，可以cd至该工程目录下使用   <code>git rm --cached xxx.iml</code>删除完后再次尝试拉取。</p>
]]></content>
    </entry>
</feed>