<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://q456qq520.github.io</id>
    <title>LIKE CAT</title>
    <updated>2022-03-14T10:04:01.813Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://q456qq520.github.io"/>
    <link rel="self" href="https://q456qq520.github.io/atom.xml"/>
    <subtitle>一条小咸鱼</subtitle>
    <logo>https://q456qq520.github.io/images/avatar.png</logo>
    <icon>https://q456qq520.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, LIKE CAT</rights>
    <entry>
        <title type="html"><![CDATA[迭代器模式]]></title>
        <id>https://q456qq520.github.io/post/die-dai-qi-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/die-dai-qi-mo-shi/">
        </link>
        <updated>2022-03-14T01:55:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="意图">意图</h1>
<p><strong>迭代器模式</strong>是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。</p>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/content/iterator/iterator-zh-2x.png" alt="likecat" loading="lazy"></figure>
<h1 id="问题">问题</h1>
<p>集合是编程中最常使用的数据类型之一。 尽管如此， 集合只是一组对象的容器而已。</p>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/iterator/problem1-2x.png" alt="各种类型的集合" loading="lazy"></figure>
<p>大部分集合使用简单列表存储元素。 但有些集合还会使用栈、 树、 图和其他复杂的数据结构。</p>
<p>无论集合的构成方式如何， 它都必须提供某种访问元素的方式， 便于其他代码使用其中的元素。 集合应提供一种能够遍历元素的方式， 且保证它不会周而复始地访问同一个元素。</p>
<p>如果你的集合基于列表， 那么这项工作听上去仿佛很简单。 但如何遍历复杂数据结构 （例如树） 中的元素呢？ 例如， 今天你需要使用深度优先算法来遍历树结构， 明天可能会需要广度优先算法； 下周则可能会需要其他方式 （比如随机存取树中的元素）。</p>
<figure data-type="image" tabindex="3"><img src="https://refactoringguru.cn/images/patterns/diagrams/iterator/problem2-2x.png" alt="可通过不同的方式遍历相同的集合" loading="lazy"></figure>
<p>不断向集合中添加遍历算法会模糊其 “高效存储数据” 的主要职责。 此外， 有些算法可能是根据特定应用订制的， 将其加入泛型集合类中会显得非常奇怪。</p>
<p>另一方面， 使用多种集合的客户端代码可能并不关心存储数据的方式。 不过由于集合提供不同的元素访问方式， 你的代码将不得不与特定集合类进行耦合。</p>
<h1 id="解决方案">解决方案</h1>
<p>迭代器模式的主要思想是将集合的遍历行为抽取为单独的迭代器对象。</p>
<figure data-type="image" tabindex="4"><img src="https://refactoringguru.cn/images/patterns/diagrams/iterator/solution1-2x.png" alt="迭代器可实现多种遍历算法。 多个迭代器对象可同时遍历同一个集合" loading="lazy"></figure>
<p>除实现自身算法外， 迭代器还封装了遍历操作的所有细节， 例如当前位置和末尾剩余元素的数量。 因此， 多个迭代器可以在相互独立的情况下同时访问集合。</p>
<p>迭代器通常会提供一个获取集合元素的基本方法。 客户端可不断调用该方法直至它不返回任何内容， 这意味着迭代器已经遍历了所有元素。</p>
<p>所有迭代器必须实现相同的接口。 这样一来， 只要有合适的迭代器， 客户端代码就能兼容任何类型的集合或遍历算法。 如果你需要采用特殊方式来遍历集合， 只需创建一个新的迭代器类即可， 无需对集合或客户端进行修改。</p>
<h1 id="真实世界类比">真实世界类比</h1>
<figure data-type="image" tabindex="5"><img src="https://refactoringguru.cn/images/patterns/content/iterator/iterator-comic-1-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>你计划在罗马游览数天， 参观所有主要的旅游景点。 但在到达目的地后， 你可能会浪费很多时间绕圈子， 甚至找不到罗马斗兽场在哪里。</p>
<p>或者你可以购买一款智能手机上的虚拟导游程序。 这款程序非常智能而且价格不贵， 你想在景点待多久都可以。</p>
<p>第三种选择是用部分旅行预算雇佣一位对城市了如指掌的当地向导。 向导能根据你的喜好来安排行程， 为你介绍每个景点并讲述许多激动人心的故事。 这样的旅行可能会更有趣， 但所需费用也会更高。</p>
<p>所有这些选择(自由漫步、 智能手机导航或真人向导)都是这个由众多罗马景点组成的集合的迭代器。</p>
<h1 id="迭代器模式结构">迭代器模式结构</h1>
<figure data-type="image" tabindex="6"><img src="https://refactoringguru.cn/images/patterns/diagrams/iterator/structure-2x.png" alt="likecat" loading="lazy"></figure>
<ol>
<li>
<p><strong>迭代器 （Iterator）</strong> 接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。</p>
</li>
<li>
<p><strong>具体迭代器 （Concrete Iterators）</strong> 实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。</p>
</li>
<li>
<p><strong>集合</strong>（Collection）接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意， 返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。</p>
</li>
<li>
<p><strong>具体集合（Concrete Collections）</strong> 会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 你可能会琢磨， 剩下的集合代码在什么地方呢？ 不用担心， 它也会在同一个类中。 只是这些细节对于实际模式来说并不重要， 所以我们将其省略了而已。</p>
</li>
<li>
<p><strong>客户端</strong> （Client）通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。</p>
<p>客户端通常不会自行创建迭代器， 而是会从集合中获取。 但在特定情况下， 客户端可以直接创建一个迭代器 （例如当客户端需要自定义特殊迭代器时）。</p>
</li>
</ol>
<h2 id="迭代器模式适合应用场景">迭代器模式适合应用场景</h2>
<ol>
<li>
<p>当集合背后为复杂的数据结构， 且你希望对客户端隐藏其复杂性时 （出于使用便利性或安全性的考虑）， 可以使用迭代器模式。</p>
<p>迭代器封装了与复杂数据结构进行交互的细节， 为客户端提供多个访问集合元素的简单方法。 这种方式不仅对客户端来说非常方便， 而且能避免客户端在直接与集合交互时执行错误或有害的操作， 从而起到保护集合的作用。</p>
</li>
<li>
<p>使用该模式可以减少程序中重复的遍历代码。</p>
<p>重要迭代算法的代码往往体积非常庞大。 当这些代码被放置在程序业务逻辑中时， 它会让原始代码的职责模糊不清， 降低其可维护性。 因此， 将遍历代码移到特定的迭代器中可使程序代码更加精炼和简洁。</p>
</li>
<li>
<p>如果你希望代码能够遍历不同的甚至是无法预知的数据结构， 可以使用迭代器模式。</p>
</li>
</ol>
<pre><code>该模式为集合和迭代器提供了一些通用接口。 如果你在代码中使用了这些接口， 那么将其他实现了这些接口的集合和迭代器传递给它时， 它仍将可以正常运行。
</code></pre>
<h1 id="实现方式">实现方式</h1>
<ol>
<li>
<p>声明迭代器接口。 该接口必须提供至少一个方法来获取集合中的下个元素。 但为了使用方便， 你还可以添加一些其他方法， 例如获取前一个元素、 记录当前位置和判断迭代是否已结束。</p>
</li>
<li>
<p>声明集合接口并描述一个获取迭代器的方法。 其返回值必须是迭代器接口。 如果你计划拥有多组不同的迭代器， 则可以声明多个类似的方法。</p>
</li>
<li>
<p>为希望使用迭代器进行遍历的集合实现具体迭代器类。 迭代器对象必须与单个集合实体链接。 链接关系通常通过迭代器的构造函数建立。</p>
</li>
<li>
<p>在你的集合类中实现集合接口。 其主要思想是针对特定集合为客户端代码提供创建迭代器的快捷方式。 集合对象必须将自身传递给迭代器的构造函数来创建两者之间的链接。</p>
</li>
<li>
<p>检查客户端代码， 使用迭代器替代所有集合遍历代码。 每当客户端需要遍历集合元素时都会获取一个新的迭代器。</p>
</li>
</ol>
<h1 id="迭代器模式优缺点">迭代器模式优缺点</h1>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>单一职责原则。 通过将体积庞大的遍历算法代码抽取为独立的类， 你可对客户端代码和集合进行整理。</td>
<td style="text-align:center">如果你的程序只与简单的集合进行交互， 应用该模式可能会矫枉过正。</td>
</tr>
<tr>
<td>开闭原则。 你可实现新型的集合和迭代器并将其传递给现有代码， 无需修改现有代码。</td>
<td style="text-align:center">对于某些特殊集合， 使用迭代器可能比直接遍历的效率低。</td>
</tr>
<tr>
<td>你可以并行遍历同一集合， 因为每个迭代器对象都包含其自身的遍历状态。</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>相似的， 你可以暂停遍历并在需要时继续。</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h1 id="与其他模式的关系">与其他模式的关系</h1>
<ol>
<li>
<p>你可以使用<strong>迭代器模式</strong>来遍历<strong>组合模式树</strong>。</p>
</li>
<li>
<p>你可以同时使用<strong>工厂方法模式</strong>和<strong>迭代器</strong>来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。</p>
</li>
<li>
<p>你可以同时使用<strong>备忘录模式</strong>和<strong>迭代器</strong>来获取当前迭代器的状态， 并且在需要的时候进行回滚。</p>
</li>
<li>
<p>可以同时使用<strong>访问者模式</strong>和<strong>迭代器</strong>来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同。</p>
</li>
</ol>
<h1 id="伪代码">伪代码</h1>
<h2 id="迭代访问社交网络档案">迭代访问社交网络档案</h2>
<p>在本例中， 迭代器模式被用于在不向客户端代码暴露通信细节的情况下访问远程社交网络集合中的社交媒体档案。</p>
<h3 id="社交档案">社交档案</h3>
<pre><code>package com.iterator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * 社交档案
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:35
 */
public class Profile {

    private String name;
    private String email;
    private Map&lt;String, List&lt;String&gt;&gt; contacts = new HashMap&lt;&gt;();

    public Profile(String email, String name, String... contacts) {
        this.email = email;
        this.name = name;

        // Parse contact list from a set of &quot;friend:email@gmail.com&quot; pairs.
        for (String contact : contacts) {
            String[] parts = contact.split(&quot;:&quot;);
            String contactType = &quot;friend&quot;, contactEmail;
            if (parts.length == 1) {
                contactEmail = parts[0];
            }
            else {
                contactType = parts[0];
                contactEmail = parts[1];
            }
            if (!this.contacts.containsKey(contactType)) {
                this.contacts.put(contactType, new ArrayList&lt;&gt;());
            }
            this.contacts.get(contactType).add(contactEmail);
        }
    }

    public String getEmail() {
        return email;
    }

    public String getName() {
        return name;
    }

    public List&lt;String&gt; getContacts(String contactType) {
        if (!this.contacts.containsKey(contactType)) {
            this.contacts.put(contactType, new ArrayList&lt;&gt;());
        }
        return contacts.get(contactType);
    }
}

</code></pre>
<h3 id="定义档案接口">定义档案接口</h3>
<pre><code>package com.iterator;

/**
 * 定义档案接口
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:34
 */
public interface ProfileIterator {
    boolean hasNext();

    Profile getNext();

    void reset();
}
</code></pre>
<h3 id="定义通用的社交网络接口">定义通用的社交网络接口</h3>
<pre><code>package com.iterator;

/**
 * 定义通用的社交网络接口
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:39
 */
public interface SocialNetwork {
    ProfileIterator createFriendsIterator(String profileEmail);

    ProfileIterator createCoworkersIterator(String profileEmail);
}
</code></pre>
<h3 id="facebook">Facebook</h3>
<pre><code>package com.iterator;

import java.util.ArrayList;
import java.util.List;

/**
 * Facebook
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:40
 */
public class Facebook implements SocialNetwork {
    private List&lt;Profile&gt; profiles;

    public Facebook(List&lt;Profile&gt; cache) {
        if (cache != null) {
            this.profiles = cache;
        } else {
            this.profiles = new ArrayList&lt;&gt;();
        }
    }

    public Profile requestProfileFromFacebook(String profileEmail) {
        // Here would be a POST request to one of the Facebook API endpoints.
        // Instead, we emulates long network connection, which you would expect
        // in the real life...
        simulateNetworkLatency();
        System.out.println(&quot;Facebook: Loading profile '&quot; + profileEmail + &quot;' over the network...&quot;);

        // ...and return test data.
        return findProfile(profileEmail);
    }

    public List&lt;String&gt; requestProfileFriendsFromFacebook(String profileEmail, String contactType) {
        // Here would be a POST request to one of the Facebook API endpoints.
        // Instead, we emulates long network connection, which you would expect
        // in the real life...
        simulateNetworkLatency();
        System.out.println(&quot;Facebook: Loading '&quot; + contactType + &quot;' list of '&quot; + profileEmail + &quot;' over the network...&quot;);

        // ...and return test data.
        Profile profile = findProfile(profileEmail);
        if (profile != null) {
            return profile.getContacts(contactType);
        }
        return null;
    }

    private Profile findProfile(String profileEmail) {
        for (Profile profile : profiles) {
            if (profile.getEmail().equals(profileEmail)) {
                return profile;
            }
        }
        return null;
    }

    private void simulateNetworkLatency() {
        try {
            Thread.sleep(2500);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
    }

    @Override
    public ProfileIterator createFriendsIterator(String profileEmail) {
        return new FacebookIterator(this, &quot;friends&quot;, profileEmail);
    }

    @Override
    public ProfileIterator createCoworkersIterator(String profileEmail) {
        return new FacebookIterator(this, &quot;coworkers&quot;, profileEmail);
    }
}
</code></pre>
<h3 id="在-facebook-档案上实现迭代">在 Facebook 档案上实现迭代</h3>
<pre><code>package com.iterator;

import java.util.ArrayList;
import java.util.List;

/**
 * 在 Facebook 档案上实现迭代
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:38
 */
public class FacebookIterator implements ProfileIterator {
    private Facebook facebook;
    private String type;
    private String email;
    private int currentPosition = 0;
    private List&lt;String&gt; emails = new ArrayList&lt;&gt;();
    private List&lt;Profile&gt; profiles = new ArrayList&lt;&gt;();

    public FacebookIterator(Facebook facebook, String type, String email) {
        this.facebook = facebook;
        this.type = type;
        this.email = email;
    }

    private void lazyLoad() {
        if (emails.size() == 0) {
            List&lt;String&gt; profiles = facebook.requestProfileFriendsFromFacebook(this.email, this.type);
            for (String profile : profiles) {
                this.emails.add(profile);
                this.profiles.add(null);
            }
        }
    }

    @Override
    public boolean hasNext() {
        lazyLoad();
        return currentPosition &lt; emails.size();
    }

    @Override
    public Profile getNext() {
        if (!hasNext()) {
            return null;
        }

        String friendEmail = emails.get(currentPosition);
        Profile friendProfile = profiles.get(currentPosition);
        if (friendProfile == null) {
            friendProfile = facebook.requestProfileFromFacebook(friendEmail);
            profiles.set(currentPosition, friendProfile);
        }
        currentPosition++;
        return friendProfile;
    }

    @Override
    public void reset() {
        currentPosition = 0;
    }
}
</code></pre>
<h3 id="在领英档案上实现迭代">在领英档案上实现迭代</h3>
<pre><code>package com.iterator;

import java.util.ArrayList;
import java.util.List;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:44
 */
public class LinkedInIterator implements ProfileIterator {
    private LinkedIn linkedIn;
    private String type;
    private String email;
    private int currentPosition = 0;
    private List&lt;String&gt; emails = new ArrayList&lt;&gt;();
    private List&lt;Profile&gt; contacts = new ArrayList&lt;&gt;();

    public LinkedInIterator(LinkedIn linkedIn, String type, String email) {
        this.linkedIn = linkedIn;
        this.type = type;
        this.email = email;
    }

    private void lazyLoad() {
        if (emails.size() == 0) {
            List&lt;String&gt; profiles = linkedIn.requestRelatedContactsFromLinkedInAPI(this.email, this.type);
            for (String profile : profiles) {
                this.emails.add(profile);
                this.contacts.add(null);
            }
        }
    }

    @Override
    public boolean hasNext() {
        lazyLoad();
        return currentPosition &lt; emails.size();
    }

    @Override
    public Profile getNext() {
        if (!hasNext()) {
            return null;
        }

        String friendEmail = emails.get(currentPosition);
        Profile friendContact = contacts.get(currentPosition);
        if (friendContact == null) {
            friendContact = linkedIn.requestContactInfoFromLinkedInAPI(friendEmail);
            contacts.set(currentPosition, friendContact);
        }
        currentPosition++;
        return friendContact;
    }

    @Override
    public void reset() {
        currentPosition = 0;
    }
}
</code></pre>
<h3 id="领英">领英</h3>
<pre><code>package com.iterator;

import java.util.ArrayList;
import java.util.List;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:42
 */
public class LinkedIn implements SocialNetwork {
    private List&lt;Profile&gt; contacts;

    public LinkedIn(List&lt;Profile&gt; cache) {
        if (cache != null) {
            this.contacts = cache;
        } else {
            this.contacts = new ArrayList&lt;&gt;();
        }
    }

    public Profile requestContactInfoFromLinkedInAPI(String profileEmail) {
        // Here would be a POST request to one of the LinkedIn API endpoints.
        // Instead, we emulates long network connection, which you would expect
        // in the real life...
        simulateNetworkLatency();
        System.out.println(&quot;LinkedIn: Loading profile '&quot; + profileEmail + &quot;' over the network...&quot;);

        // ...and return test data.
        return findContact(profileEmail);
    }

    public List&lt;String&gt; requestRelatedContactsFromLinkedInAPI(String profileEmail, String contactType) {
        // Here would be a POST request to one of the LinkedIn API endpoints.
        // Instead, we emulates long network connection, which you would expect
        // in the real life.
        simulateNetworkLatency();
        System.out.println(&quot;LinkedIn: Loading '&quot; + contactType + &quot;' list of '&quot; + profileEmail + &quot;' over the network...&quot;);

        // ...and return test data.
        Profile profile = findContact(profileEmail);
        if (profile != null) {
            return profile.getContacts(contactType);
        }
        return null;
    }

    private Profile findContact(String profileEmail) {
        for (Profile profile : contacts) {
            if (profile.getEmail().equals(profileEmail)) {
                return profile;
            }
        }
        return null;
    }

    private void simulateNetworkLatency() {
        try {
            Thread.sleep(2500);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
    }

    @Override
    public ProfileIterator createFriendsIterator(String profileEmail) {
        return new LinkedInIterator(this, &quot;friends&quot;, profileEmail);
    }

    @Override
    public ProfileIterator createCoworkersIterator(String profileEmail) {
        return new LinkedInIterator(this, &quot;coworkers&quot;, profileEmail);
    }
}
</code></pre>
<h3 id="消息发送应用">消息发送应用</h3>
<pre><code>package com.iterator;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:47
 */
public class SocialSpammer {
    public SocialNetwork network;
    public ProfileIterator iterator;

    public SocialSpammer(SocialNetwork network) {
        this.network = network;
    }

    public void sendSpamToFriends(String profileEmail, String message) {
        System.out.println(&quot;\nIterating over friends...\n&quot;);
        iterator = network.createFriendsIterator(profileEmail);
        while (iterator.hasNext()) {
            Profile profile = iterator.getNext();
            sendMessage(profile.getEmail(), message);
        }
    }

    public void sendSpamToCoworkers(String profileEmail, String message) {
        System.out.println(&quot;\nIterating over coworkers...\n&quot;);
        iterator = network.createCoworkersIterator(profileEmail);
        while (iterator.hasNext()) {
            Profile profile = iterator.getNext();
            sendMessage(profile.getEmail(), message);
        }
    }

    public void sendMessage(String email, String message) {
        System.out.println(&quot;Sent message to: '&quot; + email + &quot;'. Message body: '&quot; + message + &quot;'&quot;);
    }
}
</code></pre>
<h3 id="客户端代码">客户端代码</h3>
<pre><code>package com.iterator;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:50
 */
public class Demo {
    public static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println(&quot;Please specify social network to target spam tool (default:Facebook):&quot;);
        System.out.println(&quot;1. Facebook&quot;);
        System.out.println(&quot;2. LinkedIn&quot;);
        String choice = scanner.nextLine();

        SocialNetwork network;
        if (choice.equals(&quot;2&quot;)) {
            network = new LinkedIn(createTestProfiles());
        }
        else {
            network = new Facebook(createTestProfiles());
        }

        SocialSpammer spammer = new SocialSpammer(network);
        spammer.sendSpamToFriends(&quot;anna.smith@bing.com&quot;,
                &quot;Hey! This is Anna's friend Josh. Can you do me a favor and like this post [link]?&quot;);
        spammer.sendSpamToCoworkers(&quot;anna.smith@bing.com&quot;,
                &quot;Hey! This is Anna's boss Jason. Anna told me you would be interested in [link].&quot;);
    }

    public static List&lt;Profile&gt; createTestProfiles() {
        List&lt;Profile&gt; data = new ArrayList&lt;Profile&gt;();
        data.add(new Profile(&quot;anna.smith@bing.com&quot;, &quot;Anna Smith&quot;, &quot;friends:mad_max@ya.com&quot;, &quot;friends:catwoman@yahoo.com&quot;, &quot;coworkers:sam@amazon.com&quot;));
        data.add(new Profile(&quot;mad_max@ya.com&quot;, &quot;Maximilian&quot;, &quot;friends:anna.smith@bing.com&quot;, &quot;coworkers:sam@amazon.com&quot;));
        data.add(new Profile(&quot;bill@microsoft.eu&quot;, &quot;Billie&quot;, &quot;coworkers:avanger@ukr.net&quot;));
        data.add(new Profile(&quot;avanger@ukr.net&quot;, &quot;John Day&quot;, &quot;coworkers:bill@microsoft.eu&quot;));
        data.add(new Profile(&quot;sam@amazon.com&quot;, &quot;Sam Kitting&quot;, &quot;coworkers:anna.smith@bing.com&quot;, &quot;coworkers:mad_max@ya.com&quot;, &quot;friends:catwoman@yahoo.com&quot;));
        data.add(new Profile(&quot;catwoman@yahoo.com&quot;, &quot;Liza&quot;, &quot;friends:anna.smith@bing.com&quot;, &quot;friends:sam@amazon.com&quot;));
        return data;
    }
}
</code></pre>
<h3 id="执行结果">执行结果</h3>
<pre><code>Please specify social network to target spam tool (default:Facebook):
1. Facebook
2. LinkedIn
&gt; 1

Iterating over friends...

Facebook: Loading 'friends' list of 'anna.smith@bing.com' over the network...
Facebook: Loading profile 'mad_max@ya.com' over the network...
Sent message to: 'mad_max@ya.com'. Message body: 'Hey! This is Anna's friend Josh. Can you do me a favor and like this post [link]?'
Facebook: Loading profile 'catwoman@yahoo.com' over the network...
Sent message to: 'catwoman@yahoo.com'. Message body: 'Hey! This is Anna's friend Josh. Can you do me a favor and like this post [link]?'

Iterating over coworkers...

Facebook: Loading 'coworkers' list of 'anna.smith@bing.com' over the network...
Facebook: Loading profile 'sam@amazon.com' over the network...
Sent message to: 'sam@amazon.com'. Message body: 'Hey! This is Anna's boss Jason. Anna told me you would be interested in [link].'
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从PAXOS到ZOOKEEPER分布式一致性原理与实践]]></title>
        <id>https://q456qq520.github.io/post/cong-paxos-dao-zookeeper-fen-bu-shi-yi-zhi-xing-yuan-li-yu-shi-jian/</id>
        <link href="https://q456qq520.github.io/post/cong-paxos-dao-zookeeper-fen-bu-shi-yi-zhi-xing-yuan-li-yu-shi-jian/">
        </link>
        <updated>2022-03-11T01:50:43.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Domain Drive Design（领域驱动设计）]]></title>
        <id>https://q456qq520.github.io/post/domain-drive-designling-yu-qu-dong-she-ji/</id>
        <link href="https://q456qq520.github.io/post/domain-drive-designling-yu-qu-dong-she-ji/">
        </link>
        <updated>2022-03-10T06:23:54.000Z</updated>
        <content type="html"><![CDATA[<p>Domain Drive Design（领域驱动设计）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[重试组件]]></title>
        <id>https://q456qq520.github.io/post/chong-shi-zu-jian/</id>
        <link href="https://q456qq520.github.io/post/chong-shi-zu-jian/">
        </link>
        <updated>2022-03-10T06:22:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="什么重试机制">什么重试机制？</h1>
<p><strong>重试是为了提高成功的可能性</strong></p>
<p>反过来理解，任何可能失败且允许重试操作的场景，就适合使用重试机制。但有了重试机制就一定能成功吗？显然不是。如果不成功就一直重试，这种处理方式会使得业务线程一直被重试占用，这样会导致服务的负载线程暴增直至服务宕机，因此需要限制重试次数。失败情况下，我们需要做后续的操作，如果是数据库操作的重试，需要回滚事物；如果是服务调用的重试，需要邮件报警通知运维开发人员，恢复服务。</p>
<p>对于服务接口调用，可能是因为网络波动导致超时失败，这时候所有重试次数是在很短时间内发起的话，就很容易全部超时失败，因此超时机制还需要引入重试动作之间时间间隔以及第一次失败后延迟多长时间再开始重试等机制。</p>
<p>重试机制要素</p>
<pre><code>- 限制重试次数
- 每次重试的时间间隔
- 最终失败结果的报警或事物回滚
- 在特定失败异常事件情况下选择重试
</code></pre>
<h1 id="背景介绍">背景介绍</h1>
<p>在实际的项目应用场景中，经常会需要遇到远程服务接口的调用，时不时会出现一些接口调用超时，或者函数执行失败需要重试的情况，例如下边的这种场景：</p>
<pre><code>某些不太稳定的接口，需要依赖于第三方的远程调用，例如数据加载，数据上传相关的类型。
</code></pre>
<h1 id="基于trycatch的重试方案">基于try/catch的重试方案</h1>
<p>这种方式来做重试处理的话，会比较简单粗暴。</p>
<pre><code> public void test(){
    try{
        //执行远程调用方法
        doRef();
    }catch(Exception e){
        //重新执行远程调用方法
        doRef();
    }
}
</code></pre>
<p>当出现了异常的时候，立即执行远程调用，此时可能忽略了几个问题：</p>
<ol>
<li>如果重试出现了问题，是否还能继续重试</li>
<li>第一次远程调用出现了异常，此时可能第三方服务此时负载已达到瓶颈，或许需要间隔一段时间再发送远程调用的成功率会高些。</li>
<li>多次重试都失败之后如何通知调用方自己。</li>
</ol>
<h1 id="使用spring的retry组件">使用Spring的Retry组件</h1>
<ol>
<li>引入依赖</li>
</ol>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;
    &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>在启动类上加入一个@EnableRetry注解</li>
</ol>
<pre><code>@SpringBootApplication
@EnableRetry
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class);
    }
}
</code></pre>
<ol start="3">
<li>在需要被执行的函数头部加入这一@Retryable注解</li>
</ol>
<pre><code>@Retryable(value = Exception.class,maxAttempts = 3  , backoff = @Backoff(delay = 2000,multiplier = 1.5))
public int retryServiceOne(int code) throws Exception {
	// TODO Auto-generated method stub 
	System.out.println(&quot;retryServiceOne被调用,时间：&quot;+LocalTime.now());
	System.out.println(&quot;执行当前业务逻辑的线程名：&quot;+Thread.currentThread().getName());
	if (code==0){
	    throw new Exception(&quot;业务执行失败情况！&quot;);
	}
	System.out.println(&quot;retryServiceOne执行成功！&quot;);

	return 200;
}
</code></pre>
<p>配置元数据情况：</p>
<pre><code>- 重试次数为3
- 第一次重试延迟2s
- 每次重试时间间隔是前一次1.5倍
- Exception类异常情况下重试
</code></pre>
<h1 id="自定义重试组件">自定义重试组件</h1>
<ol>
<li>定义一个重试注解</li>
</ol>
<pre><code>package com.likecat.retry;

import java.lang.annotation.*;

/**
 * 重试组件注解
 * @author likecat
 * @version 1.0
 * @date 2022/3/11 11:41
 */
@Documented
@Target(value = ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Retry {
    //最大重试次数
    int maxAttempts() default 3;

    //每次重试的间隔时间
    int delay() default 3000;

    //关注异常（仅当抛出了相应异常的条件下才会重试）
    Class&lt;? extends Throwable&gt;[] value() default {};

    //重试策略（默认是快速重试）
    Class&lt;? extends RetryStrategy&gt; strategy() default FastRetryStrategy.class;

    //重试监听器
    Class&lt;? extends RetryListener&gt; listener() default AbstractRetryListener.class;
}
</code></pre>
<ol start="2">
<li>重试切面,拦截带有 @Retry 注解的方法，然后将需要执行的部分放入到一个RetryTask类型的对象当中，内部的doTask函数会触发真正的方法调用。</li>
</ol>
<pre><code>package com.likecat.retry;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.lang.reflect.Method;

/**
 * 重试接口的拦截和处理
 * @author likecat
 * @version 1.0
 * @date 2022/3/11 11:50
 */
@Aspect
@Component
public class RetryAop {

    @Resource
    private ApplicationContext applicationContext;

    @Pointcut(&quot;@annotation(com.likecat.retry.Retry)&quot;)
    public void pointCut() {
    }

    @Around(value = &quot;pointCut()&quot;)
    public Object doBiz(ProceedingJoinPoint point) {
        MethodSignature methodSignature = (MethodSignature) point.getSignature();
        Method method = methodSignature.getMethod();
        Retry retry = method.getDeclaredAnnotation(Retry.class);

        //获取重试策略
        RetryStrategy retryStrategy = applicationContext.getBean(retry.strategy());
        RetryTask retryTask = new RetryTaskImpl(point);
        retryStrategy.initArgs(retry, retryTask);
        try {
            Object result = point.proceed();
            return result;
        } catch (Throwable throwable) {
            //重试
            System.out.println(method.getName()+&quot;执行失败,开始重试&quot;);
            retryStrategy.retryTask();
        }
        return null;
    }

    /**
     * 重试业务
     */
    private class RetryTaskImpl implements RetryTask {
        private ProceedingJoinPoint proceedingJoinPoint;
        private Object result;
        private volatile Boolean asyncRetryState = null;
        public RetryTaskImpl(ProceedingJoinPoint proceedingJoinPoint) {
            this.proceedingJoinPoint = proceedingJoinPoint;
        }
        public ProceedingJoinPoint getProceedingJoinPoint() {
            return proceedingJoinPoint;
        }
        public void setProceedingJoinPoint(ProceedingJoinPoint proceedingJoinPoint) {
            this.proceedingJoinPoint = proceedingJoinPoint;
        }
        public Object getResult() {
            return result;
        }
        public void setResult(Object result) {
            this.result = result;
        }
        public Boolean getAsyncRetryState() {
            return asyncRetryState;
        }
        public void setAsyncRetryState(Boolean asyncRetryState) {
            this.asyncRetryState = asyncRetryState;
        }

        @Override
        public Object getRetryResult() {
            return result;
        }
        @Override
        public Boolean getRetryStatus() {
            return asyncRetryState;
        }
        @Override
        public void setRetrySuccess() {
            this.setAsyncRetryState(true);
        }
        @Override
        public void doTask() throws Throwable {
            this.result = proceedingJoinPoint.proceed();
        }
    }
}

</code></pre>
<ol start="3">
<li>RetryTask接口(重试任务)</li>
</ol>
<pre><code>package com.likecat.retry;

/**
 * 任务执行
 * @author likecat
 * @version 1.0
 * @date 2022/3/11 11:46
 */
public interface RetryTask {

    //获取重试结果
    Object getRetryResult();

    //获取重试状态
    Boolean getRetryStatus();

    void setRetrySuccess();

    //重试逻辑
    void doTask() throws Throwable;
}
</code></pre>
<ol start="4">
<li>重试策略接口</li>
</ol>
<pre><code>package com.likecat.retry;

/**
 * 重试策略
 * @author likecat
 * @version 1.0
 * @date 2022/3/11 11:41
 */
public interface RetryStrategy {

    /**
     * 初始化一些参数配置
     *
     * @param retry
     * @param retryTask
     */
    void initArgs(Retry retry,RetryTask retryTask);

    /**
     * 重试策略
     */
    void retryTask();

}

</code></pre>
<ol start="5">
<li>默认的重试策略为快速重试策略</li>
</ol>
<pre><code>package com.likecat.retry;

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

import java.util.concurrent.ExecutorService;

/**
 * 默认的重试策略为快速重试策略
 * @author likecat
 * @version 1.0
 * @date 2022/3/11 11:42
 */
public class FastRetryStrategy implements RetryStrategy, ApplicationContextAware {

    private Retry retry;
    private RetryTask retryTask;
    private ApplicationContext applicationContext;
    private ExecutorService retryThreadPool;

    public FastRetryStrategy() {
    }

    public ExecutorService getRetryThreadPool() {
        return retryThreadPool;
    }

    public void setRetryThreadPool(ExecutorService retryThreadPool) {
        this.retryThreadPool = retryThreadPool;
    }

    @Override
    public void initArgs(Retry retry, RetryTask retryTask) {
        this.retry = retry;
        this.retryTask = retryTask;
    }

    @Override
    public void retryTask() {
        if (!FastRetryStrategy.class.equals(retry.strategy())) {
            System.err.println(&quot;error retry strategy&quot;);
            return;
        }
        //安全类型bean查找
        String[] beanNames = applicationContext.getBeanNamesForType(retry.listener());
        RetryListener retryListener = null;
        if (beanNames != null &amp;&amp; beanNames.length &gt; 0) {
            retryListener = applicationContext.getBean(retry.listener());
        }
        Class&lt;? extends Throwable&gt;[] exceptionClasses = retry.value();
        RetryListener finalRetryListener = retryListener;
        //如果没有支持异步功能，那么在进行重试的时候就会一直占用着服务器的业务线程，导致服务器线程负载暴增
        retryThreadPool.submit(new Runnable() {
            @Override
            public void run() {
                for (int i = 1; i &lt;= retry.maxAttempts(); i++) {
                    int finalI = i;
                    try {
                        retryTask.doTask();
                        retryTask.setRetrySuccess();
                        return;
                    } catch (Throwable e) {
                        for (Class&lt;? extends Throwable&gt; clazz : exceptionClasses) {
                            if (e.getClass().equals(clazz) || e.getClass().isInstance(clazz)) {
                                if (finalRetryListener != null) {
                                    finalRetryListener.notifyObserver();
                                }
                                System.err.println(&quot;[FastRetryStrategy] retry again,attempt's time is &quot; + finalI + &quot;,tims is &quot; + System.currentTimeMillis());
                                try {
                                    Thread.sleep(retry.delay());
                                } catch (InterruptedException ex) {
                                    ex.printStackTrace();
                                }
                                continue;
                            }
                        }
                    }
                }
            }
        });
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
        ExecutorService executorService = (ExecutorService) applicationContext.getBean(&quot;retryThreadPool&quot;);
        this.setRetryThreadPool(executorService);
    }

}
</code></pre>
<ol start="6">
<li>通过回调对应的监听器组件做一些记录：例如日志记录，操作记录写入等等操作。</li>
</ol>
<pre><code>package com.likecat.retry;

/**
 * 通知观察者
 * @author likecat
 * @version 1.0
 * @date 2022/3/11 11:46
 */
public interface RetryListener {

    /**
     * 通知观察者
     */
    void notifyObserver();
}

</code></pre>
<ol start="7">
<li>默认抽象类</li>
</ol>
<pre><code>package com.likecat.retry;

/**
 * 默认抽象类
 * @author likecat
 * @version 1.0
 * @date 2022/3/11 11:47
 */
public abstract class AbstractRetryListener implements RetryListener {
    @Override
    public abstract void notifyObserver();
}
</code></pre>
<ol start="8">
<li>自定义监听器</li>
</ol>
<pre><code>package com.likecat.retry;

/**
 * 默认监听器
 * @author likecat
 * @version 1.0
 * @date 2022/3/11 11:47
 */
public class DefaultRetryListener implements RetryListener{

    @Override
    public void notifyObserver() {
        System.out.println(&quot;this is a DefaultRetryListener&quot;);
    }
}
</code></pre>
<ol start="9">
<li>bean的初始化配置</li>
</ol>
<pre><code>package com.likecat.retry;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/11 14:45
 */
@Configuration
public class RetryConfig {
    @Bean
    public FastRetryStrategy fastRetryStrategy(){
        return new FastRetryStrategy();
    }
    @Bean
    public RetryListener defaultRetryListener(){
        return new DefaultRetryListener();
    }
    @Bean
    public ExecutorService retryThreadPool(){
        ExecutorService executorService = new ThreadPoolExecutor(2,4,0L, TimeUnit.SECONDS,new LinkedBlockingQueue&lt;&gt;());
        return executorService;
    }
}
</code></pre>
<ol start="9">
<li>测试</li>
</ol>
<pre><code>package com.likecat.retry;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/11 14:42
 */
@RestController
public class TestController {

    public static int count = 0;

    @Retry(maxAttempts = 5, delay = 100, value = {ArithmeticException.class}, strategy = FastRetryStrategy.class, listener = DefaultRetryListener.class)
    @GetMapping(value = &quot;/do-test&quot;)
    public String doTest(int code) {
        count++;
        System.out.println(&quot;code is :&quot; + code + &quot; result is :&quot; + count % 3 + &quot; count is :&quot; + count);
        if (code == 1) {
            System.out.println(&quot;--this is a test&quot;);
        } else {
            if (count % 5 != 0) {
                System.out.println(4 / 0);
            }
        }
        return &quot;success&quot;;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[命令模式]]></title>
        <id>https://q456qq520.github.io/post/fen-bu-shi-gong-shi-cun-yi-qiu-tong/</id>
        <link href="https://q456qq520.github.io/post/fen-bu-shi-gong-shi-cun-yi-qiu-tong/">
        </link>
        <updated>2022-03-08T01:54:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="意图">意图</h1>
<p><strong>命令模式</strong>是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。</p>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/content/command/command-zh-2x.png" alt="likecat" loading="lazy"></figure>
<h1 id="问题">问题</h1>
<p>假如你正在开发一款新的文字编辑器， 当前的任务是创建一个包含多个按钮的工具栏， 并让每个按钮对应编辑器的不同操作。 你创建了一个非常简洁的按钮类， 它不仅可用于生成工具栏上的按钮， 还可用于生成各种对话框的通用按钮。</p>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/command/problem1-2x.png" alt="应用中的所有按钮都可以继承相同的类" loading="lazy"></figure>
<p>尽管所有按钮看上去都很相似， 但它们可以完成不同的操作 （打开、 保存、 打印和应用等）。 你会在哪里放置这些按钮的点击处理代码呢？ 最简单的解决方案是在使用按钮的每个地方都创建大量的子类。 这些子类中包含按钮点击后必须执行的代码。</p>
<figure data-type="image" tabindex="3"><img src="https://refactoringguru.cn/images/patterns/diagrams/command/problem2-2x.png" alt="大量的按钮子类" loading="lazy"></figure>
<p>你很快就意识到这种方式有严重缺陷。 首先， 你创建了大量的子类， 当每次修改基类 按钮时， 你都有可能需要修改所有子类的代码。 简单来说， GUI 代码以一种拙劣的方式依赖于业务逻辑中的不稳定代码。</p>
<figure data-type="image" tabindex="4"><img src="https://refactoringguru.cn/images/patterns/diagrams/command/problem3-zh-2x.png" alt="大量的按钮子类" loading="lazy"></figure>
<p>还有一个部分最难办。 复制/粘贴文字等操作可能会在多个地方被调用。 例如用户可以点击工具栏上小小的 “复制” 按钮， 或者通过上下文菜单复制一些内容， 又或者直接使用键盘上的 Ctrl+C 。</p>
<p>我们的程序最初只有工具栏， 因此可以使用按钮子类来实现各种不同操作。 换句话来说， ​ 复制按钮Copy­Button子类包含复制文字的代码是可行的。 在实现了上下文菜单、 快捷方式和其他功能后， 你要么需要将操作代码复制进许多个类中， 要么需要让菜单依赖于按钮， 而后者是更糟糕的选择。</p>
<h1 id="解决方案">解决方案</h1>
<p>优秀的软件设计通常会将关注点进行分离， 而这往往会导致软件的分层。 最常见的例子： 一层负责用户图像界面； 另一层负责业务逻辑。 GUI 层负责在屏幕上渲染美观的图形， 捕获所有输入并显示用户和程序工作的结果。 当需要完成一些重要内容时 （比如计算月球轨道或撰写年度报告）， GUI 层则会将工作委派给业务逻辑底层。</p>
<p>这在代码中看上去就像这样： 一个 GUI 对象传递一些参数来调用一个业务逻辑对象。 这个过程通常被描述为一个对象发送请求给另一个对象。</p>
<figure data-type="image" tabindex="5"><img src="https://refactoringguru.cn/images/patterns/diagrams/command/solution1-zh-2x.png" alt="GUI 层可以直接访问业务逻辑层。" loading="lazy"></figure>
<p>命令模式建议 GUI 对象不直接提交这些请求。 你应该将请求的所有细节 （例如调用的对象、 方法名称和参数列表） 抽取出来组成命令类， 该类中仅包含一个用于触发请求的方法。</p>
<p>命令对象负责连接不同的 GUI 和业务逻辑对象。 此后， GUI 对象无需了解业务逻辑对象是否获得了请求， 也无需了解其对请求进行处理的方式。 GUI 对象触发命令即可， 命令对象会自行处理所有细节工作。</p>
<figure data-type="image" tabindex="6"><img src="https://refactoringguru.cn/images/patterns/diagrams/command/solution2-zh-2x.png" alt="通过命令访问业务逻辑层。" loading="lazy"></figure>
<p>下一步是让所有命令实现相同的接口。 该接口通常只有一个没有任何参数的执行方法， 让你能在不和具体命令类耦合的情况下使用同一请求发送者执行不同命令。 此外还有额外的好处， 现在你能在运行时切换连接至发送者的命令对象， 以此改变发送者的行为。</p>
<p>你可能会注意到遗漏的一块拼图——请求的参数。 GUI 对象可以给业务层对象提供一些参数。 但执行命令方法没有任何参数， 所以我们如何将请求的详情发送给接收者呢？ 答案是： 使用数据对命令进行预先配置， 或者让其能够自行获取数据。</p>
<figure data-type="image" tabindex="7"><img src="https://refactoringguru.cn/images/patterns/diagrams/command/solution3-zh-2x.png" alt="GUI 对象将命令委派给命令对象。" loading="lazy"></figure>
<p>让我们回到文本编辑器。 应用命令模式后， 我们不再需要任何按钮子类来实现点击行为。 我们只需在 按钮Button基类中添加一个成员变量来存储对于命令对象的引用， 并在点击后执行该命令即可。</p>
<p>你需要为每个可能的操作实现一系列命令类， 并且根据按钮所需行为将命令和按钮连接起来。</p>
<p>其他菜单、 快捷方式或整个对话框等 GUI 元素都可以通过相同方式来实现。 当用户与 GUI 元素交互时， 与其连接的命令将会被执行。 现在你很可能已经猜到了， 与相同操作相关的元素将会被连接到相同的命令， 从而避免了重复代码。</p>
<p>最后， 命令成为了减少 GUI 和业务逻辑层之间耦合的中间层。 而这仅仅是命令模式所提供的一小部分好处！</p>
<h1 id="真实世界类比">真实世界类比</h1>
<p>在市中心逛了很久的街后， 你找到了一家不错的餐厅， 坐在了临窗的座位上。 一名友善的服务员走近你， 迅速记下你点的食物， 写在一张纸上。 服务员来到厨房， 把订单贴在墙上。 过了一段时间， 厨师拿到了订单， 他根据订单来准备食物。 厨师将做好的食物和订单一起放在托盘上。 服务员看到托盘后对订单进行检查， 确保所有食物都是你要的， 然后将食物放到了你的桌上。</p>
<p>那张纸就是一个命令， 它在厨师开始烹饪前一直位于队列中。 命令中包含与烹饪这些食物相关的所有信息。 厨师能够根据它马上开始烹饪， 而无需跑来直接和你确认订单详情。</p>
<h1 id="命令模式结构">命令模式结构</h1>
<figure data-type="image" tabindex="8"><img src="https://refactoringguru.cn/images/patterns/diagrams/command/structure-2x.png" alt="likecat" loading="lazy"></figure>
<ol>
<li>
<p><strong>发送者 （Sender）</strong>——亦称 “触发者 （Invoker）”——类负责对请求进行初始化， 其中必须包含一个成员变量来存储对于命令对象的引用。 发送者触发命令， 而不向接收者直接发送请求。 注意， 发送者并不负责创建命令对象： 它通常会通过构造函数从客户端处获得预先生成的命令。</p>
</li>
<li>
<p><strong>命令 （Command）</strong> 接口通常仅声明一个执行命令的方法。</p>
</li>
<li>
<p><strong>具体命令 （Concrete Commands）</strong> 会实现各种类型的请求。 具体命令自身并不完成工作， 而是会将调用委派给一个业务逻辑对象。 但为了简化代码， 这些类可以进行合并。</p>
</li>
<li>
<p><strong>接收者 （Receiver）</strong> 类包含部分业务逻辑。 几乎任何对象都可以作为接收者。 绝大部分命令只处理如何将请求传递到接收者的细节， 接收者自己会完成实际的工作。</p>
</li>
<li>
<p><strong>客户端 （Client）</strong> 会创建并配置具体命令对象。 客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。 此后， 生成的命令就可以与一个或多个发送者相关联了。</p>
</li>
</ol>
<h2 id="命令模式适合应用场景">命令模式适合应用场景</h2>
<ol>
<li>
<p>如果你需要通过操作来参数化对象， 可使用命令模式。</p>
<p>命令模式可将特定的方法调用转化为独立对象。 这一改变也带来了许多有趣的应用： 你可以将命令作为方法的参数进行传递、 将命令保存在其他对象中， 或者在运行时切换已连接的命令等。</p>
<p>举个例子： 你正在开发一个 GUI 组件 （例如上下文菜单）， 你希望用户能够配置菜单项， 并在点击菜单项时触发操作。</p>
</li>
<li>
<p>如果你想要将操作放入队列中、 操作的执行或者远程执行操作， 可使用命令模式。</p>
<p>同其他对象一样， 命令也可以实现序列化 （序列化的意思是转化为字符串）， 从而能方便地写入文件或数据库中。 一段时间后， 该字符串可被恢复成为最初的命令对象。 因此， 你可以延迟或计划命令的执行。 但其功能远不止如此！ 使用同样的方式， 你还可以将命令放入队列、 记录命令或者通过网络发送命令。</p>
</li>
<li>
<p>如果你想要实现操作回滚功能， 可使用命令模式。</p>
<p>尽管有很多方法可以实现撤销和恢复功能， 但命令模式可能是其中最常用的一种。</p>
<p>为了能够回滚操作， 你需要实现已执行操作的历史记录功能。 命令历史记录是一种包含所有已执行命令对象及其相关程序状态备份的栈结构。</p>
<p>这种方法有两个缺点。 首先， 程序状态的保存功能并不容易实现， 因为部分状态可能是私有的。 你可以使用备忘录模式来在一定程度上解决这个问题。</p>
<p>其次， 备份状态可能会占用大量内存。 因此， 有时你需要借助另一种实现方式： 命令无需恢复原始状态， 而是执行反向操作。 反向操作也有代价： 它可能会很难甚至是无法实现。</p>
</li>
</ol>
<h1 id="实现方式">实现方式</h1>
<ol>
<li>
<p>声明仅有一个执行方法的命令接口。</p>
</li>
<li>
<p>抽取请求并使之成为实现命令接口的具体命令类。 每个类都必须有一组成员变量来保存请求参数和对于实际接收者对象的引用。 所有这些变量的数值都必须通过命令构造函数进行初始化。</p>
</li>
<li>
<p>找到担任发送者职责的类。 在这些类中添加保存命令的成员变量。 发送者只能通过命令接口与其命令进行交互。 发送者自身通常并不创建命令对象， 而是通过客户端代码获取。</p>
</li>
<li>
<p>修改发送者使其执行命令， 而非直接将请求发送给接收者。</p>
</li>
<li>
<p>客户端必须按照以下顺序来初始化对象：</p>
<ol>
<li>
<p>创建接收者。</p>
</li>
<li>
<p>创建命令， 如有需要可将其关联至接收者。</p>
</li>
<li>
<p>创建发送者并将其与特定命令关联。</p>
</li>
</ol>
</li>
</ol>
<h1 id="命令模式优缺点">命令模式优缺点</h1>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>单一职责原则。 你可以解耦触发和执行操作的类。</td>
<td style="text-align:center">代码可能会变得更加复杂， 因为你在发送者和接收者之间增加了一个全新的层次。</td>
</tr>
<tr>
<td>开闭原则。 你可以在不修改已有客户端代码的情况下在程序中创建新的命令。</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>你可以实现撤销和恢复功能。</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>你可以实现操作的延迟执行。</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>你可以将一组简单命令组合成一个复杂命令。</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h1 id="与其他模式的关系">与其他模式的关系</h1>
<ol>
<li>
<p><strong>责任链模式</strong>、 <strong>命令模式</strong>、 <strong>中介者模式</strong>和<strong>观察者模式</strong>用于处理请求发送者和接收者之间的不同连接方式：</p>
<ol>
<li>责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。</li>
<li>命令在发送者和请求者之间建立单向连接。</li>
<li>中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。</li>
<li>观察者允许接收者动态地订阅或取消接收请求。</li>
</ol>
</li>
<li>
<p><strong>责任链</strong>的管理者可使用<strong>命令模式</strong>实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。</p>
<p>还有另外一种实现方式， 那就是请求自身就是一个命令对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。</p>
</li>
<li>
<p>你可以同时使用<strong>命令</strong>和<strong>备忘录模式</strong>来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态。</p>
</li>
<li>
<p><strong>命令</strong>和<strong>策略模式</strong>看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。</p>
<p>你可以使用命令来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。</p>
<p>另一方面， 策略通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。</p>
</li>
<li>
<p><strong>原型模式</strong>可用于保存命令的历史记录。</p>
</li>
<li>
<p>你可以将<strong>访问者模式</strong>视为<strong>命令模式</strong>的加强版本， 其对象可对不同类的多种对象执行操作。</p>
</li>
</ol>
<h1 id="伪代码">伪代码</h1>
<h2 id="文字编辑器和撤销">文字编辑器和撤销</h2>
<p>本例中的文字编辑器在每次用户与其互动时， 都会创建一个新的命令对象。 命令执行其行为后会被压入历史堆栈。</p>
<p>现在， 当程序执行撤销操作时， 它就需要从历史记录中取出最近执行的命令， 然后执行反向操作或者恢复由该命令保存的编辑器历史状态。</p>
<h3 id="抽象基础命令">抽象基础命令</h3>
<pre><code>package com.command;

/**
 * 抽象基础命令
 * @author likecat
 * @version 1.0
 * @date 2022/3/9 17:43
 */
public abstract class Command {
    public Editor editor;
    private String backup;

    Command(Editor editor) {
        this.editor = editor;
    }

    void backup() {
        backup = editor.textField.getText();
    }

    public void undo() {
        editor.textField.setText(backup);
    }

    public abstract boolean execute();
}

</code></pre>
<h3 id="文字编辑器的-gui">文字编辑器的 GUI</h3>
<pre><code>package com.command;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

/**
 * 文字编辑器的 GUI
 * @author likecat
 * @version 1.0
 * @date 2022/3/9 17:43
 */
public class Editor {
    public JTextArea textField;
    public String clipboard;

    private CommandHistory history = new CommandHistory();

    public void init() {
        JFrame frame = new JFrame(&quot;Text editor (type &amp; use buttons, Luke!)&quot;);
        JPanel content = new JPanel();
        frame.setContentPane(content);
        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        content.setLayout(new BoxLayout(content, BoxLayout.Y_AXIS));
        textField = new JTextArea();
        textField.setLineWrap(true);
        content.add(textField);
        JPanel buttons = new JPanel(new FlowLayout(FlowLayout.CENTER));
        JButton ctrlC = new JButton(&quot;Ctrl+C&quot;);
        JButton ctrlX = new JButton(&quot;Ctrl+X&quot;);
        JButton ctrlV = new JButton(&quot;Ctrl+V&quot;);
        JButton ctrlZ = new JButton(&quot;Ctrl+Z&quot;);
        Editor editor = this;
        ctrlC.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                executeCommand(new CopyCommand(editor));
            }
        });
        ctrlX.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                executeCommand(new CutCommand(editor));
            }
        });
        ctrlV.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                executeCommand(new PasteCommand(editor));
            }
        });
        ctrlZ.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                undo();
            }
        });
        buttons.add(ctrlC);
        buttons.add(ctrlX);
        buttons.add(ctrlV);
        buttons.add(ctrlZ);
        content.add(buttons);
        frame.setSize(450, 200);
        frame.setLocationRelativeTo(null);
        frame.setVisible(true);
    }

    private void executeCommand(Command command) {
        if (command.execute()) {
            history.push(command);
        }
    }

    private void undo() {
        if (history.isEmpty()) return;

        Command command = history.pop();
        if (command != null) {
            command.undo();
        }
    }
}


</code></pre>
<h3 id="将所选文字复制到剪贴板">将所选文字复制到剪贴板</h3>
<pre><code>package com.command;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/9 17:45
 */
public class CopyCommand extends Command{
    public CopyCommand(Editor editor) {
        super(editor);
    }

    @Override
    public boolean execute() {
        editor.clipboard = editor.textField.getSelectedText();
        return false;
    }
}


</code></pre>
<h3 id="从剪贴板粘贴文字">从剪贴板粘贴文字</h3>
<pre><code>package com.command;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/9 17:46
 */
public class PasteCommand extends Command {

    public PasteCommand(Editor editor) {
        super(editor);
    }

    @Override
    public boolean execute() {
        if (editor.clipboard == null || editor.clipboard.isEmpty()) return false;

        backup();
        editor.textField.insert(editor.clipboard, editor.textField.getCaretPosition());
        return true;
    }
}

</code></pre>
<h3 id="将文字剪切到剪贴板">将文字剪切到剪贴板</h3>
<pre><code>package com.command;

/**
 *将文字剪切到剪贴板
 * @author likecat
 * @version 1.0
 * @date 2022/3/9 17:47
 */
public class CutCommand extends Command {

    public CutCommand(Editor editor) {
        super(editor);
    }

    @Override
    public boolean execute() {
        if (editor.textField.getSelectedText().isEmpty()) return false;

        backup();
        String source = editor.textField.getText();
        editor.clipboard = editor.textField.getSelectedText();
        editor.textField.setText(cutString(source));
        return true;
    }

    private String cutString(String source) {
        String start = source.substring(0, editor.textField.getSelectionStart());
        String end = source.substring(editor.textField.getSelectionEnd());
        return start + end;
    }
}


</code></pre>
<h3 id="命令历史">命令历史</h3>
<pre><code>package com.command;

import java.util.Stack;

/**
 * 命令历史
 * @author likecat
 * @version 1.0
 * @date 2022/3/9 17:48
 */
public class CommandHistory {
    private Stack&lt;Command&gt; history = new Stack&lt;&gt;();

    public void push(Command c) {
        history.push(c);
    }

    public Command pop() {
        return history.pop();
    }

    public boolean isEmpty() { return history.isEmpty(); }
}

</code></pre>
<h3 id="客户端代码">客户端代码</h3>
<pre><code>package com.command;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/9 17:49
 */
public class Demo {

    public static void main(String[] args) {
        Editor editor = new Editor();
        editor.init();
    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分布式事务Allornothing]]></title>
        <id>https://q456qq520.github.io/post/fen-bu-shi-shi-wu-allornothing/</id>
        <link href="https://q456qq520.github.io/post/fen-bu-shi-shi-wu-allornothing/">
        </link>
        <updated>2022-03-08T01:54:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="all-or-nothing">All or nothing</h1>
<h1 id="什么是分布式事务">什么是分布式事务？</h1>
<p>要想理解分布式事务，我们首先来看一下什么是事务。</p>
<p>事务，其实是包含一系列操作的、一个有边界的工作序列，有明确的开始和结束标志，且要么被完全执行，要么完全失败，即 all or nothing。通常情况下，我们所说的事务指的都是本地事务，也就是在单机上的事务。</p>
<p>而分布式事务，就是在分布式系统中运行的事务，由多个本地事务组合而成。在分布式场景下，对事务的处理操作可能来自不同的机器，甚至是来自不同的操作系统。</p>
<p>要深入理解分布式事务，我们首先需要了解它的特征。分布式事务是多个事务的组合，那么事务的特征 ACID，也是分布式事务的基本特征，其中 ACID 具体含义如下：</p>
<pre><code>1. 原子性（Atomicity），即事务最终的状态只有两种，全部执行成功和全部不执行。若处理事务的任何一项操作不成功，就会导致整个事务失败。一旦操作失败，所有操作都会被取消（即回滚），使得事务仿佛没有被执行过一样。

2. 一致性（Consistency），是指事务操作前和操作后，数据的完整性保持一致或满足完整性约束。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加200 元 ; 一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况 (该情况，用户 A 和 B 均为 600 元，总共 1200 元)。

3. 隔离性（Isolation），是指当系统内有多个事务并发执行时，多个事务不会相互干扰，
</code></pre>
<p>即一个事务内部的操作及使用的数据，对其他并发事务是隔离的。</p>
<pre><code>4. 持久性（Durability），也被称为永久性，是指一个事务完成了，那么它对数据库所做的更新就被永久保存下来了。即使发生系统崩溃或宕机等故障，只要数据库能够重新被访问，那么一定能够将其恢复到事务完成时的状态。
</code></pre>
<p>分布式事务基本能够满足 ACID，其中的 C 是强一致性，也就是所有操作均执行成功，才提交最终结果，以保证数据一致性或完整性。但随着分布式系统规模不断扩大，复杂度急剧上升，达成强一致性所需时间周期较长，限定了复杂业务的处理。为了适应复杂业务，出现了BASE 理论，该理论的一个关键点就是采用最终一致性代替强一致性。</p>
<h1 id="如何实现分布式事务">如何实现分布式事务？</h1>
<p>分布式事务主要是解决在分布式环境下，组合事务的一致性问题。实现分布式事务有以下 3 种基本方法：</p>
<pre><code>- 基于 XA 协议的二阶段提交协议方法；
- 三阶段提交协议方法；
- 基于消息的最终一致性方法。
</code></pre>
<p>其中，基于 XA 协议的二阶段提交协议方法和三阶段提交协议方法，采用了强一致性，遵从ACID，基于消息的最终一致性方法，采用了最终一致性，遵从 BASE 理论。</p>
<h1 id="什么是-base-理论">什么是 BASE 理论</h1>
<p>刚性事务，遵循 ACID 原则，具有强一致性。比如，数据库事务。</p>
<p>柔性事务，其实就是根据不同的业务场景使用不同的方法实现最终一致性，也就是说我们可以根据业务的特性做部分取舍，容忍一定时间内的数据不一致。</p>
<p>总结来讲，与刚性事务不同，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致。而柔性事务的最终一致性，遵循的是 BASE 理论。</p>
<p>BASE 理论包括基本可用（Basically Available）、柔性状态（Soft State）和最终一致性（Eventual Consistency）。</p>
<ol>
<li>基本可用：分布式系统出现故障的时候，允许损失一部分功能的可用性。</li>
<li>柔性状态：在柔性事务中，允许系统存在中间状态，且这个中间状态不会影响系统整体可用性。比如，数据库读写分离，写库同步到读库（主库同步到从库）会有一个延时，其实就是一种柔性状态。</li>
<li>最终一致性：事务在操作过程中可能会由于同步延迟等问题导致不一致，但最终状态下，数据都是一致的。</li>
</ol>
<p>BASE 理论为了支持大型分布式系统，通过牺牲强一致性，保证最终一致性，来获得高可用性，是对 ACID 原则的弱化。</p>
<h1 id="基于-xa-协议的二阶段提交方法">基于 XA 协议的二阶段提交方法</h1>
<p>XA 是一个分布式事务协议，规定了事务管理器和资源管理器接口。因此，XA 协议可以分为两部分，即事务管理器和本地资源管理器。</p>
<p>XA 实现分布式事务的原理，事务管理器作为协调者，负责各个本地资源的提交和回滚；而资源管理器就是分布式事务的参与者，通常由数据库实现。</p>
<p>基于 XA 协议的二阶段提交方法中，<strong>二阶段提交协议（The two-phase commit protocol，2PC）</strong>，用于保证分布式系统中事务提交时的数据一致性，是 XA 在全局事务中用于协调多个资源的机制。</p>
<p>那么，两阶段提交协议如何保证分布在不同节点上的分布式事务的一致性呢？为了保证它们的一致性，我们需要引入一个协调者来管理所有的节点，并确保这些节点正确提交操作结果，若提交失败则放弃事务。接下来，我们看看两阶段提交协议的具体过程。两阶段提交协议的执行过程，分为投票（voting）和提交（commit）两个阶段。</p>
<p><strong>投票</strong>为第一阶段，协调者（Coordinator，即事务管理器）会向事务的参与者（Cohort，即本地资源管理器）发起执行操作的 CanCommit 请求，并等待参与者的响应。参与者接收到请求后，会执行请求中的事务操作，记录日志信息但不提交，待参与者执行成功，则向协调者发送“Yes”消息，表示同意操作；若不成功，则发送“No”消息，表示终止操作。</p>
<p>当所有的参与者都返回了操作结果（Yes 或 No 消息）后，系统进入了提交阶段。在提交阶段，协调者会根据所有参与者返回的信息向参与者发送 DoCommit 或 DoAbort 指令：</p>
<p>若协调者收到的都是“Yes”消息，则向参与者发送“DoCommit”消息，参与者会完成剩余的操作并释放资源，然后向协调者返回“HaveCommitted”消息；</p>
<p>如果协调者收到的消息中包含“No”消息，则向所有参与者发送“DoAbort”消息，此时发送“Yes”的参与者则会根据之前执行操作时的回滚日志对操作进行回滚，然后所有参与者会向协调者发送“HaveCommitted”消息；<br>
协调者接收到“HaveCommitted”消息，就意味着整个事务结束了。</p>
<p>二阶段提交的算法思路可以概括为：<strong>协调者下发请求事务操作，参与者将操作结果通知协调者，协调者根据所有参与者的反馈结果决定各参与者是要提交操作还是撤销操作。</strong></p>
<p>虽然基于 XA 的二阶段提交算法基本满足了事务的 ACID 特性，但依然有些不足。</p>
<pre><code>1. 同步阻塞问题：二阶段提交算法在执行过程中，所有参与节点都是事务阻塞型的。也就是说，当本地资源管理器占有临界资源时，其他资源管理器如果要访问同一临界资源，会处于阻塞状态。

2. 单点故障问题：基于 XA 的二阶段提交算法类似于集中式算法，一旦事务管理器发生故障，整个系统都处于停滞状态。尤其是在提交阶段，一旦事务管理器发生故障，资源管理器会由于等待管理器的消息，而一直锁定事务资源，导致整个系统被阻塞。

3. 数据不一致问题：在提交阶段，当协调者向参与者发送 DoCommit 请求之后，如果发生了局部网络异常，或者在发送提交请求的过程中协调者发生了故障，就会导致只有一部分参与者接收到了提交请求并执行提交操作，但其他未接到提交请求的那部分参与者则无法执行事务提交。于是整个分布式系统便出现了数据不一致的问题。
</code></pre>
<h1 id="三阶段提交方法">三阶段提交方法</h1>
<p>三阶段提交协议（Three-phase commit protocol，3PC），是对二阶段提交（2PC）的改进。为了解决两阶段提交的同步阻塞和数据不一致问题，三阶段提交引入了<strong>超时机制</strong>和<strong>准备阶段</strong>。</p>
<p>同时在协调者和参与者中引入超时机制。<strong>如果协调者或参与者在规定的时间内没有接收到来自其他节点的响应，就会根据当前的状态选择提交或者终止整个事务</strong>。</p>
<p><strong>在第一阶段和第二阶段中间引入了一个准备阶段</strong>，也就是在提交阶段之前，加入了一个预提交阶段。在预提交阶段排除一些不一致的情况，保证在最后提交之前各参与节点的状态是一致的。</p>
<p>也就是说，除了引入超时机制之外，3PC 把 2PC 的提交阶段一分为二，这样三阶段提交协议就有 CanCommit、PreCommit、DoCommit 三个阶段。</p>
<h2 id="第一cancommit-阶段">第一，CanCommit 阶段。</h2>
<p>CanCommit 阶段与 2PC 的投票阶段类似：协调者向参与者发送请求操作（CanCommit请求），询问参与者是否可以执行事务提交操作，然后等待参与者的响应；参与者收到CanCommit 请求之后，回复 Yes，表示可以顺利执行事务；否则回复 No。</p>
<p>CanCommit 阶段不同节点之间的事务请求成功和失败的流程，如下所示。</p>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1646725943605.png" alt="3pc第一阶段" loading="lazy"></figure>
<h2 id="第二precommit-阶段">第二，PreCommit 阶段。</h2>
<p>协调者根据参与者的回复情况，来决定是否可以进行 PreCommit 操作</p>
<p>如果所有参与者回复的都是“Yes”，那么协调者就会执行事务的预执行：</p>
<pre><code>- 发送预提交请求。协调者向参与者发送 PreCommit 请求，进入预提交阶段。
- 事务预提交。参与者接收到 PreCommit 请求后执行事务操作，并将 Undo 和 Redo信息记录到事务日志中。
- 响应反馈。如果参与者成功执行了事务操作，则返回 ACK 响应，同时开始等待最终指令。
</code></pre>
<p>假如任何一个参与者向协调者发送了“No”消息，或者等待超时之后，协调者都没有收到参与者的响应，就执行中断事务的操作：</p>
<pre><code> - 发送中断请求。协调者向所有参与者发送“Abort”消息。
 - 终断事务。参与者收到“Abort”消息之后，或超时后仍未收到协调者的消息，执行事务的终断操作。
</code></pre>
<p>预执行阶段，不同节点上事务执行成功和失败的流程，如下所示。</p>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1646726217417.png" alt="3pc2阶段" loading="lazy"></figure>
<h2 id="第三docommit-阶段">第三，DoCommit 阶段。</h2>
<p>DoCmmit 阶段进行真正的事务提交，根据 PreCommit 阶段协调者发送的消息，进入执行提交阶段或事务中断阶段。</p>
<ul>
<li>
<p><strong>执行提交阶段</strong>：</p>
<ul>
<li>发送提交请求。协调者接收到所有参与者发送的 Ack 响应，从预提交状态进入到提交状态，并向所有参与者发送 DoCommit 消息。</li>
<li>事务提交。参与者接收到 DoCommit 消息之后，正式提交事务。完成事务提交之后，释放所有锁住的资源。</li>
<li>响应反馈。参与者提交完事务之后，向协调者发送 Ack 响应。</li>
<li>完成事务。协调者接收到所有参与者的 Ack 响应之后，完成事务。</li>
</ul>
</li>
<li>
<p><strong>事务中断阶段</strong>：</p>
<ul>
<li>发送中断请求。协调者向所有参与者发送 Abort 请求。</li>
<li>事务回滚。参与者接收到 Abort 消息之后，利用其在 PreCommit 阶段记录的 Undo信息执行事务的回滚操作，并释放所有锁住的资源。</li>
<li>反馈结果。参与者完成事务回滚之后，向协调者发送 Ack 消息。</li>
<li>终断事务。协调者接收到参与者反馈的 Ack 消息之后，执行事务的终断，并结束事务。</li>
</ul>
</li>
</ul>
<p>执行阶段不同节点上事务执行成功和失败 (事务终断) 的流程，如下所示。</p>
<figure data-type="image" tabindex="3"><img src="https://q456qq520.github.io/post-images/1646729143957.png" alt="3pc3阶段" loading="lazy"></figure>
<p>在 DoCommit 阶段，当参与者向协调者发送 Ack 消息后，如果长时间没有得到协调者的响应，在默认情况下，参与者会自动将超时的事务进行提交，不会像两阶段提交那样被阻塞住。</p>
<h1 id="基于分布式消息的最终一致性方案">基于分布式消息的最终一致性方案</h1>
<p>2PC 和 3PC 这两种方法，有两个共同的缺点，一是都需要锁定资源，降低系统性能；二是，没有解决数据不一致的问题。因此，便有了通过分布式消息来确保事务最终一致性的方案。</p>
<p>在 eBay 的分布式系统架构中，架构师解决一致性问题的核心思想就是：将需要分布式处理的事务通过消息或者日志的方式异步执行，消息或日志可以存到本地文件、数据库或消息队列中，再通过业务规则进行失败重试。这个案例，就是使用基于<strong>分布式消息的最终一致性方案</strong>解决了分布式事务的问题。</p>
<p>基于分布式消息的最终一致性方案的事务处理，引入了一个消息中间件（MessageQueue，MQ），用于在多个应用之间进行消息传递。</p>
<p>基于消息中间件协商多个节点分布式事务执行操作的示意图，如下所示。</p>
<figure data-type="image" tabindex="4"><img src="https://q456qq520.github.io/post-images/1646813542498.png" alt="最终一致性示意图" loading="lazy"></figure>
<p>以网上购物为例。假设用户 A 在某电商平台下了一个订单，需要支付 50 元，发现自己的账户余额共 150 元，就使用余额支付，支付成功之后，订单状态修改为支付成功，然后通知仓库发货。</p>
<p>在该事件中，涉及到了订单系统、支付系统、仓库系统，这三个系统是相互独立的应用，通过远程服务进行调用。</p>
<figure data-type="image" tabindex="5"><img src="https://q456qq520.github.io/post-images/1646813778051.png" alt="最终一致性时序图" loading="lazy"></figure>
<p>根据基于分布式消息的最终一致性方案，用户 A 通过终端手机首先在订单系统上操作，然后整个购物的流程如下所示。</p>
<figure data-type="image" tabindex="6"><img src="https://q456qq520.github.io/post-images/1646813800623.png" alt="最终一致性流程图" loading="lazy"></figure>
<ol>
<li>订单系统把订单消息发给消息中间件，消息状态标记为“待确认”。</li>
<li>消息中间件收到消息后，进行消息持久化操作，即在消息存储系统中新增一条状态为“待发送”的消息。</li>
<li>消息中间件返回消息持久化结果（成功 / 失败），订单系统根据返回结果判断如何进行业务操作。失败，放弃订单，结束（必要时向上层返回失败结果）；成功，则创建订单。</li>
<li>订单操作完成后，把操作结果（成功 / 失败）发送给消息中间件。</li>
<li>消息中间件收到业务操作结果后，根据结果进行处理：失败，删除消息存储中的消息，结束；成功，则更新消息存储中的消息状态为“待发送（可发送）”，并执行消息投递。</li>
<li>如果消息状态为“可发送”，则 MQ 会将消息发送给支付系统，表示已经创建好订单，需要对订单进行支付。支付系统也按照上述方式进行订单支付操作。</li>
<li>订单系统支付完成后，会将支付消息返回给消息中间件，中间件将消息传送给订单系统。订单系统再调用库存系统，进行出货操作。</li>
</ol>
<p>分布式事务中，当且仅当所有的事务均成功时整个流程才成功。所以，<strong>分布式事务的一致性是实现分布式事务的关键问题，目前来看还没有一种很简单、完美的方案可以应对所有场景</strong>。</p>
<h1 id="三种实现方式对比">三种实现方式对比</h1>
<figure data-type="image" tabindex="7"><img src="https://q456qq520.github.io/post-images/1646813912330.png" alt="分布式事务对比图" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分布式锁]]></title>
        <id>https://q456qq520.github.io/post/fen-bu-shi-shi-wu/</id>
        <link href="https://q456qq520.github.io/post/fen-bu-shi-shi-wu/">
        </link>
        <updated>2022-03-08T01:54:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="为什么要使用分布锁">为什么要使用分布锁？</h1>
<h2 id="什么是锁">什么是锁</h2>
<p>在单机多线程环境中，我们经常遇到多个线程访问同一个共享资源（这里需要注意的是：在很多地方，这种资源会称为临界资源，也称之为共享资源）的情况。为了维护数据的一致性，我们需要某种机制来保证只有满足某个条件的线程才能访问资源，不满足条件的线程只能等待，在下一轮竞争中重新满足条件时才能访问资源。</p>
<p>这个机制指的是，为了实现分布式互斥，在某个地方做个标记，这个标记每个线程都能看到，到标记不存在时可以设置该标记，当标记被设置后，其他线程只能等待拥有该标记的线程执行完成，并释放该标记后，才能去设置该标记和访问共享资源。这里的标记，就是我们常说的锁。</p>
<p>也就是说，<strong>锁是实现多线程同时访问同一共享资源，保证同一时刻只有一个线程可访问共享资源所做的一种标记</strong>。</p>
<p>与普通锁不同的是，<strong>分布式锁</strong>是指分布式环境下，系统部署在多个机器中，实现多进程分布式互斥的一种锁。为了保证多个进程能看到锁，锁被存在公共存储（比如 Redis、Memcache、数据库等三方存储中），以实现多个进程并发访问同一个临界资源，同一时刻只有一个进程可访问共享资源，确保数据的一致性。</p>
<h1 id="分布式锁的三种实现方法及对比">分布式锁的三种实现方法及对比</h1>
<p>接下来，我带你看看实现分布式锁的 3 种主流方法，即：</p>
<pre><code>1. 基于数据库实现分布式锁，这里的数据库指的是关系型数据库；

2. 基于缓存实现分布式锁；

3. 基于 ZooKeeper 实现分布式锁。
</code></pre>
<h2 id="基于数据库实现分布式锁">基于数据库实现分布式锁</h2>
<p>要实现分布式锁，最简单的方式就是创建一张锁表，然后通过操作该表中的数据来实现。</p>
<p>当我们要锁住某个资源时，就在该表中增加一条记录，想要释放锁的时候就删除这条记录。数据库对共享资源做了唯一性约束，如果有多个请求被同时提交到数据库的话，数据库会保证只有一个操作可以成功，操作成功的那个线程就获得了访问共享资源的锁，可以进行操作。</p>
<p>基于数据库实现的分布式锁，是最容易理解的。但是，因为数据库需要落到硬盘上，频繁读取数据库会导致 IO 开销大，因此这种分布式锁适用于并发量低，对性能要求低的场景。对于双 11、双 12 等需求量激增场景，数据库锁是无法满足其性能要求的。而在平日的购物中，我们可以在局部场景中使用数据库锁实现对资源的互斥访问。</p>
<p>以电商售卖吹风机的场景为例。吹风机库存是 2 个，有 5 个来自不同地区的用户{A,B,C,D,E}想要购买，其中用户 A 想买 1 个，用户 B 想买 2 个，用户 C 想买 1个。</p>
<p>用户 A 和用户 B 几乎同时下单，但用户 A 的下单请求最先到达服务器。因此，该商家的产品数据库中增加了一条关于用户 A 的记录，用户 A 获得了锁，他的订单请求被处理，服务器修改吹风机库存数，减去 1 后还剩下 1 个。</p>
<p>当用户 A 的订单请求处理完成后，有关用户 A 的记录被删除，服务器开始处理用户 B 的订单请求。这时，库存只有 1 个了，无法满足用户 B 的订单需求，因此用户 B 购买失败。从数据库中，删除用户 B 的记录，服务器开始处理用户 C 的订单请求，库存中 1 个吹风机满足用户 C 的订单需求。所以，数据库中增加了一条关于用户 C 的记录，用户 C 获得了锁，他的订单请求被处理，服务器修改吹风机数量，减去 1 后还剩下 0 个。</p>
<p><strong>基于数据库实现分布式锁比较简单，主要在于创建一张锁表，为申请者在锁表里建立一条记录，记录建立成功则获得锁，消除记录则释放锁</strong>。该方法依赖于数据库，主要有两个缺点：</p>
<pre><code>1. 单点故障问题。一旦数据库不可用，会导致整个系统崩溃。

2. 死锁问题。数据库锁没有失效时间，未获得锁的进程只能一直等待已获得锁的进程主动释放锁。一旦已获得锁的进程挂掉或者解锁操作失败，会导致锁记录一直存在数据库中，其他进程无法获得锁。
</code></pre>
<h2 id="基于缓存实现分布式锁">基于缓存实现分布式锁</h2>
<p>基于缓存实现分布式锁的方式。所谓基于缓存，也就是说把数据存放在计算机内存中，不需要写入磁盘，减少了 IO 读写。</p>
<p>Redis 通常可以使用 setnx(key, value) 函数来实现分布式锁。key 和 value 就是基于缓存的分布式锁的两个属性，其中 key 表示锁 id，value = currentTime + timeOut，表示当前时间 + 超时时间。也就是说，某个进程获得 key 这把锁后，如果在 value 的时间内未释放锁，系统就会主动释放锁。</p>
<p>setnx 函数的返回值有 0 和 1：</p>
<p>返回 1，说明该服务器获得锁，setnx 将 key 对应的 value 设置为当前时间 + 锁的有效时间。</p>
<p>返回 0，说明其他服务器已经获得了锁，进程不能进入临界区。该服务器可以不断尝试setnx 操作，以获得锁。</p>
<p>以电商售卖吹风机的场景为例，和你说明基于缓存实现的分布式锁，假设现在库存数量是足够的。</p>
<p>用户 A 的请求因为网速快，最先到达 Server2，setnx 操作返回 1，并获取到购买吹风机的锁；用户 B 和用户 C 的请求，几乎同时到达了 Server1 和 Server3，但因为这时 Server2获取到了吹风机数据的锁，所以只能加入等待队列。</p>
<p>Server2 获取到锁后，负责管理吹风机的服务器执行业务逻辑，只用了 1s 就完成了订单。订单请求完成后，删除锁的 key，从而释放锁。此时，排在第二顺位的 Server1 获得了锁，可以访问吹风机的数据资源。但不巧的是，Server1 在完成订单后发生了故障，无法主动释放锁。</p>
<p>于是，排在第三顺位的 Server3 只能等设定的有效时间（比如 30 分钟）到期，锁自动释放后，才能访问吹风机的数据资源，也就是说用户 C 只能到 00:30:01 以后才能继续抢购。</p>
<p>Redis 通过队列来维持进程访问共享资源的先后顺序。Redis 锁主要基于 setnx函数实现分布式锁，当进程通过 setnx&lt;key,value&gt; 函数返回 1 时，表示已经获得锁。排在后面的进程只能等待前面的进程主动释放锁，或者等到时间超时才能获得锁。</p>
<p>相对于基于数据库实现分布式锁的方案来说，基于缓存实现的分布式锁的优势表现在以下几个方面：</p>
<pre><code>1. 性能更好。数据被存放在内存，而不是磁盘，避免了频繁的 IO 操作。

2. 很多缓存可以跨集群部署，避免了单点故障问题。

3. 很多缓存服务都提供了可以用来实现分布式锁的方法，比如 Redis 的 setnx 方法等。可以直接设置超时时间来控制锁的释放，因为这些缓存服务器一般支持自动删除过期数据。
</code></pre>
<p>这个方案的不足是，通过超时时间来控制锁的失效时间，并不是十分靠谱，因为一个进程执行时间可能比较长，或受系统进程做内存回收等影响，导致时间超时，从而不正确地释放了锁。</p>
<h2 id="基于-zookeeper-实现分布式锁">基于 ZooKeeper 实现分布式锁</h2>
<p>ZooKeeper 基于树形数据存储结构实现分布式锁，来解决多个进程同时访问同一临界资源时，数据的一致性问题。ZooKeeper 的树形数据存储结构主要由 4 种节点构成：</p>
<pre><code>1. 持久节点。这是默认的节点类型，一直存在于 ZooKeeper 中。

2. 持久顺序节点。也就是说，在创建节点时，ZooKeeper 根据节点创建的时间顺序对节点进行编号。

3. 临时节点。与持久节点不同，当客户端与 ZooKeeper 断开连接后，该进程创建的临时节点就会被删除。

4. 临时顺序节点，就是按时间顺序编号的临时节点。
</code></pre>
<p>根据它们的特征，ZooKeeper 基于临时顺序节点实现了分布锁。</p>
<p>还是以电商售卖吹风机的场景为例。假设用户 A、B、C 同时在 11 月 11 日的零点整提交了购买吹风机的请求，ZooKeeper 会采用如下方法来实现分布式锁：</p>
<ol>
<li>
<p>在与该方法对应的持久节点 shared_lock 的目录下，为每个进程创建一个临时顺序节点。吹风机就是一个拥有 shared_lock 的目录，当有人买吹风机时，会为他创建一个临时顺序节点。</p>
</li>
<li>
<p>每个进程获取 shared_lock 目录下的所有临时节点列表，注册子节点变更的Watcher，并监听节点。</p>
</li>
<li>
<p>每个节点确定自己的编号是否是 shared_lock 下所有子节点中最小的，若最小，则获得锁。例如，用户 A 的订单最先到服务器，因此创建了编号为 1 的临时顺序节点LockNode1。该节点的编号是持久节点目录下最小的，因此获取到分布式锁，可以访问临界资源，从而可以购买吹风机。</p>
</li>
<li>
<p>若本进程对应的临时节点编号不是最小的，则分为两种情况：</p>
<p>a. 本进程为读请求，如果比自己序号小的节点中有写请求，则等待；</p>
<p>b. 本进程为写请求，如果比自己序号小的节点中有读请求，则等待。</p>
</li>
</ol>
<p>例如，用户 B 也想要买吹风机，但在他之前，用户 C 想看看吹风机的库存量。因此，用户B 只能等用户 A 买完吹风机、用户 C 查询完库存量后，才能购买吹风机。</p>
<p>使用 ZooKeeper 可以完美解决设计分布式锁时遇到的各种问题，比如单点故障、不可重入、死锁等问题。虽然 ZooKeeper 实现的分布式锁，几乎能涵盖所有分布式锁的特性，且易于实现，但需要频繁地添加和删除节点，所以性能不如基于缓存实现的分布式锁。</p>
<table>
<thead>
<tr>
<th>特征</th>
<th style="text-align:center">对比</th>
</tr>
</thead>
<tbody>
<tr>
<td>理解的容易程度</td>
<td style="text-align:center">数据库&gt;缓存&gt;zk</td>
</tr>
<tr>
<td>实现复杂性</td>
<td style="text-align:center">zk&gt;=缓存&gt;数据库</td>
</tr>
<tr>
<td>性能</td>
<td style="text-align:center">缓存&gt;zk&gt;=数据库</td>
</tr>
<tr>
<td>可靠性</td>
<td style="text-align:center">zk&gt;缓存&gt;数据库</td>
</tr>
</tbody>
</table>
<p>ZooKeeper 分布式锁的可靠性最高，有封装好的框架，很容易实现分布式锁的功能，并且几乎解决了数据库锁和缓存式锁的不足，因此是实现分布式锁的首选方法。</p>
<p>为了确保分布式锁的可用性，我们在设计时应考虑到以下几点：</p>
<pre><code>1. 互斥性，即在分布式系统环境下，分布式锁应该能保证一个资源或一个方法在同一时间只能被一个机器的一个线程或进程操作。

2. 具备锁失效机制，防止死锁。即使有一个进程在持有锁的期间因为崩溃而没有主动解锁，也能保证后续其他进程可以获得锁。

3. 可重入性，即进程未释放锁时，可以多次访问临界资源。

4. 有高可用的获取锁和释放锁的功能，且性能要好。
</code></pre>
<h1 id="如何解决分布式锁的羊群效应问题">如何解决分布式锁的羊群效应问题？</h1>
<p>在分布式锁问题中，会经常遇到羊群效应。所谓羊群效应，就是在整个分布式锁的竞争过程中，大量的“Watcher 通知”和“子节点列表的获取”操作重复运行，并且大多数节点的运行结果都是判断出自己当前并不是编号最小的节点，继续等待下一次通知，而不是执行业务逻辑。</p>
<p>这，就会对 ZooKeeper 服务器造成巨大的性能影响和网络冲击。更甚的是，如果同一时间多个节点对应的客户端完成事务或事务中断引起节点消失，ZooKeeper 服务器就会在短时间内向其他客户端发送大量的事件通知。</p>
<p>那如何解决这个问题呢？具体方法可以分为以下三步。</p>
<ol>
<li>
<p>在与该方法对应的持久节点的目录下，为每个进程创建一个临时顺序节点。</p>
</li>
<li>
<p>每个进程获取所有临时节点列表，对比自己的编号是否最小，若最小，则获得锁。</p>
</li>
<li>
<p>若本进程对应的临时节点编号不是最小的，则继续判断：</p>
<p>a. 若本进程为读请求，则向比自己序号小的最后一个写请求节点注册 watch 监听，当监听到该节点释放锁后，则获取锁；</p>
<p>b. 若本进程为写请求，则向比自己序号小的最后一个读请求节点注册 watch 监听，当监听到该节点释放锁后，获取锁。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 分布式选举]]></title>
        <id>https://q456qq520.github.io/post/fen-bu-shi-xuan-ju/</id>
        <link href="https://q456qq520.github.io/post/fen-bu-shi-xuan-ju/">
        </link>
        <updated>2022-03-07T11:24:59.000Z</updated>
        <content type="html"><![CDATA[<h1 id="为什么要有分布式选举">为什么要有分布式选举？</h1>
<p>主节点，在一个分布式集群中负责对其他节点的协调和管理，也就是说，其他节点都必须听从主节点的安排。</p>
<p>主节点的存在，就可以保证其他节点的有序运行，以及数据库集群中的写入数据在每个节点上的一致性。这里的一致性是指，数据在每个集群节点中都是一样的，不存在不同的情况。当然，如果主故障了，集群就会天下大乱，就好比一个国家的皇帝驾崩了，国家大乱一样。比如，数据库集群中主节点故障后，可能导致每个节点上的数据会不一致。</p>
<p>这，就应了那句话“国不可一日无君”，对应到分布式系统中就是“集群不可一刻无主”。总结来说，选举的作用就是选出一个主节点，由它来协调和管理其他节点，以保证集群有序运行和节点间数据的一致性。</p>
<h1 id="分布式选举的算法">分布式选举的算法</h1>
<p>目前常见的选主方法有基于序号选举的算法（ 比如，Bully 算法）、多数派算法（比如，Raft 算法、ZAB 算法）等。</p>
<h1 id="bully-算法">Bully 算法</h1>
<p>Bully 算法是一种集群选主算法，因为它的选举原则是“长者”为大，即在所有活着的节点中，选取 ID 最大的节点作为主节点。</p>
<p>在 Bully 算法中，节点的角色有两种：普通节点和主节点。初始化时，所有节点都是平等的，都是普通节点，并且都有成为主的权利。但是，当选主成功后，有且仅有一个节点成为主节点，其他所有节点都是普通节点。当且仅当主节点故障或与其他节点失去联系后，才会重新选主。</p>
<p>Bully 算法在选举过程中，需要用到以下 3 种消息：</p>
<pre><code>1. Election 消息，用于发起选举；
2. Alive 消息，对 Election 消息的应答；
3. Victory 消息，竞选成功的主节点向其他节点发送的宣誓主权的消息。
</code></pre>
<p>Bully 算法选举的原则是“长者为大”，意味着它的假设条件是，集群中每个节点均知道其他节点的 ID。在此前提下，其具体的选举过程是：</p>
<ol>
<li>集群中每个节点判断自己的 ID 是否为当前活着的节点中 ID 最大的，如果是，则直接向其他节点发送 Victory 消息，宣誓自己的主权；</li>
<li>如果自己不是当前活着的节点中 ID 最大的，则向比自己 ID 大的所有节点发送Election 消息，并等待其他节点的回复；</li>
<li>若在给定的时间范围内，本节点没有收到其他节点回复的 Alive 消息，则认为自己成为主节点，并向其他节点发送 Victory 消息，宣誓自己成为主节点；若接收到来自比自己ID 大的节点的 Alive 消息，则等待其他节点发送 Victory 消息；</li>
<li>若本节点收到比自己 ID 小的节点发送的 Election 消息，则回复一个 Alive 消息，告知其他节点，我比你大，重新选举。</li>
</ol>
<p>目前已经有很多开源软件采用了 Bully 算法进行选主，比如 MongoDB 的副本集故障转移功能。MongoDB 的分布式选举中，采用节点的最后操作时间戳来表示 ID，时间戳最新的节点其 ID 最大，也就是说时间戳最新的、活着的节点是主节点。</p>
<p>小结一下。Bully 算法的选择特别霸道和简单，谁活着且谁的 ID 最大谁就是主节点，其他节点必须无条件服从。这种算法的优点是，选举速度快、算法复杂度低、简单易实现。</p>
<p>但这种算法的缺点在于，需要每个节点有全局的节点信息，因此额外信息存储较多；其次，任意一个比当前主节点 ID 大的新节点或节点故障后恢复加入集群的时候，都可能会触发重新选举，成为新的主节点，如果该节点频繁退出、加入集群，就会导致频繁切主。</p>
<h1 id="raft-算法">Raft 算法</h1>
<p>Raft 算法是典型的多数派投票选举算法，其选举机制与我们日常生活中的民主投票机制类似，核心思想是“<strong>少数服从多数</strong>”。也就是说，Raft 算法中，获得投票最多的节点成为主。</p>
<p>采用 Raft 算法选举，集群节点的角色有 3 种：</p>
<pre><code>- **Leader**，即主节点，同一时刻只有一个 Leader，负责协调和管理其他节点；

- **Candidate**，即候选者，每一个节点都可以成为 Candidate，节点在该角色下才可以被

    选为新的 Leader；

- **Follower**，Leader 的跟随者，不可以发起选举。
</code></pre>
<p>Raft 选举的流程，可以分为以下几步：</p>
<ol>
<li>初始化时，所有节点均为 Follower 状态。</li>
<li>开始选主时，所有节点的状态由 Follower 转化为 Candidate，并向其他节点发送选举请求。</li>
<li>其他节点根据接收到的选举请求的先后顺序，回复是否同意成为主。这里需要注意的<br>
是，在每一轮选举中，一个节点只能投出一张票。</li>
<li>若发起选举请求的节点获得超过一半的投票，则成为主节点，其状态转化为 Leader，<br>
其他节点的状态则由 Candidate 降为 Follower。Leader 节点与 Follower 节点之间会<br>
定期发送心跳包，以检测主节点是否活着。</li>
<li>当 Leader 节点的任期到了，即发现其他服务器开始下一轮选主周期时，Leader 节点<br>
的状态由 Leader 降级为 Follower，进入新一轮选主。</li>
</ol>
<p><strong>每一轮选举，每个节点只能投一次票。</strong></p>
<p>小结一下。Raft 算法具有选举速度快、算法复杂度低、易于实现的优点；缺点是，它要求系统内每个节点都可以相互通信，且需要获得过半的投票数才能选主成功，因此通信量大。该算法选举稳定性比 Bully 算法好，这是因为当有新节点加入或节点故障恢复后，会触发选主，但不一定会真正切主，除非新节点或故障后恢复的节点获得投票数过半，才会导致切主。</p>
<h2 id="扩展">扩展</h2>
<p>两主的情况出现在集群因为网络原因，被划分了两部分局部可通信的区域。下面的链接详细讲解了Raft算法，及双主出现后集群是如何恢复的。<br>
https://www.infoq.cn/article/coreos-analyse-etcd/</p>
<p>还有一个Raft算法动画链接<br>
http://thesecretlivesofdata.com/raft/#election</p>
<p>一文搞懂Raft算法<br>
https://www.cnblogs.com/xybaby/p/10124083.html</p>
<h1 id="具有优先级的民主投票zab-算法">具有优先级的民主投票：ZAB 算法</h1>
<p>ZAB（ZooKeeper Atomic Broadcast）选举算法是为 ZooKeeper 实现分布式协调功能而设计的。相较于 Raft 算法的投票机制，ZAB 算法增加了通过节点 ID 和数据 ID 作为参考进行选主，节点 ID 和数据 ID 越大，表示数据越新，优先成为主。相比较于 Raft 算法，ZAB 算法尽可能保证数据的最新性。所以，ZAB 算法可以说是对 Raft 算法的改进。</p>
<p>使用 ZAB 算法选举时，集群中每个节点拥有 3 种角色：</p>
<pre><code>- ** Leader**，主节点；
- **Follower**，跟随者节点；
- **Observer**，观察者，无投票权。
</code></pre>
<p>选举过程中，集群中的节点拥有 4 个状态：</p>
<pre><code>- **Looking**状态，即选举状态。当节点处于该状态时，它会认为当前集群中没有 Leader，因此自己进入选举状态。
- **Leading**状态，即领导者状态，表示已经选出主，且当前节点为 Leader。
- **Following**状态，即跟随者状态，集群中已经选出主后，其他非主节点状态更新为Following，表示对 Leader 的追随。
- **Observing**状态，即观察者状态，表示当前节点为 Observer，持观望态度，没有投票权和选举权。
</code></pre>
<p>投票过程中，每个节点都有一个唯一的三元组 (server_id, server_zxID, epoch)，其中server_id 表示本节点的唯一 ID；server_zxID 表示本节点存放的数据 ID，数据 ID 越大表示数据越新，选举权重越大；epoch 表示当前选取轮数，一般用逻辑时钟表示。</p>
<p>ZAB 选举算法的核心是“少数服从多数，ID 大的节点优先成为主”，因此选举过程中通过(vote_id, vote_zxID) 来表明投票给哪个节点，其中 vote_id 表示被投票节点的 ID，vote_zxID 表示被投票节点的服务器 zxID。ZAB 算法选主的原则是：<strong>server_zxID 最大者成为 Leader；若 server_zxID 相同，则 server_id 最大者成为 Leader。</strong></p>
<p>接下来，我以 3 个 Server 的集群为例，此处每个 Server 代表一个节点，与你介绍 ZAB 选主的过程。</p>
<p>第一步：当系统刚启动时，3 个服务器当前投票均为第一轮投票，即 epoch=1，且 zxID均为 0。此时每个服务器都推选自己，并将选票信息 &lt;epoch, vote_id, vote_zxID&gt; 广播出去。</p>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1646703805954.png" alt="zab1" loading="lazy"></figure>
<p>第二步：根据判断规则，由于 3 个 Server 的 epoch、zxID 都相同，因此比较 server_id，较大者即为推选对象，因此 Server 1 和 Server 2 将 vote_id 改为 3，更新自己的投票箱并重新广播自己的投票。</p>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1646703819106.png" alt="zab2" loading="lazy"></figure>
<p>第三步：此时系统内所有服务器都推选了 Server 3，因此 Server 3 当选 Leader，处于Leading 状态，向其他服务器发送心跳包并维护连接；Server1 和 Server2 处于Following 状态。</p>
<figure data-type="image" tabindex="3"><img src="https://q456qq520.github.io/post-images/1646703831617.png" alt="zab3" loading="lazy"></figure>
<p>小结一下。ZAB 算法性能高，对系统无特殊要求，采用广播方式发送信息，若节点中有 n个节点，每个节点同时广播，则集群中信息量为 n*(n-1) 个消息，容易出现广播风暴；且除了投票，还增加了对比节点 ID 和数据 ID，这就意味着还需要知道所有节点的 ID 和数据ID，所以选举时间相对较长。但该算法选举稳定性比较好，当有新节点加入或节点故障恢复后，会触发选主，但不一定会真正切主，除非新节点或故障后恢复的节点数据 ID 和节点ID 最大，且获得投票数过半，才会导致切主。</p>
<p>#三种选举算法的对比分析</p>
<figure data-type="image" tabindex="4"><img src="https://q456qq520.github.io/post-images/1646703947766.png" alt="算法对比1" loading="lazy"></figure>
<h1 id="为什么多数派选主算法通常采用奇数节点而不是偶数节点呢">为什么“多数派”选主算法通常采用奇数节点，而不是偶数节点呢？</h1>
<p>多数派选主算法的核心是少数服从多数，获得投票多的节点胜出。想象一下，如果现在采用偶数节点集群，当两个节点均获得一半投票时，到底应该选谁为主呢？</p>
<p>答案是，在这种情况下，无法选出主，必须重新投票选举。但即使重新投票选举，两个节点拥有相同投票数的概率也会很大。因此，多数派选主算法通常采用奇数节点。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分布式互斥]]></title>
        <id>https://q456qq520.github.io/post/fen-bu-shi-hu-chi/</id>
        <link href="https://q456qq520.github.io/post/fen-bu-shi-hu-chi/">
        </link>
        <updated>2022-03-07T06:49:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="有你没我有我没你">有你没我，有我没你</h1>
<h2 id="什么是分布式互斥">什么是分布式互斥?</h2>
<p>在分布式系统里，排他性的资源访问方式，叫作分布式互斥(Distributed Mutual Exclusion)，而被互斥访问的共享资源就叫作临界资源(Critical Resource)。</p>
<p>举个例子</p>
<p>想象一下，你正在一家餐厅使用自助咖啡机泡制咖啡，突然有个人过来挪走了你的杯子，开始泡制他自己的咖啡。你耐着性子等他操作完，继续泡制自己的咖啡。结果你开始没多久，他又回来中断了你泡制咖啡的过程。相信要不了几个回合，你和他就会上演一场“有你没我，有我没你”的格斗了。这样现实的问题也同样存在于分布式世界。就像我们使用自助咖啡机时不希望被打扰一样，对于同一共享资源，一个程序正在使用的时候也不希望被其他程序打扰。这，就要求同一时刻只能有一个程序能够访问这种资源。</p>
<h2 id="集中式算法">集中式算法</h2>
<p>对于前面提到的咖啡机问题，我们首先想到的就是，增加一个“协调者”来约束大家使用自助咖啡机，解决强行插入打断别人的问题。</p>
<p>类似地，我们引入一个协调者程序，得到一个分布式互斥算法。每个程序在需要访问临界资源时，先给协调发送一个请求。如果当前没有程序使用这个资源，协调者直接授权请求程序访问;否则，按照先来后到的顺序请求程序“排一个号”。如果有程序使用完资源，则通知协调者，协调者从“排号”的队列里取出排在最前面的请求，并给它发送授权消息。拿到授权消息的程序，可以直接去访问临界资源。</p>
<p>这个互斥算法，就是我们所说的集中式算法，也可以叫做中央服务器算法。之所以这么称 呼，是因为协调者代表着集中程序或中央服务器。</p>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1646640649977.png" alt="分布式集中式算法示意图" loading="lazy"></figure>
<p>如图所示，程序 1、2、3、4 为普通运行程序，另一个程序为协调者。当程序 2 和程序 4<br>
需要使用临界资源时，它们会向协调者发起申请，请求协调者授权。不巧的是，程序 3 正在使用临界资源。这时，协调者根据程序 2 和 4 的申请时间顺序，依次将它们放入等待队列。在这个案例里，程序 4 的申请时间早于程序 2，因此排在程序 2的前面。程序 3 使用完临界资源后，通知协调者释放授权。此时，协调者从等待队列中取出程序4，并给它发放授权。这时，程序 4 就可以使用临界资源了。</p>
<p>从上述流程可以看出，<strong>一个程序完成一次临界资源访问，需要如下几个流程和消息交互</strong>：</p>
<ol>
<li>向协调者发送请求授权信息，1 次消息交互；</li>
<li>协调者向程序发放授权信息，1 次消息交互；</li>
<li>程序使用完临界资源后，向协调者发送释放授权，1 次消息交互。</li>
</ol>
<p>因此，每个程序完成一次临界资源访问，需要进行 3 次消息交互。</p>
<p>不难看出，集中式算法的优点在于直观、简单、信息交互量少、易于实现，并且所有程序只需和协调者通信，程序之间无需通信。但是，这个算法的问题也出在了协调者身上。</p>
<p>一方面，协调者会成为系统的性能瓶颈。想象一下，如果有 100 个程序要访问临界资源，那么协调者要处理 100*3=300 条消息。也就是说，协调者处理的消息数量会随着需要访问临界资源的程序数量线性增加。另一方面，容易引发单点故障问题。协调者故障，会导致所有的程序均无法访问临界资源，导致整个系统不可用。</p>
<p>因此，在使用集中式算法的时候，一定要选择性能好、可靠性高的服务器来运行协调者。</p>
<p>小结一下：集中式算法具有简单、易于实现的特点，但可用性、性能易受协调者影响。在可靠性和性能有一定保障的情况下，比如中央服务器计算能力强、性能高、故障率低，或者中央服务器进行了主备备份，主故障后备可以立马升为主，且数据可恢复的情况下，集中式算法可以适用于比较广泛的应用场景。</p>
<h2 id="民主协商分布式算法">民主协商：分布式算法</h2>
<p>既然引入协调者会带来一些问题，这时你可能就会想，不用协调者是否可以实现对临界资源的互斥访问呢？想象一下，当你需要使用自助咖啡机的时候，是不是可以先去征求其他人的意见，在确认其他人都没在使用也暂时不会使用咖啡机时，你就可以放心大胆地去泡制自己的咖啡了呢？</p>
<p>同理，我们可以把这套算法用于分布式系统。当一个程序要访问临界资源时，先向系统中的其他程序发送一条请求消息，在接收到所有程序返回的同意消息后，才可以访问临界资源。其中，请求消息需要包含所请求的资源、请求者的 ID，以及发起请求的时间</p>
<p>这，就是<strong>民主协商法。在分布式领域中，我们称之为分布式算法</strong>，或者使用组播和逻辑时钟的算法。</p>
<p>如图所示，程序 1、2、3 需要访问共享资源 A。在时间戳为 8 的时刻，程序 1 想要使用资源 A，于是向程序 2 和 3 发起使用资源 A 的申请，希望得到它们的同意。在时间戳为 12的时刻，程序 3 想要使用资源 A，于是向程序 1 和 2 发起访问资源 A 的请求。</p>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1646642012370.png" alt="分布式算法1" loading="lazy"></figure>
<p>如图所示，此时程序 2 暂时不访问资源 A，因此同意了程序 1 和 3 的资源访问请求。对于程序 3 来说，由于程序 1 提出请求的时间更早，因此同意程序 1 先使用资源，并等待程序1 返回同意消息。</p>
<figure data-type="image" tabindex="3"><img src="https://q456qq520.github.io/post-images/1646642063633.png" alt="分布式算法2" loading="lazy"></figure>
<p>如图所示，程序 1 接收到其他所有程序的同意消息之后，开始使用资源 A。当程序 1 使用完资源 A 后，释放使用权限，向请求队列中需要使用资源 A 的程序 3 发送同意使用资源的消息，并将程序 3 从请求队列中删除。此时，程序 3 收到了其他所有程序的同意消息，获得了使用资源 A 的权限，开始使用临界资源 A 的旅程。</p>
<figure data-type="image" tabindex="4"><img src="https://q456qq520.github.io/post-images/1646642086375.png" alt="分布式算法3" loading="lazy"></figure>
<p>从上述流程可以看出，一个程序完成一次临界资源的访问，需要进行如下的信息交互：</p>
<ol>
<li>向其他 n-1 个程序发送访问临界资源的请求，总共需要 n-1 次消息交互；</li>
<li>需要接收到其他 n-1 个程序回复的同意消息，方可访问资源，总共需要 n-1 次消息交互。</li>
</ol>
<p>可以看出，一个程序要成功访问临界资源，至少需要 2*(n-1) 次消息交互。假设，现在系统中的 n 个程序都要访问临界资源，则会同时产生 2n(n-1) 条消息。总结来说，在大型系统中使用分布式算法，消息数量会随着需要访问临界资源的程序数量呈指数级增加，容易导致高昂的“沟通成本”。</p>
<p>从上述分析不难看出，分布式算法根据“先到先得”以及“投票全票通过”的机制，让每个程序按时间顺序公平地访问资源，简单粗暴、易于实现。但，这个算法可用性很低，主要包括两个方面的原因：</p>
<pre><code>当系统内需要访问临界资源的程序增多时，容易产生“信令风暴”，也就是程序收到的请求完全超过了自己的处理能力，而导致自己正常的业务无法开展。

一旦某一程序发生故障，无法发送同意消息，那么其他程序均处在等待回复的状态中，使得整个系统处于停滞状态，导致整个系统不可用。所以，相对于集中式算法的协调者故障，分布式算法的可用性更低。
</code></pre>
<p>针对可用性低的一种改进办法是，如果检测到一个程序故障，则直接忽略这个程序，无需再等待它的同意消息。这就好比在自助餐厅，一个人离开餐厅了，那你在使用咖啡机前，也无需征得他的同意。但这样的话，每个程序都需要对其他程序进行故障检测，这无疑带来了更大的复杂性。</p>
<p>因此，分布式算法适合节点数目少且变动不频繁的系统，且由于每个程序均需通信交互，因此适合 P2P 结构的系统。比如，运行在局域网中的分布式文件系统，具有 P2P 结构的系统等。</p>
<h2 id="轮值-ceo令牌环算法">轮值 CEO：令牌环算法</h2>
<p>程序访问临界资源问题也可按照轮值 CEO 的思路实现。 如下图所示，所有程序构成一个环结构，令牌按照顺时针（或逆时针）方向在程序之间传递，收到令牌的程序有权访问临界资源，访问完成后将令牌传送到下一个程序；若该程序不需要访问临界资源，则直接把令牌传送给下一个程序。</p>
<p>在分布式领域，这个算法叫作令牌环算法，也可以叫作基于环的算法。</p>
<figure data-type="image" tabindex="5"><img src="https://q456qq520.github.io/post-images/1646651760528.png" alt="" loading="lazy"></figure>
<p>因为在使用临界资源前，不需要像分布式算法那样挨个征求其他程序的意见了，所以相对而言，在令牌环算法里单个程序具有更高的通信效率。同时，在一个周期内，每个程序都能访问到临界资源，因此令牌环算法的公平性很好。</p>
<p>但是，不管环中的程序是否想要访问资源，都需要接收并传递令牌，所以也会带来一些无效通信。假设系统中有 100 个程序，那么程序 1 访问完资源后，即使其它 99 个程序不需要访问，也必须要等令牌在其他 99 个程序传递完后，才能重新访问资源，这就降低了系统的实时性。</p>
<p>综上，令牌环算法非常适合通信模式为令牌环方式的分布式系统，例如移动自组织网络系统。一个典型的应用场景就是无人机通信。</p>
<p>小结一下：令牌环算法的公平性高，在改进单点故障后，稳定性也很高，适用于系统规模较小，并且系统中每个程序使用临界资源的频率高且使用时间比较短的场景。</p>
<h2 id="知识扩展有适合大规模系统中的分布式互斥算法吗">知识扩展：有适合大规模系统中的分布式互斥算法吗？</h2>
<p>可以看到，上面提到的集中式、分布式和令牌环 3 个互斥算法，都不适用于规模过大、节点数量过多的系统。那么，什么样的互斥算法适用于大规模系统呢？</p>
<p>由于大规模系统的复杂性，我们很自然地想到要用一个相对复杂的互斥算法。时下有一个很流行的互斥算法，两层结构的分布式令牌环算法，把整个广域网系统中的节点组织成两层结构，可以用于节点数量较多的系统，或者是广域网系统。</p>
<p>我们知道，广域网由多个局域网组成，因此在该算法中，局域网是较低的层次，广域网是较高的层次。每个局域网中包含若干个局部进程和一个协调进程。局部进程在逻辑上组成一个环形结构，在每个环形结构上有一个局部令牌 T 在局部进程间传递。局域网与局域网之间通过各自的协调进程进行通信，这些协调进程同样组成一个环结构，这个环就是广域网中的全局环。在这个全局环上，有一个全局令牌在多个协调进程间传递。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql中的MDL]]></title>
        <id>https://q456qq520.github.io/post/mysql-zhong-de-mdl/</id>
        <link href="https://q456qq520.github.io/post/mysql-zhong-de-mdl/">
        </link>
        <updated>2022-03-07T03:54:23.000Z</updated>
        <content type="html"><![CDATA[<p>首先简单了解一下 mysql 的 sql 类型：</p>
<p>1、数据定义语言 DDL：Create、Drop、Alter 操作。用于定义库和表结构的。</p>
<p>2、数据查询语言 DQL：select。用于查询数据的。</p>
<p>3、数据操纵语言 DML：insert、update、delete。对行记录进行增删改操作。</p>
<p>4、数据控制语言 DCL：grant、revoke、commit、rollback。控制数据库的权限和事务。</p>
<h2 id="mdl">MDL</h2>
<p>MDL（MetaData Lock）就是针对于 DDL 与 DML、DQL 操作加锁，执行 DDL 自动添加写锁，执行 DML、DQL 自动添加读锁，也就是说 DML 语句可以同时执行（不考虑其他锁），而 DDL 间则会相互阻塞。</p>
<h4 id="为什么在执行-ddl-时会添加写锁">为什么在执行 DDL 时会添加写锁</h4>
<p>DDL 在执行会先创建一个临时表，先将表的数据全部移到这个临时表中，然后再将临时表替换当前表。在这个过程中如果出现读写操作就会影响最终结果出错。这个过程耗时主要在将原表的数据移到临时表的过程。</p>
<h2 id="执行">执行</h2>
<p>不同事务的执行是按队列顺序进行的，如果两个事务所执行的 MDL 添加的分别是读、写锁，那么就会互斥，后面的事务只有等到前面事务提交释放锁后才能执行。</p>
<p>例子：假设有四个会话：session1、session2、session3、session4 ，首先先依次开启事务，然后session1，session2 先执行查询操作（为了避免可能是可串行化级别导致加的写锁冲突，所以就使用查询操作），session1，session2 中的操作可以正常执行，session3执行 Alter 修改表结构，此时 session3 的操作就会阻塞（因为 MDL 的读写锁冲突），session4 再执行增删改查也会被阻塞，因为是在队列中，它位于 session3 后面，所以只有等到 session3 提交后其才能继续执行。</p>
<h2 id="online-ddl">Online DDL</h2>
<p>可以看到执行和显示顺序是图中标注的从1开始递增按顺序执行的。可以看到 session4 在 session2 提交后就立刻会执行，并且在 session4 提交后 session3 才能执行成功，这个和前面所说的理论就会冲突。这个原因是当前 mysql 版本是5.6，而在 mysql 5.6 支持 Online DDL。</p>
<p>Online DDL 是对 MDL 的一种优化，因为如果按照 MDL 的执行逻辑，像上面这种情况，一旦一些简单的读写操作比某一条 DDL 语句启动慢一些，就会陷入阻塞，如果 DDL 修改的是大表且是高频表，那么在这条语句执行时会阻塞所有的读写操作，很容易使数据库崩溃。而 Online DDL 优化思路就是在获取到锁之后先允许一段时间的读写操作，直到临时表的数据转移完成，再停止其他读写操作，而具体实现就主要分为下面几步，</p>
<ol>
<li>
<p>拿MDL写锁</p>
</li>
<li>
<p>降级成MDL读锁，接受读写操作，读操作直接正常返回，写操作会被记录下来，等待后面更新到临时表中。</p>
</li>
<li>
<p>真正做DDL，在 DDL 表记录向临时表转移完成并执行完记录的写操作后开始阻塞读写操作。</p>
</li>
<li>
<p>升级成MDL写锁，进行临时表的替换</p>
</li>
<li>
<p>释放MDL锁</p>
</li>
</ol>
<h4 id="注意点">注意点</h4>
<ol>
<li>Online DDL 整个过程是在 InnoDB 内部执行的，对于 Server 来说并没有什么操作，所以这个操作是 &quot;inplace&quot; 的，也就是说：</li>
</ol>
<p>Online 过程一定是 inplace 的，但 inplace 过程不一定是 Online 的。</p>
<ol start="2">
<li>5.6 开始因为支持 Online DDL，所以在向临时表迁移数据时可能会积攒一些写操作造成页分裂，同时在创建新表时每个数据页还会留 1/16 的空间用于更新操作，所以执行DDL后的表结构不一定是最 &quot;紧凑&quot; 的。</li>
<li>5 .6以后 ALGORITHM=INPLACE 这个参数不会表复制</li>
<li>例子：ALTER TABLE tbl_name ADD COLUMN column_name column_definition, ALGORITHM=INPLACE, LOCK=NONE;</li>
</ol>
<h2 id="mdl-引发的问题">MDL 引发的问题</h2>
<p>在上线项目中，如果需要对某个大表的字段进行删除，那么必然会阻塞该表的所有增删改查操作，如果该表存储了热点数据，那么就会阻塞大量的操作，最终导致数据库崩溃。</p>
<p><strong>解决</strong></p>
<p>1、查看当前是否存在长事务，如果存在，先尽快将其提交，防止长事务的MDL写锁阻塞<br>
2、为 DDL 的操作设置过期时间，如果时间内没有成功执行就取消。可以使用 Github 的开源工具 gh-ost。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-online-ddl.html">MDL</a></p>
]]></content>
    </entry>
</feed>