<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://q456qq520.github.io</id>
    <title>LIKE CAT</title>
    <updated>2022-03-18T09:26:59.081Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://q456qq520.github.io"/>
    <link rel="self" href="https://q456qq520.github.io/atom.xml"/>
    <subtitle>一条小咸鱼</subtitle>
    <logo>https://q456qq520.github.io/images/avatar.png</logo>
    <icon>https://q456qq520.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, LIKE CAT</rights>
    <entry>
        <title type="html"><![CDATA[流程引擎]]></title>
        <id>https://q456qq520.github.io/post/liu-cheng-yin-qing/</id>
        <link href="https://q456qq520.github.io/post/liu-cheng-yin-qing/">
        </link>
        <updated>2022-03-17T08:12:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="流程概念">流程概念</h1>
<h2 id="流程的定义">流程的定义</h2>
<p>维基百科：对工作流程及其各操作步骤之间业务规则的抽象、概括描述。即将工作流程中的工作如何前后组织在一起的逻辑和规则。</p>
<p>流程就是一组活动按照一定的顺序组成的序列流，其顺序可能是串行的、并行的，或者两者的组合模式</p>
<p>流程一般具备六个要素：输入、活动、活动间的相互作用、输出、流程的服务对象和价值。</p>
<ul>
<li>输入：是运作流程所必须的资源</li>
<li>输出：流程运作的结果</li>
<li>活动：是流程运作的环节</li>
<li>活动间的相互作用：是环节之间的关系，把流程从头尾串联起来</li>
<li>价值：是流程运作为流程的服务对象带来的好处</li>
<li>流程的服务对象：是流程服务的对象，也叫做流程的下一个环节</li>
</ul>
<h1 id="为什么要用流程引擎">为什么要用流程引擎</h1>
<h2 id="工作流程常见问题">工作流程常见问题</h2>
<ol>
<li>
<p>做需求时考虑不周全，上线后不断修改流程。</p>
</li>
<li>
<p>组织架构调整，产生业务流程变更。</p>
</li>
<li>
<p>业务流程比较复杂，使用的状态很多。</p>
</li>
<li>
<p>工作流业务耦合度太高，很多场景不适用。</p>
</li>
</ol>
<h2 id="例子">例子</h2>
<p>假定我们有一个支付订单状态需要维护，它的状态图如下：</p>
<p>它的状态跃迁自左向右，清晰名了，而且没有处理角色的概念，此时我们使用代码控制好状态流转即可，无需使用框架。</p>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1647572517222.png" alt="流程1" loading="lazy"></figure>
<p>假设有一天流程变更为下图所示：</p>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1647572617376.png" alt="流程2" loading="lazy"></figure>
<p>如果是开发人员，看到的则是：</p>
<pre><code>public function do(int case){
   if(case == 0){
       //业务逻辑
       retutn;
   }
    if(case == 1){
       //业务逻辑
       retutn;
   }
    if(case == 2){
       //业务逻辑
       retutn;
   }
   .
   .
   .
}
</code></pre>
<p>这个采购订单的状态复杂多变，状态的转换不稳定性很强，随时有可能增加新的状态；而且不同状态的处理人也是不同的，存在权限管理功能，若此时我们仍然使用一个状态字段来维持状态变更，无疑会困难重重。</p>
<p>复杂繁多的业务流程如果采用 if else 实现那将是崩溃的，代码不可维护，业务流程在代码中可读性很差，所以就有了业务流程模型图示 BPMN2.0 规范，我们要做到就是把业务场景抽象为标准流程图，把流程图丢到流程引擎中按流程定义约定逐步流转，很显然扩展性和业务可描述性会好很多，所以工作流引擎主要用于解决复杂的业务。</p>
<h2 id="流程引擎适用场景">流程引擎适用场景</h2>
<ol>
<li>
<p>状态的个数及其稳定性，个数多且不稳定，适合使用工作流引擎。</p>
</li>
<li>
<p>每个状态的处理人，处理人角色多且不稳定，适合使用工作流引擎。</p>
</li>
</ol>
<h2 id="流程引擎优缺点">流程引擎优缺点</h2>
<h3 id="优点">优点</h3>
<pre><code>- 具有可视化的流程设计工具
- 业务数据和流程数据的分离，可以进行更专注的性能优化，业务划分
- 内置API能很好的完成常见的功能场景
- 具有完善的流程监控体系
- 具备大量的自定义扩展接口
</code></pre>
<h1 id="工作流规范简介">工作流规范简介</h1>
<p>20 世纪 70 年代中期，工作流出现并运用于办公自动化领域，使流程管理技术第一次有了系统的技术规范。20 世纪 80 年代 初期，工作流伴随着 OA 系统走向商用，但是应用范围有限。至 80 年代后期，OA 系统的研究被群件和工作流管理系统所代替。20 世纪 90 年代以后，相关技术逐渐成熟，工作流管理联盟(WfMC)成立并发布了工作流参考模型。进入 21 世纪， BPM 更进一步发展。SOA 的出现使得流程管理技术从工作流转向业务流，基于此的一系列规范也相应被推出。</p>
<figure data-type="image" tabindex="3"><img src="https://q456qq520.github.io/post-images/1647574593657.png" alt="流程管理技术发展时间线" loading="lazy"></figure>
<h2 id="bpmn20-规范">BPMN2.0 规范</h2>
<p>业务流程模型和标记法（BPMN, Business Process Model and Notation）是一套图形化表示法，用于以图形的方式详细说明各种业务流程。</p>
<p>它最初由业务流程管理倡议组织（BPMI, Business Process Management Initiative）开发，名称为”Business Process Modeling Notation”，即“业务流程建模标记法”。BPMI 于 2005 年与对象管理组织（OMG, Object Management Group）合并。2011 年 1 月 OMG 发布 2.0 版本（时至今日，没人会用 1.0 版本了），同时改为现在的名称。</p>
<p>BPMN2.0 规范的实现，实质上是一个按照特定规范编写的 XML 文件，使用特定的 BPMN 设计器，即可以图形化的形式查看和编辑该文件。Camunda，Activiti，Flowable 等主流的 java 开源流程引擎，以代码的形式实现了这套图形化表示法，使任务的流转依赖图形，而非具体的实现代码。</p>
<figure data-type="image" tabindex="4"><img src="https://q456qq520.github.io/post-images/1647574956600.png" alt="BPMN2.0规范图1" loading="lazy"></figure>
<h1 id="开源流程引擎">开源流程引擎</h1>
<p>目前 java 主流的开源流程引擎，有 jBPM，Activiti，Camunda，Flowable 等</p>
<p>Activiti<br>
Activiti 由 Alfresco 公司开发，目前最高版本为 Activiti cloud 7.1.0。其中 activiti5 和 activiti6 的核心 leader 是 Tijs Rademakers，由于团队内部分歧，2017 年 Tijs Rademakers 离开团队，创建了后来的 Flowable。activiti6 以及 activiti5 代码则交接给 Salaboy 团队维护，activiti6 以及 activiti5 的代码官方已经暂停维护。往后 Salaboy 团队开发了 activiti7 框架，activiti7 内核使用的还是 activiti6，并没有为引擎注入更多的新特性，只是在 Activiti 之外的上层封装了一些应用。直到 Activiti cloud 7.1.0 版本，Activiti cloud 将系统拆分为 Runtime Bundle、Audit Service、Query Service、Cloud Connectors、Application Service、Notification Service。这些工作的主要目的其实就是为了上云，减少对 Activiti 依赖的耦合，需要使用 Activiti 的系统只需要通过调用 http 接口的方式来实现工作流能力的整合，将工作流业务托管上云。</p>
<p>Flowable<br>
Flowable 是基于 activiti6 衍生出来的版本，目前最新版本是 v6.7.0。开发团队是从 Activiti 中分裂出来的，修复了一众 activiti6 的 bug，并在其基础上实现了 DMN 支持，BPEL 支持等。相对开源版，其商业版的功能会更强大。Flowable 是一个使用 Java 编写的轻量级业务流程引擎，使用 Apache V2 license 协议开源。2016 年 10 月，Activiti 工作流引擎的主要开发者离开 Alfresco 公司并在 Activiti 分支基础上开启了 Flowable 开源项目。Flowable 项目中包括 BPMN（Business Process Model and Notation）引擎、CMMN（Case Management Model and Notation）引擎、DMN（Decision Model and Notation）引擎和表单引擎（Form Engine）等模块。</p>
<p>Camunda<br>
Camunda 基于 activiti5，所以其保留了 PVM，最新版本 Camunda7.17，开发团队也是从 activiti 中分裂出来的，发展轨迹与 Flowable 相似。通过压力测试验证 Camunda BPMN 引擎性能和稳定性更好。功能比较完善，除了 BPMN，Camunda 还支持 CMMN（案例管理）和 DMN（决策自动化）。Camunda 不仅带有引擎，还带有非常强大的工具，用于建模、任务管理、操作监控和用户管理。</p>
<p>jBPM<br>
jBPM 由 JBoss 公司开发，目前最高版本 7.61.0.Final，不过从 jBPM5 开始已经跟之前不是同一个产品了，jBPM5 的代码基础不是 jBPM4，而是从 Drools Flow 重新开始，基于 Drools Flow 技术在国内市场上用的很少，jBPM4 诞生的比较早，后来 jBPM4 创建者 Tom Baeyens 离开 JBoss 后，加入 Alfresco 后很快推出了新的基于 jBPM4 的开源工作流系统 Activiti，另外 jBPM 以 Hibernate 作为数据持久化 ORM，而 Hibernate 也已不是主流技术。</p>
<p>osworkflow<br>
osworkflow 是一个轻量化的流程引擎，基于状态机机制，数据库表很少，osworkflow 提供的工作流构成元素有：步骤（step）、条件（conditions）、循环（loops）、分支（spilts）、合并（joins）等，但不支持会签、跳转、退回、加签等这些操作，需要自己扩展开发，有一定难度。如果流程比较简单，osworkflow 是很好的选择。</p>
<p>选型建议：</p>
<pre><code>Flowable6 &gt; Activiti7 &gt; Activiti6 &gt; Activiti5 &gt; Camunda &gt; jBPM7
</code></pre>
<h1 id="表单引擎">表单引擎</h1>
<p>表单引擎，也可以称为表单流程，流程表单和工作流表单，是基于Web界面上可视化编辑的表单设计系统。它可以设置数据库的字段和属性，并设置模块的配置。</p>
<h2 id="表单构成">表单构成</h2>
<p>表单内容一般由基本信息、逻辑主体、补充说明三部分构成：</p>
<p>基本信息：基本就是常规信息，差不多每个表单都会用到的，例如：发起人、发起组织、发起时间等身份标识，与业务相关的客户基本信息或者合同基本信息等。</p>
<p>逻辑主体：流程的主要部分，相当于流程的详细描述，涉及逻辑交互、数据交互等，比如合同具体成交的业务类型、费用、数量、付款和回款信息等。</p>
<p>补充说明：作为逻辑主体没有表达清楚的补充说明，例如备注、说明、附件等让相关人员将表单没表达清楚的部分表达清楚。</p>
<h2 id="字段设置">字段设置</h2>
<p>字段设置个性化、灵活性越高，流程引擎能面向的用户则更广，能达到的管理要求也更高。</p>
<p>1）字段排版排序：字段排版、排序要符合用户使用习惯，有逻辑关联的字段要放一起，不要隔开；例如：客户姓名后放了一堆合同信息，最后又放一个客户地址，这样填写和审批都不方便，打乱使用者思维；合理的排序在数据列表展示或导出时都省事不少，表单在使用过程中会不断优化调整，优化后的字段页面上也要及时取消，避免增加页面空值字段。</p>
<p>2）字段查看权限：有的字段比如上传的附件资料，不允许某些节点处理人查阅，则会限制查看。</p>
<p>3）字段编辑权限：不是所有字段在所有节点都允许编辑，所以要根据字段的数据管理要求来设置字段在不同节点的编辑属性。</p>
<p>4）字段留痕：字段修改和留痕关联，重要的字段修改后如果找不到修改人只有系统背锅。有的字段在员工节点填写后，上级节点需要再确认修改；或者流程已结束再修改字段内容的情况就需要将修改痕迹保留下来；留痕就是日志，需要考虑痕迹的重要性，如果重要性不高的字段就不必设置留痕，浪费服务器空间。</p>
<p>5）字段只读：自动填充的关联数据有的能修改，有的不能修改，如果有只读这个控制开关便能更好管理，默认情况应该将自动填充的关联数据都设置只读；设置了只读的字段，一定要关闭必填属性，否则当关联数据空值或者关联失败时，用户是无法提交表单的，设计者应该避免犯这种常规错误。</p>
<p>6）修改字段值：很多流程结束后但需要修改页面内容，需要考虑是否允许不通过节点，直接更改页面表单值，如果允许直接修改已有值，那必须得留痕；但应该尽量避免这种情况，如果直接修改已有值会让流程规范变得更难，使用者对于规范会越来越不重视。</p>
<h2 id="关联数据">关联数据</h2>
<p>1）页面字段数据：表单除了要手动输入的数据外，还有很多数据是由其他表单关联过来的；选择关键字段后会自动带出关联数据，有的表单可能一个字段都不填，打开流程所有数据都自动填充了；有的数据也只需要选择关键字段就自动填充；常规人事、行政审批对数据串联要求不高，但财务或者业务，逻辑关联性较强，涉及数据多，数据串联就变得非常重要。</p>
<p>2）流程相关数据：除了自动填充表单字段数据外，还要将影响审批判断但表单上没有的数据体现出来，便于审批；例如项目请款，同一个合同所有的请款历史、项目信息都应该展示出来，让审批人能快速做审批判断。</p>
<h2 id="表单引擎单优点">表单引擎单优点</h2>
<p>1.技术人员在有详细需求文档的情况下，通过表单引擎可快速实现表单功能。</p>
<p>2.轻松维护系统。</p>
<p>3.提高工作效率。即使是个性化的系统定制也可以批量化的实现业务功能。</p>
<p>4.快速更新。您可以随时根据用户要求添加或删除字段和统计信息，摘要以及数据导入和导出，而无需修改任何代码行。可以在半小时内自定义演示，以赢得客户的信任。</p>
<p>5.个性化的DIY系统。使用表单引擎系统快速定义其他系统，例如：行政管理，客户关系，采购管理，请假表单，人事档案等。</p>
<h1 id="表单-流程引擎的关系">表单、流程引擎的关系</h1>
<p>流程引擎与表单引擎的关系，就是车的制动系统与车厢的关系。</p>
<p>汽车的控制系统控制前进、转向、后退、鸣笛、刹车等，流程引擎控制功能有发送、移交、退回、关注、删除等。</p>
<p>汽车的车厢可以填充货物，流程的表单可以传递数据。汽车的控制系统、车厢、货物与流程引擎、表单引擎、表单数据三者的关系类似。</p>
<p>表单引擎与流程引擎，就类似于汽车的控制系统与汽车的车厢一样。</p>
<p>流程 = 控制系统  表单 = 货物盒子  数据 = 货物</p>
<h2 id="引擎测试">引擎测试</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高性能Mysql]]></title>
        <id>https://q456qq520.github.io/post/gao-xing-neng-mysql/</id>
        <link href="https://q456qq520.github.io/post/gao-xing-neng-mysql/">
        </link>
        <updated>2022-03-15T06:12:26.000Z</updated>
        <content type="html"><![CDATA[<h6 id="文章基于mysql55">文章基于mysql5.5</h6>
<h1 id="一-mysql架构与历史">一 mysql架构与历史</h1>
<h2 id="11-mysql逻辑架构">1.1 mysql逻辑架构</h2>
<p>下图为mysql各组件之间协同工作的架构图<br>
<img src="https://q456qq520.github.io/post-images/1647325954273.png" alt="mysql逻辑架构图" loading="lazy"></p>
<ol>
<li>最上层不是mysql特有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。</li>
<li>第二层为大多数mysql核心服务所在的位置，包括解析、分析、优化、缓存及所有内置函数、所有跨存储引擎的功能（存储过程、触发器、视图等）都在这一层实现。</li>
<li>第三次包含了存储引擎，负责数据都存储与提取。</li>
</ol>
<h3 id="111-连接管理与安全性">1.1.1 连接管理与安全性</h3>
<p>每个客户端连接都会在服务器进程中<strong>拥有</strong>一个线程，这个连接对查询只会单独在这个线程中执行，该线程只能轮流在某个cpu中运行，服务器会负责缓存栈线程，因此不必每个新建的连接都需要创建或者销毁线程。</p>
<h3 id="112-优化与执行">1.1.2 优化与执行</h3>
<p>mysql会解析查询，并创建内部数据结构（解析树），然后对其进行优化。包括重新给查询、决定表的读取顺以及选择合适的索引等。</p>
<p>对于select语句在解析查询之前，服务器会先检查查询缓存如果能能在其中找到对应的查询，服务器就不必在执行查询解析。</p>
<h2 id="12-并发控制">1.2 并发控制</h2>
<p>无论何时，只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题。下面将从2个方面在说明并发控制：服务器层与存储引擎层。</p>
<h3 id="121-读写锁">1.2.1 读写锁</h3>
<p>读取数据的时候，即使同一时刻有多个用户读取数据也不会有什么问题，因为此时数据没有发生改变，用户读到到数据都是同一份。</p>
<p>但是如果在读取到时候另一个用户试图修改数据，就有可能读错或者读取到数据不一致到情况。</p>
<p>解决这类问题到方法就是并发控制，在处理并发读或者写时，可以通过实现由2种类型的锁组成的锁系统来解决问题。也就是俗称的<strong>共享锁</strong>与<strong>排他锁</strong>，也叫做读锁或者写锁。读锁是共享的，或者说是互不阻塞的，多个用户可以在统一时刻读取‍同一资源而且互不干扰。写锁是排他的，也就是说一个写锁会阻塞其他的写锁或者读锁，确保在给定时间内只有一个用户能执行写入操作，防止其他用户读取正在写入的其他资源，这也是处于安全策略的考虑。</p>
<h3 id="122-锁粒度">1.2.2 锁粒度</h3>
<p>一种提高共享资源并发性的方式就是让锁定的对象更具选择性。尽量只锁定需要修改的部分数据，而不是所有资源，更理想的方式就是只会对需要修改的数据片进行精确的锁定。任何时候，在给定的资源上，锁定的数据流越少，系统的并发性越高。只要相互之间不发生冲突即可。</p>
<p>问题是加锁也需要消耗资源。锁的各种操作，包括获得锁，检查锁是否以及接触、释放锁等都会增加系统的开销。如果花费大量时间来管理锁而不是存取数据，那么系统的性能也会因此受到影响。</p>
<p>所谓锁策略，就是在锁开销与数据安全性之前平衡，这种平衡也会影响到性能，这是不可避免的。大多数都是在表上加行级锁，并以各种复杂的方式来实现，以便在锁较多的情况下尽可能地提供更好的性能。</p>
<p>在mysql中每种存储引擎都可以实现自己的锁策略和锁粒度。将锁粒度固定在某个级别可以更好为某些特定场景提供性能支持，但同时也会失去对另一些应用场景对良好支持。</p>
<h3 id="123-表锁">1.2.3 表锁</h3>
<p>表锁是mysql最基本的锁策略，并且是开销最小的锁策略。他的工作思路是会锁住整张表，一个用户对表进行插入、更新、删除操作需要先获得锁，这回阻塞娶她用户对这张表的读写操作。只要没有写锁时，其他用户才能获得读锁，读锁之前是不互相阻塞的。</p>
<p>在某些特定的场景下，表锁也有良好的性能。比如READ LOCAL支持某些类型的并发写操作。另外，写锁也比读锁拥有更高的优先级，因此一个写锁请求可能会被插入到读锁请求队列前面，但是反之则不能。</p>
<h3 id="124-行级锁">1.2.4 行级锁</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[迭代器模式]]></title>
        <id>https://q456qq520.github.io/post/die-dai-qi-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/die-dai-qi-mo-shi/">
        </link>
        <updated>2022-03-14T01:55:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="意图">意图</h1>
<p><strong>迭代器模式</strong>是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。</p>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/content/iterator/iterator-zh-2x.png" alt="likecat" loading="lazy"></figure>
<h1 id="问题">问题</h1>
<p>集合是编程中最常使用的数据类型之一。 尽管如此， 集合只是一组对象的容器而已。</p>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/iterator/problem1-2x.png" alt="各种类型的集合" loading="lazy"></figure>
<p>大部分集合使用简单列表存储元素。 但有些集合还会使用栈、 树、 图和其他复杂的数据结构。</p>
<p>无论集合的构成方式如何， 它都必须提供某种访问元素的方式， 便于其他代码使用其中的元素。 集合应提供一种能够遍历元素的方式， 且保证它不会周而复始地访问同一个元素。</p>
<p>如果你的集合基于列表， 那么这项工作听上去仿佛很简单。 但如何遍历复杂数据结构 （例如树） 中的元素呢？ 例如， 今天你需要使用深度优先算法来遍历树结构， 明天可能会需要广度优先算法； 下周则可能会需要其他方式 （比如随机存取树中的元素）。</p>
<figure data-type="image" tabindex="3"><img src="https://refactoringguru.cn/images/patterns/diagrams/iterator/problem2-2x.png" alt="可通过不同的方式遍历相同的集合" loading="lazy"></figure>
<p>不断向集合中添加遍历算法会模糊其 “高效存储数据” 的主要职责。 此外， 有些算法可能是根据特定应用订制的， 将其加入泛型集合类中会显得非常奇怪。</p>
<p>另一方面， 使用多种集合的客户端代码可能并不关心存储数据的方式。 不过由于集合提供不同的元素访问方式， 你的代码将不得不与特定集合类进行耦合。</p>
<h1 id="解决方案">解决方案</h1>
<p>迭代器模式的主要思想是将集合的遍历行为抽取为单独的迭代器对象。</p>
<figure data-type="image" tabindex="4"><img src="https://refactoringguru.cn/images/patterns/diagrams/iterator/solution1-2x.png" alt="迭代器可实现多种遍历算法。 多个迭代器对象可同时遍历同一个集合" loading="lazy"></figure>
<p>除实现自身算法外， 迭代器还封装了遍历操作的所有细节， 例如当前位置和末尾剩余元素的数量。 因此， 多个迭代器可以在相互独立的情况下同时访问集合。</p>
<p>迭代器通常会提供一个获取集合元素的基本方法。 客户端可不断调用该方法直至它不返回任何内容， 这意味着迭代器已经遍历了所有元素。</p>
<p>所有迭代器必须实现相同的接口。 这样一来， 只要有合适的迭代器， 客户端代码就能兼容任何类型的集合或遍历算法。 如果你需要采用特殊方式来遍历集合， 只需创建一个新的迭代器类即可， 无需对集合或客户端进行修改。</p>
<h1 id="真实世界类比">真实世界类比</h1>
<figure data-type="image" tabindex="5"><img src="https://refactoringguru.cn/images/patterns/content/iterator/iterator-comic-1-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>你计划在罗马游览数天， 参观所有主要的旅游景点。 但在到达目的地后， 你可能会浪费很多时间绕圈子， 甚至找不到罗马斗兽场在哪里。</p>
<p>或者你可以购买一款智能手机上的虚拟导游程序。 这款程序非常智能而且价格不贵， 你想在景点待多久都可以。</p>
<p>第三种选择是用部分旅行预算雇佣一位对城市了如指掌的当地向导。 向导能根据你的喜好来安排行程， 为你介绍每个景点并讲述许多激动人心的故事。 这样的旅行可能会更有趣， 但所需费用也会更高。</p>
<p>所有这些选择(自由漫步、 智能手机导航或真人向导)都是这个由众多罗马景点组成的集合的迭代器。</p>
<h1 id="迭代器模式结构">迭代器模式结构</h1>
<figure data-type="image" tabindex="6"><img src="https://refactoringguru.cn/images/patterns/diagrams/iterator/structure-2x.png" alt="likecat" loading="lazy"></figure>
<ol>
<li>
<p><strong>迭代器 （Iterator）</strong> 接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。</p>
</li>
<li>
<p><strong>具体迭代器 （Concrete Iterators）</strong> 实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。</p>
</li>
<li>
<p><strong>集合</strong>（Collection）接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意， 返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。</p>
</li>
<li>
<p><strong>具体集合（Concrete Collections）</strong> 会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 你可能会琢磨， 剩下的集合代码在什么地方呢？ 不用担心， 它也会在同一个类中。 只是这些细节对于实际模式来说并不重要， 所以我们将其省略了而已。</p>
</li>
<li>
<p><strong>客户端</strong> （Client）通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。</p>
<p>客户端通常不会自行创建迭代器， 而是会从集合中获取。 但在特定情况下， 客户端可以直接创建一个迭代器 （例如当客户端需要自定义特殊迭代器时）。</p>
</li>
</ol>
<h2 id="迭代器模式适合应用场景">迭代器模式适合应用场景</h2>
<ol>
<li>
<p>当集合背后为复杂的数据结构， 且你希望对客户端隐藏其复杂性时 （出于使用便利性或安全性的考虑）， 可以使用迭代器模式。</p>
<p>迭代器封装了与复杂数据结构进行交互的细节， 为客户端提供多个访问集合元素的简单方法。 这种方式不仅对客户端来说非常方便， 而且能避免客户端在直接与集合交互时执行错误或有害的操作， 从而起到保护集合的作用。</p>
</li>
<li>
<p>使用该模式可以减少程序中重复的遍历代码。</p>
<p>重要迭代算法的代码往往体积非常庞大。 当这些代码被放置在程序业务逻辑中时， 它会让原始代码的职责模糊不清， 降低其可维护性。 因此， 将遍历代码移到特定的迭代器中可使程序代码更加精炼和简洁。</p>
</li>
<li>
<p>如果你希望代码能够遍历不同的甚至是无法预知的数据结构， 可以使用迭代器模式。</p>
</li>
</ol>
<pre><code>该模式为集合和迭代器提供了一些通用接口。 如果你在代码中使用了这些接口， 那么将其他实现了这些接口的集合和迭代器传递给它时， 它仍将可以正常运行。
</code></pre>
<h1 id="实现方式">实现方式</h1>
<ol>
<li>
<p>声明迭代器接口。 该接口必须提供至少一个方法来获取集合中的下个元素。 但为了使用方便， 你还可以添加一些其他方法， 例如获取前一个元素、 记录当前位置和判断迭代是否已结束。</p>
</li>
<li>
<p>声明集合接口并描述一个获取迭代器的方法。 其返回值必须是迭代器接口。 如果你计划拥有多组不同的迭代器， 则可以声明多个类似的方法。</p>
</li>
<li>
<p>为希望使用迭代器进行遍历的集合实现具体迭代器类。 迭代器对象必须与单个集合实体链接。 链接关系通常通过迭代器的构造函数建立。</p>
</li>
<li>
<p>在你的集合类中实现集合接口。 其主要思想是针对特定集合为客户端代码提供创建迭代器的快捷方式。 集合对象必须将自身传递给迭代器的构造函数来创建两者之间的链接。</p>
</li>
<li>
<p>检查客户端代码， 使用迭代器替代所有集合遍历代码。 每当客户端需要遍历集合元素时都会获取一个新的迭代器。</p>
</li>
</ol>
<h1 id="迭代器模式优缺点">迭代器模式优缺点</h1>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>单一职责原则。 通过将体积庞大的遍历算法代码抽取为独立的类， 你可对客户端代码和集合进行整理。</td>
<td style="text-align:center">如果你的程序只与简单的集合进行交互， 应用该模式可能会矫枉过正。</td>
</tr>
<tr>
<td>开闭原则。 你可实现新型的集合和迭代器并将其传递给现有代码， 无需修改现有代码。</td>
<td style="text-align:center">对于某些特殊集合， 使用迭代器可能比直接遍历的效率低。</td>
</tr>
<tr>
<td>你可以并行遍历同一集合， 因为每个迭代器对象都包含其自身的遍历状态。</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>相似的， 你可以暂停遍历并在需要时继续。</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h1 id="与其他模式的关系">与其他模式的关系</h1>
<ol>
<li>
<p>你可以使用<strong>迭代器模式</strong>来遍历<strong>组合模式树</strong>。</p>
</li>
<li>
<p>你可以同时使用<strong>工厂方法模式</strong>和<strong>迭代器</strong>来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。</p>
</li>
<li>
<p>你可以同时使用<strong>备忘录模式</strong>和<strong>迭代器</strong>来获取当前迭代器的状态， 并且在需要的时候进行回滚。</p>
</li>
<li>
<p>可以同时使用<strong>访问者模式</strong>和<strong>迭代器</strong>来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同。</p>
</li>
</ol>
<h1 id="伪代码">伪代码</h1>
<h2 id="迭代访问社交网络档案">迭代访问社交网络档案</h2>
<p>在本例中， 迭代器模式被用于在不向客户端代码暴露通信细节的情况下访问远程社交网络集合中的社交媒体档案。</p>
<h3 id="社交档案">社交档案</h3>
<pre><code>package com.iterator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * 社交档案
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:35
 */
public class Profile {

    private String name;
    private String email;
    private Map&lt;String, List&lt;String&gt;&gt; contacts = new HashMap&lt;&gt;();

    public Profile(String email, String name, String... contacts) {
        this.email = email;
        this.name = name;

        // Parse contact list from a set of &quot;friend:email@gmail.com&quot; pairs.
        for (String contact : contacts) {
            String[] parts = contact.split(&quot;:&quot;);
            String contactType = &quot;friend&quot;, contactEmail;
            if (parts.length == 1) {
                contactEmail = parts[0];
            }
            else {
                contactType = parts[0];
                contactEmail = parts[1];
            }
            if (!this.contacts.containsKey(contactType)) {
                this.contacts.put(contactType, new ArrayList&lt;&gt;());
            }
            this.contacts.get(contactType).add(contactEmail);
        }
    }

    public String getEmail() {
        return email;
    }

    public String getName() {
        return name;
    }

    public List&lt;String&gt; getContacts(String contactType) {
        if (!this.contacts.containsKey(contactType)) {
            this.contacts.put(contactType, new ArrayList&lt;&gt;());
        }
        return contacts.get(contactType);
    }
}

</code></pre>
<h3 id="定义档案接口">定义档案接口</h3>
<pre><code>package com.iterator;

/**
 * 定义档案接口
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:34
 */
public interface ProfileIterator {
    boolean hasNext();

    Profile getNext();

    void reset();
}
</code></pre>
<h3 id="定义通用的社交网络接口">定义通用的社交网络接口</h3>
<pre><code>package com.iterator;

/**
 * 定义通用的社交网络接口
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:39
 */
public interface SocialNetwork {
    ProfileIterator createFriendsIterator(String profileEmail);

    ProfileIterator createCoworkersIterator(String profileEmail);
}
</code></pre>
<h3 id="facebook">Facebook</h3>
<pre><code>package com.iterator;

import java.util.ArrayList;
import java.util.List;

/**
 * Facebook
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:40
 */
public class Facebook implements SocialNetwork {
    private List&lt;Profile&gt; profiles;

    public Facebook(List&lt;Profile&gt; cache) {
        if (cache != null) {
            this.profiles = cache;
        } else {
            this.profiles = new ArrayList&lt;&gt;();
        }
    }

    public Profile requestProfileFromFacebook(String profileEmail) {
        // Here would be a POST request to one of the Facebook API endpoints.
        // Instead, we emulates long network connection, which you would expect
        // in the real life...
        simulateNetworkLatency();
        System.out.println(&quot;Facebook: Loading profile '&quot; + profileEmail + &quot;' over the network...&quot;);

        // ...and return test data.
        return findProfile(profileEmail);
    }

    public List&lt;String&gt; requestProfileFriendsFromFacebook(String profileEmail, String contactType) {
        // Here would be a POST request to one of the Facebook API endpoints.
        // Instead, we emulates long network connection, which you would expect
        // in the real life...
        simulateNetworkLatency();
        System.out.println(&quot;Facebook: Loading '&quot; + contactType + &quot;' list of '&quot; + profileEmail + &quot;' over the network...&quot;);

        // ...and return test data.
        Profile profile = findProfile(profileEmail);
        if (profile != null) {
            return profile.getContacts(contactType);
        }
        return null;
    }

    private Profile findProfile(String profileEmail) {
        for (Profile profile : profiles) {
            if (profile.getEmail().equals(profileEmail)) {
                return profile;
            }
        }
        return null;
    }

    private void simulateNetworkLatency() {
        try {
            Thread.sleep(2500);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
    }

    @Override
    public ProfileIterator createFriendsIterator(String profileEmail) {
        return new FacebookIterator(this, &quot;friends&quot;, profileEmail);
    }

    @Override
    public ProfileIterator createCoworkersIterator(String profileEmail) {
        return new FacebookIterator(this, &quot;coworkers&quot;, profileEmail);
    }
}
</code></pre>
<h3 id="在-facebook-档案上实现迭代">在 Facebook 档案上实现迭代</h3>
<pre><code>package com.iterator;

import java.util.ArrayList;
import java.util.List;

/**
 * 在 Facebook 档案上实现迭代
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:38
 */
public class FacebookIterator implements ProfileIterator {
    private Facebook facebook;
    private String type;
    private String email;
    private int currentPosition = 0;
    private List&lt;String&gt; emails = new ArrayList&lt;&gt;();
    private List&lt;Profile&gt; profiles = new ArrayList&lt;&gt;();

    public FacebookIterator(Facebook facebook, String type, String email) {
        this.facebook = facebook;
        this.type = type;
        this.email = email;
    }

    private void lazyLoad() {
        if (emails.size() == 0) {
            List&lt;String&gt; profiles = facebook.requestProfileFriendsFromFacebook(this.email, this.type);
            for (String profile : profiles) {
                this.emails.add(profile);
                this.profiles.add(null);
            }
        }
    }

    @Override
    public boolean hasNext() {
        lazyLoad();
        return currentPosition &lt; emails.size();
    }

    @Override
    public Profile getNext() {
        if (!hasNext()) {
            return null;
        }

        String friendEmail = emails.get(currentPosition);
        Profile friendProfile = profiles.get(currentPosition);
        if (friendProfile == null) {
            friendProfile = facebook.requestProfileFromFacebook(friendEmail);
            profiles.set(currentPosition, friendProfile);
        }
        currentPosition++;
        return friendProfile;
    }

    @Override
    public void reset() {
        currentPosition = 0;
    }
}
</code></pre>
<h3 id="在领英档案上实现迭代">在领英档案上实现迭代</h3>
<pre><code>package com.iterator;

import java.util.ArrayList;
import java.util.List;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:44
 */
public class LinkedInIterator implements ProfileIterator {
    private LinkedIn linkedIn;
    private String type;
    private String email;
    private int currentPosition = 0;
    private List&lt;String&gt; emails = new ArrayList&lt;&gt;();
    private List&lt;Profile&gt; contacts = new ArrayList&lt;&gt;();

    public LinkedInIterator(LinkedIn linkedIn, String type, String email) {
        this.linkedIn = linkedIn;
        this.type = type;
        this.email = email;
    }

    private void lazyLoad() {
        if (emails.size() == 0) {
            List&lt;String&gt; profiles = linkedIn.requestRelatedContactsFromLinkedInAPI(this.email, this.type);
            for (String profile : profiles) {
                this.emails.add(profile);
                this.contacts.add(null);
            }
        }
    }

    @Override
    public boolean hasNext() {
        lazyLoad();
        return currentPosition &lt; emails.size();
    }

    @Override
    public Profile getNext() {
        if (!hasNext()) {
            return null;
        }

        String friendEmail = emails.get(currentPosition);
        Profile friendContact = contacts.get(currentPosition);
        if (friendContact == null) {
            friendContact = linkedIn.requestContactInfoFromLinkedInAPI(friendEmail);
            contacts.set(currentPosition, friendContact);
        }
        currentPosition++;
        return friendContact;
    }

    @Override
    public void reset() {
        currentPosition = 0;
    }
}
</code></pre>
<h3 id="领英">领英</h3>
<pre><code>package com.iterator;

import java.util.ArrayList;
import java.util.List;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:42
 */
public class LinkedIn implements SocialNetwork {
    private List&lt;Profile&gt; contacts;

    public LinkedIn(List&lt;Profile&gt; cache) {
        if (cache != null) {
            this.contacts = cache;
        } else {
            this.contacts = new ArrayList&lt;&gt;();
        }
    }

    public Profile requestContactInfoFromLinkedInAPI(String profileEmail) {
        // Here would be a POST request to one of the LinkedIn API endpoints.
        // Instead, we emulates long network connection, which you would expect
        // in the real life...
        simulateNetworkLatency();
        System.out.println(&quot;LinkedIn: Loading profile '&quot; + profileEmail + &quot;' over the network...&quot;);

        // ...and return test data.
        return findContact(profileEmail);
    }

    public List&lt;String&gt; requestRelatedContactsFromLinkedInAPI(String profileEmail, String contactType) {
        // Here would be a POST request to one of the LinkedIn API endpoints.
        // Instead, we emulates long network connection, which you would expect
        // in the real life.
        simulateNetworkLatency();
        System.out.println(&quot;LinkedIn: Loading '&quot; + contactType + &quot;' list of '&quot; + profileEmail + &quot;' over the network...&quot;);

        // ...and return test data.
        Profile profile = findContact(profileEmail);
        if (profile != null) {
            return profile.getContacts(contactType);
        }
        return null;
    }

    private Profile findContact(String profileEmail) {
        for (Profile profile : contacts) {
            if (profile.getEmail().equals(profileEmail)) {
                return profile;
            }
        }
        return null;
    }

    private void simulateNetworkLatency() {
        try {
            Thread.sleep(2500);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
    }

    @Override
    public ProfileIterator createFriendsIterator(String profileEmail) {
        return new LinkedInIterator(this, &quot;friends&quot;, profileEmail);
    }

    @Override
    public ProfileIterator createCoworkersIterator(String profileEmail) {
        return new LinkedInIterator(this, &quot;coworkers&quot;, profileEmail);
    }
}
</code></pre>
<h3 id="消息发送应用">消息发送应用</h3>
<pre><code>package com.iterator;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:47
 */
public class SocialSpammer {
    public SocialNetwork network;
    public ProfileIterator iterator;

    public SocialSpammer(SocialNetwork network) {
        this.network = network;
    }

    public void sendSpamToFriends(String profileEmail, String message) {
        System.out.println(&quot;\nIterating over friends...\n&quot;);
        iterator = network.createFriendsIterator(profileEmail);
        while (iterator.hasNext()) {
            Profile profile = iterator.getNext();
            sendMessage(profile.getEmail(), message);
        }
    }

    public void sendSpamToCoworkers(String profileEmail, String message) {
        System.out.println(&quot;\nIterating over coworkers...\n&quot;);
        iterator = network.createCoworkersIterator(profileEmail);
        while (iterator.hasNext()) {
            Profile profile = iterator.getNext();
            sendMessage(profile.getEmail(), message);
        }
    }

    public void sendMessage(String email, String message) {
        System.out.println(&quot;Sent message to: '&quot; + email + &quot;'. Message body: '&quot; + message + &quot;'&quot;);
    }
}
</code></pre>
<h3 id="客户端代码">客户端代码</h3>
<pre><code>package com.iterator;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/14 10:50
 */
public class Demo {
    public static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println(&quot;Please specify social network to target spam tool (default:Facebook):&quot;);
        System.out.println(&quot;1. Facebook&quot;);
        System.out.println(&quot;2. LinkedIn&quot;);
        String choice = scanner.nextLine();

        SocialNetwork network;
        if (choice.equals(&quot;2&quot;)) {
            network = new LinkedIn(createTestProfiles());
        }
        else {
            network = new Facebook(createTestProfiles());
        }

        SocialSpammer spammer = new SocialSpammer(network);
        spammer.sendSpamToFriends(&quot;anna.smith@bing.com&quot;,
                &quot;Hey! This is Anna's friend Josh. Can you do me a favor and like this post [link]?&quot;);
        spammer.sendSpamToCoworkers(&quot;anna.smith@bing.com&quot;,
                &quot;Hey! This is Anna's boss Jason. Anna told me you would be interested in [link].&quot;);
    }

    public static List&lt;Profile&gt; createTestProfiles() {
        List&lt;Profile&gt; data = new ArrayList&lt;Profile&gt;();
        data.add(new Profile(&quot;anna.smith@bing.com&quot;, &quot;Anna Smith&quot;, &quot;friends:mad_max@ya.com&quot;, &quot;friends:catwoman@yahoo.com&quot;, &quot;coworkers:sam@amazon.com&quot;));
        data.add(new Profile(&quot;mad_max@ya.com&quot;, &quot;Maximilian&quot;, &quot;friends:anna.smith@bing.com&quot;, &quot;coworkers:sam@amazon.com&quot;));
        data.add(new Profile(&quot;bill@microsoft.eu&quot;, &quot;Billie&quot;, &quot;coworkers:avanger@ukr.net&quot;));
        data.add(new Profile(&quot;avanger@ukr.net&quot;, &quot;John Day&quot;, &quot;coworkers:bill@microsoft.eu&quot;));
        data.add(new Profile(&quot;sam@amazon.com&quot;, &quot;Sam Kitting&quot;, &quot;coworkers:anna.smith@bing.com&quot;, &quot;coworkers:mad_max@ya.com&quot;, &quot;friends:catwoman@yahoo.com&quot;));
        data.add(new Profile(&quot;catwoman@yahoo.com&quot;, &quot;Liza&quot;, &quot;friends:anna.smith@bing.com&quot;, &quot;friends:sam@amazon.com&quot;));
        return data;
    }
}
</code></pre>
<h3 id="执行结果">执行结果</h3>
<pre><code>Please specify social network to target spam tool (default:Facebook):
1. Facebook
2. LinkedIn
&gt; 1

Iterating over friends...

Facebook: Loading 'friends' list of 'anna.smith@bing.com' over the network...
Facebook: Loading profile 'mad_max@ya.com' over the network...
Sent message to: 'mad_max@ya.com'. Message body: 'Hey! This is Anna's friend Josh. Can you do me a favor and like this post [link]?'
Facebook: Loading profile 'catwoman@yahoo.com' over the network...
Sent message to: 'catwoman@yahoo.com'. Message body: 'Hey! This is Anna's friend Josh. Can you do me a favor and like this post [link]?'

Iterating over coworkers...

Facebook: Loading 'coworkers' list of 'anna.smith@bing.com' over the network...
Facebook: Loading profile 'sam@amazon.com' over the network...
Sent message to: 'sam@amazon.com'. Message body: 'Hey! This is Anna's boss Jason. Anna told me you would be interested in [link].'
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从PAXOS到ZOOKEEPER分布式一致性原理与实践]]></title>
        <id>https://q456qq520.github.io/post/cong-paxos-dao-zookeeper-fen-bu-shi-yi-zhi-xing-yuan-li-yu-shi-jian/</id>
        <link href="https://q456qq520.github.io/post/cong-paxos-dao-zookeeper-fen-bu-shi-yi-zhi-xing-yuan-li-yu-shi-jian/">
        </link>
        <updated>2022-03-11T01:50:43.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Domain Drive Design（领域驱动设计）]]></title>
        <id>https://q456qq520.github.io/post/domain-drive-designling-yu-qu-dong-she-ji/</id>
        <link href="https://q456qq520.github.io/post/domain-drive-designling-yu-qu-dong-she-ji/">
        </link>
        <updated>2022-03-10T06:23:54.000Z</updated>
        <content type="html"><![CDATA[<p>Domain Drive Design（领域驱动设计）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[重试组件]]></title>
        <id>https://q456qq520.github.io/post/chong-shi-zu-jian/</id>
        <link href="https://q456qq520.github.io/post/chong-shi-zu-jian/">
        </link>
        <updated>2022-03-10T06:22:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="什么重试机制">什么重试机制？</h1>
<p><strong>重试是为了提高成功的可能性</strong></p>
<p>反过来理解，任何可能失败且允许重试操作的场景，就适合使用重试机制。但有了重试机制就一定能成功吗？显然不是。如果不成功就一直重试，这种处理方式会使得业务线程一直被重试占用，这样会导致服务的负载线程暴增直至服务宕机，因此需要限制重试次数。失败情况下，我们需要做后续的操作，如果是数据库操作的重试，需要回滚事物；如果是服务调用的重试，需要邮件报警通知运维开发人员，恢复服务。</p>
<p>对于服务接口调用，可能是因为网络波动导致超时失败，这时候所有重试次数是在很短时间内发起的话，就很容易全部超时失败，因此超时机制还需要引入重试动作之间时间间隔以及第一次失败后延迟多长时间再开始重试等机制。</p>
<p>重试机制要素</p>
<pre><code>- 限制重试次数
- 每次重试的时间间隔
- 最终失败结果的报警或事物回滚
- 在特定失败异常事件情况下选择重试
</code></pre>
<h1 id="背景介绍">背景介绍</h1>
<p>在实际的项目应用场景中，经常会需要遇到远程服务接口的调用，时不时会出现一些接口调用超时，或者函数执行失败需要重试的情况，例如下边的这种场景：</p>
<pre><code>某些不太稳定的接口，需要依赖于第三方的远程调用，例如数据加载，数据上传相关的类型。
</code></pre>
<h1 id="基于trycatch的重试方案">基于try/catch的重试方案</h1>
<p>这种方式来做重试处理的话，会比较简单粗暴。</p>
<pre><code> public void test(){
    try{
        //执行远程调用方法
        doRef();
    }catch(Exception e){
        //重新执行远程调用方法
        doRef();
    }
}
</code></pre>
<p>当出现了异常的时候，立即执行远程调用，此时可能忽略了几个问题：</p>
<ol>
<li>如果重试出现了问题，是否还能继续重试</li>
<li>第一次远程调用出现了异常，此时可能第三方服务此时负载已达到瓶颈，或许需要间隔一段时间再发送远程调用的成功率会高些。</li>
<li>多次重试都失败之后如何通知调用方自己。</li>
</ol>
<h1 id="使用spring的retry组件">使用Spring的Retry组件</h1>
<ol>
<li>引入依赖</li>
</ol>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;
    &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>在启动类上加入一个@EnableRetry注解</li>
</ol>
<pre><code>@SpringBootApplication
@EnableRetry
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class);
    }
}
</code></pre>
<ol start="3">
<li>在需要被执行的函数头部加入这一@Retryable注解</li>
</ol>
<pre><code>@Retryable(value = Exception.class,maxAttempts = 3  , backoff = @Backoff(delay = 2000,multiplier = 1.5))
public int retryServiceOne(int code) throws Exception {
	// TODO Auto-generated method stub 
	System.out.println(&quot;retryServiceOne被调用,时间：&quot;+LocalTime.now());
	System.out.println(&quot;执行当前业务逻辑的线程名：&quot;+Thread.currentThread().getName());
	if (code==0){
	    throw new Exception(&quot;业务执行失败情况！&quot;);
	}
	System.out.println(&quot;retryServiceOne执行成功！&quot;);

	return 200;
}
</code></pre>
<p>配置元数据情况：</p>
<pre><code>- 重试次数为3
- 第一次重试延迟2s
- 每次重试时间间隔是前一次1.5倍
- Exception类异常情况下重试
</code></pre>
<h1 id="自定义重试组件">自定义重试组件</h1>
<ol>
<li>定义一个重试注解</li>
</ol>
<pre><code>package com.likecat.retry;

import java.lang.annotation.*;

/**
 * 重试组件注解
 * @author likecat
 * @version 1.0
 * @date 2022/3/11 11:41
 */
@Documented
@Target(value = ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Retry {
    //最大重试次数
    int maxAttempts() default 3;

    //每次重试的间隔时间
    int delay() default 3000;

    //关注异常（仅当抛出了相应异常的条件下才会重试）
    Class&lt;? extends Throwable&gt;[] value() default {};

    //重试策略（默认是快速重试）
    Class&lt;? extends RetryStrategy&gt; strategy() default FastRetryStrategy.class;

    //重试监听器
    Class&lt;? extends RetryListener&gt; listener() default AbstractRetryListener.class;
}
</code></pre>
<ol start="2">
<li>重试切面,拦截带有 @Retry 注解的方法，然后将需要执行的部分放入到一个RetryTask类型的对象当中，内部的doTask函数会触发真正的方法调用。</li>
</ol>
<pre><code>package com.likecat.retry;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.lang.reflect.Method;

/**
 * 重试接口的拦截和处理
 * @author likecat
 * @version 1.0
 * @date 2022/3/11 11:50
 */
@Aspect
@Component
public class RetryAop {

    @Resource
    private ApplicationContext applicationContext;

    @Pointcut(&quot;@annotation(com.likecat.retry.Retry)&quot;)
    public void pointCut() {
    }

    @Around(value = &quot;pointCut()&quot;)
    public Object doBiz(ProceedingJoinPoint point) {
        MethodSignature methodSignature = (MethodSignature) point.getSignature();
        Method method = methodSignature.getMethod();
        Retry retry = method.getDeclaredAnnotation(Retry.class);

        //获取重试策略
        RetryStrategy retryStrategy = applicationContext.getBean(retry.strategy());
        RetryTask retryTask = new RetryTaskImpl(point);
        retryStrategy.initArgs(retry, retryTask);
        try {
            Object result = point.proceed();
            return result;
        } catch (Throwable throwable) {
            //重试
            System.out.println(method.getName()+&quot;执行失败,开始重试&quot;);
            retryStrategy.retryTask();
        }
        return null;
    }

    /**
     * 重试业务
     */
    private class RetryTaskImpl implements RetryTask {
        private ProceedingJoinPoint proceedingJoinPoint;
        private Object result;
        private volatile Boolean asyncRetryState = null;
        public RetryTaskImpl(ProceedingJoinPoint proceedingJoinPoint) {
            this.proceedingJoinPoint = proceedingJoinPoint;
        }
        public ProceedingJoinPoint getProceedingJoinPoint() {
            return proceedingJoinPoint;
        }
        public void setProceedingJoinPoint(ProceedingJoinPoint proceedingJoinPoint) {
            this.proceedingJoinPoint = proceedingJoinPoint;
        }
        public Object getResult() {
            return result;
        }
        public void setResult(Object result) {
            this.result = result;
        }
        public Boolean getAsyncRetryState() {
            return asyncRetryState;
        }
        public void setAsyncRetryState(Boolean asyncRetryState) {
            this.asyncRetryState = asyncRetryState;
        }

        @Override
        public Object getRetryResult() {
            return result;
        }
        @Override
        public Boolean getRetryStatus() {
            return asyncRetryState;
        }
        @Override
        public void setRetrySuccess() {
            this.setAsyncRetryState(true);
        }
        @Override
        public void doTask() throws Throwable {
            this.result = proceedingJoinPoint.proceed();
        }
    }
}

</code></pre>
<ol start="3">
<li>RetryTask接口(重试任务)</li>
</ol>
<pre><code>package com.likecat.retry;

/**
 * 任务执行
 * @author likecat
 * @version 1.0
 * @date 2022/3/11 11:46
 */
public interface RetryTask {

    //获取重试结果
    Object getRetryResult();

    //获取重试状态
    Boolean getRetryStatus();

    void setRetrySuccess();

    //重试逻辑
    void doTask() throws Throwable;
}
</code></pre>
<ol start="4">
<li>重试策略接口</li>
</ol>
<pre><code>package com.likecat.retry;

/**
 * 重试策略
 * @author likecat
 * @version 1.0
 * @date 2022/3/11 11:41
 */
public interface RetryStrategy {

    /**
     * 初始化一些参数配置
     *
     * @param retry
     * @param retryTask
     */
    void initArgs(Retry retry,RetryTask retryTask);

    /**
     * 重试策略
     */
    void retryTask();

}

</code></pre>
<ol start="5">
<li>默认的重试策略为快速重试策略</li>
</ol>
<pre><code>package com.likecat.retry;

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

import java.util.concurrent.ExecutorService;

/**
 * 默认的重试策略为快速重试策略
 * @author likecat
 * @version 1.0
 * @date 2022/3/11 11:42
 */
public class FastRetryStrategy implements RetryStrategy, ApplicationContextAware {

    private Retry retry;
    private RetryTask retryTask;
    private ApplicationContext applicationContext;
    private ExecutorService retryThreadPool;

    public FastRetryStrategy() {
    }

    public ExecutorService getRetryThreadPool() {
        return retryThreadPool;
    }

    public void setRetryThreadPool(ExecutorService retryThreadPool) {
        this.retryThreadPool = retryThreadPool;
    }

    @Override
    public void initArgs(Retry retry, RetryTask retryTask) {
        this.retry = retry;
        this.retryTask = retryTask;
    }

    @Override
    public void retryTask() {
        if (!FastRetryStrategy.class.equals(retry.strategy())) {
            System.err.println(&quot;error retry strategy&quot;);
            return;
        }
        //安全类型bean查找
        String[] beanNames = applicationContext.getBeanNamesForType(retry.listener());
        RetryListener retryListener = null;
        if (beanNames != null &amp;&amp; beanNames.length &gt; 0) {
            retryListener = applicationContext.getBean(retry.listener());
        }
        Class&lt;? extends Throwable&gt;[] exceptionClasses = retry.value();
        RetryListener finalRetryListener = retryListener;
        //如果没有支持异步功能，那么在进行重试的时候就会一直占用着服务器的业务线程，导致服务器线程负载暴增
        retryThreadPool.submit(new Runnable() {
            @Override
            public void run() {
                for (int i = 1; i &lt;= retry.maxAttempts(); i++) {
                    int finalI = i;
                    try {
                        retryTask.doTask();
                        retryTask.setRetrySuccess();
                        return;
                    } catch (Throwable e) {
                        for (Class&lt;? extends Throwable&gt; clazz : exceptionClasses) {
                            if (e.getClass().equals(clazz) || e.getClass().isInstance(clazz)) {
                                if (finalRetryListener != null) {
                                    finalRetryListener.notifyObserver();
                                }
                                System.err.println(&quot;[FastRetryStrategy] retry again,attempt's time is &quot; + finalI + &quot;,tims is &quot; + System.currentTimeMillis());
                                try {
                                    Thread.sleep(retry.delay());
                                } catch (InterruptedException ex) {
                                    ex.printStackTrace();
                                }
                                continue;
                            }
                        }
                    }
                }
            }
        });
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
        ExecutorService executorService = (ExecutorService) applicationContext.getBean(&quot;retryThreadPool&quot;);
        this.setRetryThreadPool(executorService);
    }

}
</code></pre>
<ol start="6">
<li>通过回调对应的监听器组件做一些记录：例如日志记录，操作记录写入等等操作。</li>
</ol>
<pre><code>package com.likecat.retry;

/**
 * 通知观察者
 * @author likecat
 * @version 1.0
 * @date 2022/3/11 11:46
 */
public interface RetryListener {

    /**
     * 通知观察者
     */
    void notifyObserver();
}

</code></pre>
<ol start="7">
<li>默认抽象类</li>
</ol>
<pre><code>package com.likecat.retry;

/**
 * 默认抽象类
 * @author likecat
 * @version 1.0
 * @date 2022/3/11 11:47
 */
public abstract class AbstractRetryListener implements RetryListener {
    @Override
    public abstract void notifyObserver();
}
</code></pre>
<ol start="8">
<li>自定义监听器</li>
</ol>
<pre><code>package com.likecat.retry;

/**
 * 默认监听器
 * @author likecat
 * @version 1.0
 * @date 2022/3/11 11:47
 */
public class DefaultRetryListener implements RetryListener{

    @Override
    public void notifyObserver() {
        System.out.println(&quot;this is a DefaultRetryListener&quot;);
    }
}
</code></pre>
<ol start="9">
<li>bean的初始化配置</li>
</ol>
<pre><code>package com.likecat.retry;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/11 14:45
 */
@Configuration
public class RetryConfig {
    @Bean
    public FastRetryStrategy fastRetryStrategy(){
        return new FastRetryStrategy();
    }
    @Bean
    public RetryListener defaultRetryListener(){
        return new DefaultRetryListener();
    }
    @Bean
    public ExecutorService retryThreadPool(){
        ExecutorService executorService = new ThreadPoolExecutor(2,4,0L, TimeUnit.SECONDS,new LinkedBlockingQueue&lt;&gt;());
        return executorService;
    }
}
</code></pre>
<ol start="9">
<li>测试</li>
</ol>
<pre><code>package com.likecat.retry;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/11 14:42
 */
@RestController
public class TestController {

    public static int count = 0;

    @Retry(maxAttempts = 5, delay = 100, value = {ArithmeticException.class}, strategy = FastRetryStrategy.class, listener = DefaultRetryListener.class)
    @GetMapping(value = &quot;/do-test&quot;)
    public String doTest(int code) {
        count++;
        System.out.println(&quot;code is :&quot; + code + &quot; result is :&quot; + count % 3 + &quot; count is :&quot; + count);
        if (code == 1) {
            System.out.println(&quot;--this is a test&quot;);
        } else {
            if (count % 5 != 0) {
                System.out.println(4 / 0);
            }
        }
        return &quot;success&quot;;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[命令模式]]></title>
        <id>https://q456qq520.github.io/post/fen-bu-shi-gong-shi-cun-yi-qiu-tong/</id>
        <link href="https://q456qq520.github.io/post/fen-bu-shi-gong-shi-cun-yi-qiu-tong/">
        </link>
        <updated>2022-03-08T01:54:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="意图">意图</h1>
<p><strong>命令模式</strong>是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。</p>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/content/command/command-zh-2x.png" alt="likecat" loading="lazy"></figure>
<h1 id="问题">问题</h1>
<p>假如你正在开发一款新的文字编辑器， 当前的任务是创建一个包含多个按钮的工具栏， 并让每个按钮对应编辑器的不同操作。 你创建了一个非常简洁的按钮类， 它不仅可用于生成工具栏上的按钮， 还可用于生成各种对话框的通用按钮。</p>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/command/problem1-2x.png" alt="应用中的所有按钮都可以继承相同的类" loading="lazy"></figure>
<p>尽管所有按钮看上去都很相似， 但它们可以完成不同的操作 （打开、 保存、 打印和应用等）。 你会在哪里放置这些按钮的点击处理代码呢？ 最简单的解决方案是在使用按钮的每个地方都创建大量的子类。 这些子类中包含按钮点击后必须执行的代码。</p>
<figure data-type="image" tabindex="3"><img src="https://refactoringguru.cn/images/patterns/diagrams/command/problem2-2x.png" alt="大量的按钮子类" loading="lazy"></figure>
<p>你很快就意识到这种方式有严重缺陷。 首先， 你创建了大量的子类， 当每次修改基类 按钮时， 你都有可能需要修改所有子类的代码。 简单来说， GUI 代码以一种拙劣的方式依赖于业务逻辑中的不稳定代码。</p>
<figure data-type="image" tabindex="4"><img src="https://refactoringguru.cn/images/patterns/diagrams/command/problem3-zh-2x.png" alt="大量的按钮子类" loading="lazy"></figure>
<p>还有一个部分最难办。 复制/粘贴文字等操作可能会在多个地方被调用。 例如用户可以点击工具栏上小小的 “复制” 按钮， 或者通过上下文菜单复制一些内容， 又或者直接使用键盘上的 Ctrl+C 。</p>
<p>我们的程序最初只有工具栏， 因此可以使用按钮子类来实现各种不同操作。 换句话来说， ​ 复制按钮Copy­Button子类包含复制文字的代码是可行的。 在实现了上下文菜单、 快捷方式和其他功能后， 你要么需要将操作代码复制进许多个类中， 要么需要让菜单依赖于按钮， 而后者是更糟糕的选择。</p>
<h1 id="解决方案">解决方案</h1>
<p>优秀的软件设计通常会将关注点进行分离， 而这往往会导致软件的分层。 最常见的例子： 一层负责用户图像界面； 另一层负责业务逻辑。 GUI 层负责在屏幕上渲染美观的图形， 捕获所有输入并显示用户和程序工作的结果。 当需要完成一些重要内容时 （比如计算月球轨道或撰写年度报告）， GUI 层则会将工作委派给业务逻辑底层。</p>
<p>这在代码中看上去就像这样： 一个 GUI 对象传递一些参数来调用一个业务逻辑对象。 这个过程通常被描述为一个对象发送请求给另一个对象。</p>
<figure data-type="image" tabindex="5"><img src="https://refactoringguru.cn/images/patterns/diagrams/command/solution1-zh-2x.png" alt="GUI 层可以直接访问业务逻辑层。" loading="lazy"></figure>
<p>命令模式建议 GUI 对象不直接提交这些请求。 你应该将请求的所有细节 （例如调用的对象、 方法名称和参数列表） 抽取出来组成命令类， 该类中仅包含一个用于触发请求的方法。</p>
<p>命令对象负责连接不同的 GUI 和业务逻辑对象。 此后， GUI 对象无需了解业务逻辑对象是否获得了请求， 也无需了解其对请求进行处理的方式。 GUI 对象触发命令即可， 命令对象会自行处理所有细节工作。</p>
<figure data-type="image" tabindex="6"><img src="https://refactoringguru.cn/images/patterns/diagrams/command/solution2-zh-2x.png" alt="通过命令访问业务逻辑层。" loading="lazy"></figure>
<p>下一步是让所有命令实现相同的接口。 该接口通常只有一个没有任何参数的执行方法， 让你能在不和具体命令类耦合的情况下使用同一请求发送者执行不同命令。 此外还有额外的好处， 现在你能在运行时切换连接至发送者的命令对象， 以此改变发送者的行为。</p>
<p>你可能会注意到遗漏的一块拼图——请求的参数。 GUI 对象可以给业务层对象提供一些参数。 但执行命令方法没有任何参数， 所以我们如何将请求的详情发送给接收者呢？ 答案是： 使用数据对命令进行预先配置， 或者让其能够自行获取数据。</p>
<figure data-type="image" tabindex="7"><img src="https://refactoringguru.cn/images/patterns/diagrams/command/solution3-zh-2x.png" alt="GUI 对象将命令委派给命令对象。" loading="lazy"></figure>
<p>让我们回到文本编辑器。 应用命令模式后， 我们不再需要任何按钮子类来实现点击行为。 我们只需在 按钮Button基类中添加一个成员变量来存储对于命令对象的引用， 并在点击后执行该命令即可。</p>
<p>你需要为每个可能的操作实现一系列命令类， 并且根据按钮所需行为将命令和按钮连接起来。</p>
<p>其他菜单、 快捷方式或整个对话框等 GUI 元素都可以通过相同方式来实现。 当用户与 GUI 元素交互时， 与其连接的命令将会被执行。 现在你很可能已经猜到了， 与相同操作相关的元素将会被连接到相同的命令， 从而避免了重复代码。</p>
<p>最后， 命令成为了减少 GUI 和业务逻辑层之间耦合的中间层。 而这仅仅是命令模式所提供的一小部分好处！</p>
<h1 id="真实世界类比">真实世界类比</h1>
<p>在市中心逛了很久的街后， 你找到了一家不错的餐厅， 坐在了临窗的座位上。 一名友善的服务员走近你， 迅速记下你点的食物， 写在一张纸上。 服务员来到厨房， 把订单贴在墙上。 过了一段时间， 厨师拿到了订单， 他根据订单来准备食物。 厨师将做好的食物和订单一起放在托盘上。 服务员看到托盘后对订单进行检查， 确保所有食物都是你要的， 然后将食物放到了你的桌上。</p>
<p>那张纸就是一个命令， 它在厨师开始烹饪前一直位于队列中。 命令中包含与烹饪这些食物相关的所有信息。 厨师能够根据它马上开始烹饪， 而无需跑来直接和你确认订单详情。</p>
<h1 id="命令模式结构">命令模式结构</h1>
<figure data-type="image" tabindex="8"><img src="https://refactoringguru.cn/images/patterns/diagrams/command/structure-2x.png" alt="likecat" loading="lazy"></figure>
<ol>
<li>
<p><strong>发送者 （Sender）</strong>——亦称 “触发者 （Invoker）”——类负责对请求进行初始化， 其中必须包含一个成员变量来存储对于命令对象的引用。 发送者触发命令， 而不向接收者直接发送请求。 注意， 发送者并不负责创建命令对象： 它通常会通过构造函数从客户端处获得预先生成的命令。</p>
</li>
<li>
<p><strong>命令 （Command）</strong> 接口通常仅声明一个执行命令的方法。</p>
</li>
<li>
<p><strong>具体命令 （Concrete Commands）</strong> 会实现各种类型的请求。 具体命令自身并不完成工作， 而是会将调用委派给一个业务逻辑对象。 但为了简化代码， 这些类可以进行合并。</p>
</li>
<li>
<p><strong>接收者 （Receiver）</strong> 类包含部分业务逻辑。 几乎任何对象都可以作为接收者。 绝大部分命令只处理如何将请求传递到接收者的细节， 接收者自己会完成实际的工作。</p>
</li>
<li>
<p><strong>客户端 （Client）</strong> 会创建并配置具体命令对象。 客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。 此后， 生成的命令就可以与一个或多个发送者相关联了。</p>
</li>
</ol>
<h2 id="命令模式适合应用场景">命令模式适合应用场景</h2>
<ol>
<li>
<p>如果你需要通过操作来参数化对象， 可使用命令模式。</p>
<p>命令模式可将特定的方法调用转化为独立对象。 这一改变也带来了许多有趣的应用： 你可以将命令作为方法的参数进行传递、 将命令保存在其他对象中， 或者在运行时切换已连接的命令等。</p>
<p>举个例子： 你正在开发一个 GUI 组件 （例如上下文菜单）， 你希望用户能够配置菜单项， 并在点击菜单项时触发操作。</p>
</li>
<li>
<p>如果你想要将操作放入队列中、 操作的执行或者远程执行操作， 可使用命令模式。</p>
<p>同其他对象一样， 命令也可以实现序列化 （序列化的意思是转化为字符串）， 从而能方便地写入文件或数据库中。 一段时间后， 该字符串可被恢复成为最初的命令对象。 因此， 你可以延迟或计划命令的执行。 但其功能远不止如此！ 使用同样的方式， 你还可以将命令放入队列、 记录命令或者通过网络发送命令。</p>
</li>
<li>
<p>如果你想要实现操作回滚功能， 可使用命令模式。</p>
<p>尽管有很多方法可以实现撤销和恢复功能， 但命令模式可能是其中最常用的一种。</p>
<p>为了能够回滚操作， 你需要实现已执行操作的历史记录功能。 命令历史记录是一种包含所有已执行命令对象及其相关程序状态备份的栈结构。</p>
<p>这种方法有两个缺点。 首先， 程序状态的保存功能并不容易实现， 因为部分状态可能是私有的。 你可以使用备忘录模式来在一定程度上解决这个问题。</p>
<p>其次， 备份状态可能会占用大量内存。 因此， 有时你需要借助另一种实现方式： 命令无需恢复原始状态， 而是执行反向操作。 反向操作也有代价： 它可能会很难甚至是无法实现。</p>
</li>
</ol>
<h1 id="实现方式">实现方式</h1>
<ol>
<li>
<p>声明仅有一个执行方法的命令接口。</p>
</li>
<li>
<p>抽取请求并使之成为实现命令接口的具体命令类。 每个类都必须有一组成员变量来保存请求参数和对于实际接收者对象的引用。 所有这些变量的数值都必须通过命令构造函数进行初始化。</p>
</li>
<li>
<p>找到担任发送者职责的类。 在这些类中添加保存命令的成员变量。 发送者只能通过命令接口与其命令进行交互。 发送者自身通常并不创建命令对象， 而是通过客户端代码获取。</p>
</li>
<li>
<p>修改发送者使其执行命令， 而非直接将请求发送给接收者。</p>
</li>
<li>
<p>客户端必须按照以下顺序来初始化对象：</p>
<ol>
<li>
<p>创建接收者。</p>
</li>
<li>
<p>创建命令， 如有需要可将其关联至接收者。</p>
</li>
<li>
<p>创建发送者并将其与特定命令关联。</p>
</li>
</ol>
</li>
</ol>
<h1 id="命令模式优缺点">命令模式优缺点</h1>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>单一职责原则。 你可以解耦触发和执行操作的类。</td>
<td style="text-align:center">代码可能会变得更加复杂， 因为你在发送者和接收者之间增加了一个全新的层次。</td>
</tr>
<tr>
<td>开闭原则。 你可以在不修改已有客户端代码的情况下在程序中创建新的命令。</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>你可以实现撤销和恢复功能。</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>你可以实现操作的延迟执行。</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>你可以将一组简单命令组合成一个复杂命令。</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h1 id="与其他模式的关系">与其他模式的关系</h1>
<ol>
<li>
<p><strong>责任链模式</strong>、 <strong>命令模式</strong>、 <strong>中介者模式</strong>和<strong>观察者模式</strong>用于处理请求发送者和接收者之间的不同连接方式：</p>
<ol>
<li>责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。</li>
<li>命令在发送者和请求者之间建立单向连接。</li>
<li>中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。</li>
<li>观察者允许接收者动态地订阅或取消接收请求。</li>
</ol>
</li>
<li>
<p><strong>责任链</strong>的管理者可使用<strong>命令模式</strong>实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。</p>
<p>还有另外一种实现方式， 那就是请求自身就是一个命令对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。</p>
</li>
<li>
<p>你可以同时使用<strong>命令</strong>和<strong>备忘录模式</strong>来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态。</p>
</li>
<li>
<p><strong>命令</strong>和<strong>策略模式</strong>看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。</p>
<p>你可以使用命令来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。</p>
<p>另一方面， 策略通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。</p>
</li>
<li>
<p><strong>原型模式</strong>可用于保存命令的历史记录。</p>
</li>
<li>
<p>你可以将<strong>访问者模式</strong>视为<strong>命令模式</strong>的加强版本， 其对象可对不同类的多种对象执行操作。</p>
</li>
</ol>
<h1 id="伪代码">伪代码</h1>
<h2 id="文字编辑器和撤销">文字编辑器和撤销</h2>
<p>本例中的文字编辑器在每次用户与其互动时， 都会创建一个新的命令对象。 命令执行其行为后会被压入历史堆栈。</p>
<p>现在， 当程序执行撤销操作时， 它就需要从历史记录中取出最近执行的命令， 然后执行反向操作或者恢复由该命令保存的编辑器历史状态。</p>
<h3 id="抽象基础命令">抽象基础命令</h3>
<pre><code>package com.command;

/**
 * 抽象基础命令
 * @author likecat
 * @version 1.0
 * @date 2022/3/9 17:43
 */
public abstract class Command {
    public Editor editor;
    private String backup;

    Command(Editor editor) {
        this.editor = editor;
    }

    void backup() {
        backup = editor.textField.getText();
    }

    public void undo() {
        editor.textField.setText(backup);
    }

    public abstract boolean execute();
}

</code></pre>
<h3 id="文字编辑器的-gui">文字编辑器的 GUI</h3>
<pre><code>package com.command;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

/**
 * 文字编辑器的 GUI
 * @author likecat
 * @version 1.0
 * @date 2022/3/9 17:43
 */
public class Editor {
    public JTextArea textField;
    public String clipboard;

    private CommandHistory history = new CommandHistory();

    public void init() {
        JFrame frame = new JFrame(&quot;Text editor (type &amp; use buttons, Luke!)&quot;);
        JPanel content = new JPanel();
        frame.setContentPane(content);
        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        content.setLayout(new BoxLayout(content, BoxLayout.Y_AXIS));
        textField = new JTextArea();
        textField.setLineWrap(true);
        content.add(textField);
        JPanel buttons = new JPanel(new FlowLayout(FlowLayout.CENTER));
        JButton ctrlC = new JButton(&quot;Ctrl+C&quot;);
        JButton ctrlX = new JButton(&quot;Ctrl+X&quot;);
        JButton ctrlV = new JButton(&quot;Ctrl+V&quot;);
        JButton ctrlZ = new JButton(&quot;Ctrl+Z&quot;);
        Editor editor = this;
        ctrlC.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                executeCommand(new CopyCommand(editor));
            }
        });
        ctrlX.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                executeCommand(new CutCommand(editor));
            }
        });
        ctrlV.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                executeCommand(new PasteCommand(editor));
            }
        });
        ctrlZ.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                undo();
            }
        });
        buttons.add(ctrlC);
        buttons.add(ctrlX);
        buttons.add(ctrlV);
        buttons.add(ctrlZ);
        content.add(buttons);
        frame.setSize(450, 200);
        frame.setLocationRelativeTo(null);
        frame.setVisible(true);
    }

    private void executeCommand(Command command) {
        if (command.execute()) {
            history.push(command);
        }
    }

    private void undo() {
        if (history.isEmpty()) return;

        Command command = history.pop();
        if (command != null) {
            command.undo();
        }
    }
}


</code></pre>
<h3 id="将所选文字复制到剪贴板">将所选文字复制到剪贴板</h3>
<pre><code>package com.command;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/9 17:45
 */
public class CopyCommand extends Command{
    public CopyCommand(Editor editor) {
        super(editor);
    }

    @Override
    public boolean execute() {
        editor.clipboard = editor.textField.getSelectedText();
        return false;
    }
}


</code></pre>
<h3 id="从剪贴板粘贴文字">从剪贴板粘贴文字</h3>
<pre><code>package com.command;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/9 17:46
 */
public class PasteCommand extends Command {

    public PasteCommand(Editor editor) {
        super(editor);
    }

    @Override
    public boolean execute() {
        if (editor.clipboard == null || editor.clipboard.isEmpty()) return false;

        backup();
        editor.textField.insert(editor.clipboard, editor.textField.getCaretPosition());
        return true;
    }
}

</code></pre>
<h3 id="将文字剪切到剪贴板">将文字剪切到剪贴板</h3>
<pre><code>package com.command;

/**
 *将文字剪切到剪贴板
 * @author likecat
 * @version 1.0
 * @date 2022/3/9 17:47
 */
public class CutCommand extends Command {

    public CutCommand(Editor editor) {
        super(editor);
    }

    @Override
    public boolean execute() {
        if (editor.textField.getSelectedText().isEmpty()) return false;

        backup();
        String source = editor.textField.getText();
        editor.clipboard = editor.textField.getSelectedText();
        editor.textField.setText(cutString(source));
        return true;
    }

    private String cutString(String source) {
        String start = source.substring(0, editor.textField.getSelectionStart());
        String end = source.substring(editor.textField.getSelectionEnd());
        return start + end;
    }
}


</code></pre>
<h3 id="命令历史">命令历史</h3>
<pre><code>package com.command;

import java.util.Stack;

/**
 * 命令历史
 * @author likecat
 * @version 1.0
 * @date 2022/3/9 17:48
 */
public class CommandHistory {
    private Stack&lt;Command&gt; history = new Stack&lt;&gt;();

    public void push(Command c) {
        history.push(c);
    }

    public Command pop() {
        return history.pop();
    }

    public boolean isEmpty() { return history.isEmpty(); }
}

</code></pre>
<h3 id="客户端代码">客户端代码</h3>
<pre><code>package com.command;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/3/9 17:49
 */
public class Demo {

    public static void main(String[] args) {
        Editor editor = new Editor();
        editor.init();
    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分布式事务Allornothing]]></title>
        <id>https://q456qq520.github.io/post/fen-bu-shi-shi-wu-allornothing/</id>
        <link href="https://q456qq520.github.io/post/fen-bu-shi-shi-wu-allornothing/">
        </link>
        <updated>2022-03-08T01:54:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="all-or-nothing">All or nothing</h1>
<h1 id="什么是分布式事务">什么是分布式事务？</h1>
<p>要想理解分布式事务，我们首先来看一下什么是事务。</p>
<p>事务，其实是包含一系列操作的、一个有边界的工作序列，有明确的开始和结束标志，且要么被完全执行，要么完全失败，即 all or nothing。通常情况下，我们所说的事务指的都是本地事务，也就是在单机上的事务。</p>
<p>而分布式事务，就是在分布式系统中运行的事务，由多个本地事务组合而成。在分布式场景下，对事务的处理操作可能来自不同的机器，甚至是来自不同的操作系统。</p>
<p>要深入理解分布式事务，我们首先需要了解它的特征。分布式事务是多个事务的组合，那么事务的特征 ACID，也是分布式事务的基本特征，其中 ACID 具体含义如下：</p>
<pre><code>1. 原子性（Atomicity），即事务最终的状态只有两种，全部执行成功和全部不执行。若处理事务的任何一项操作不成功，就会导致整个事务失败。一旦操作失败，所有操作都会被取消（即回滚），使得事务仿佛没有被执行过一样。

2. 一致性（Consistency），是指事务操作前和操作后，数据的完整性保持一致或满足完整性约束。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加200 元 ; 一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况 (该情况，用户 A 和 B 均为 600 元，总共 1200 元)。

3. 隔离性（Isolation），是指当系统内有多个事务并发执行时，多个事务不会相互干扰，
</code></pre>
<p>即一个事务内部的操作及使用的数据，对其他并发事务是隔离的。</p>
<pre><code>4. 持久性（Durability），也被称为永久性，是指一个事务完成了，那么它对数据库所做的更新就被永久保存下来了。即使发生系统崩溃或宕机等故障，只要数据库能够重新被访问，那么一定能够将其恢复到事务完成时的状态。
</code></pre>
<p>分布式事务基本能够满足 ACID，其中的 C 是强一致性，也就是所有操作均执行成功，才提交最终结果，以保证数据一致性或完整性。但随着分布式系统规模不断扩大，复杂度急剧上升，达成强一致性所需时间周期较长，限定了复杂业务的处理。为了适应复杂业务，出现了BASE 理论，该理论的一个关键点就是采用最终一致性代替强一致性。</p>
<h1 id="如何实现分布式事务">如何实现分布式事务？</h1>
<p>分布式事务主要是解决在分布式环境下，组合事务的一致性问题。实现分布式事务有以下 3 种基本方法：</p>
<pre><code>- 基于 XA 协议的二阶段提交协议方法；
- 三阶段提交协议方法；
- 基于消息的最终一致性方法。
</code></pre>
<p>其中，基于 XA 协议的二阶段提交协议方法和三阶段提交协议方法，采用了强一致性，遵从ACID，基于消息的最终一致性方法，采用了最终一致性，遵从 BASE 理论。</p>
<h1 id="什么是-base-理论">什么是 BASE 理论</h1>
<p>刚性事务，遵循 ACID 原则，具有强一致性。比如，数据库事务。</p>
<p>柔性事务，其实就是根据不同的业务场景使用不同的方法实现最终一致性，也就是说我们可以根据业务的特性做部分取舍，容忍一定时间内的数据不一致。</p>
<p>总结来讲，与刚性事务不同，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致。而柔性事务的最终一致性，遵循的是 BASE 理论。</p>
<p>BASE 理论包括基本可用（Basically Available）、柔性状态（Soft State）和最终一致性（Eventual Consistency）。</p>
<ol>
<li>基本可用：分布式系统出现故障的时候，允许损失一部分功能的可用性。</li>
<li>柔性状态：在柔性事务中，允许系统存在中间状态，且这个中间状态不会影响系统整体可用性。比如，数据库读写分离，写库同步到读库（主库同步到从库）会有一个延时，其实就是一种柔性状态。</li>
<li>最终一致性：事务在操作过程中可能会由于同步延迟等问题导致不一致，但最终状态下，数据都是一致的。</li>
</ol>
<p>BASE 理论为了支持大型分布式系统，通过牺牲强一致性，保证最终一致性，来获得高可用性，是对 ACID 原则的弱化。</p>
<h1 id="基于-xa-协议的二阶段提交方法">基于 XA 协议的二阶段提交方法</h1>
<p>XA 是一个分布式事务协议，规定了事务管理器和资源管理器接口。因此，XA 协议可以分为两部分，即事务管理器和本地资源管理器。</p>
<p>XA 实现分布式事务的原理，事务管理器作为协调者，负责各个本地资源的提交和回滚；而资源管理器就是分布式事务的参与者，通常由数据库实现。</p>
<p>基于 XA 协议的二阶段提交方法中，<strong>二阶段提交协议（The two-phase commit protocol，2PC）</strong>，用于保证分布式系统中事务提交时的数据一致性，是 XA 在全局事务中用于协调多个资源的机制。</p>
<p>那么，两阶段提交协议如何保证分布在不同节点上的分布式事务的一致性呢？为了保证它们的一致性，我们需要引入一个协调者来管理所有的节点，并确保这些节点正确提交操作结果，若提交失败则放弃事务。接下来，我们看看两阶段提交协议的具体过程。两阶段提交协议的执行过程，分为投票（voting）和提交（commit）两个阶段。</p>
<p><strong>投票</strong>为第一阶段，协调者（Coordinator，即事务管理器）会向事务的参与者（Cohort，即本地资源管理器）发起执行操作的 CanCommit 请求，并等待参与者的响应。参与者接收到请求后，会执行请求中的事务操作，记录日志信息但不提交，待参与者执行成功，则向协调者发送“Yes”消息，表示同意操作；若不成功，则发送“No”消息，表示终止操作。</p>
<p>当所有的参与者都返回了操作结果（Yes 或 No 消息）后，系统进入了提交阶段。在提交阶段，协调者会根据所有参与者返回的信息向参与者发送 DoCommit 或 DoAbort 指令：</p>
<p>若协调者收到的都是“Yes”消息，则向参与者发送“DoCommit”消息，参与者会完成剩余的操作并释放资源，然后向协调者返回“HaveCommitted”消息；</p>
<p>如果协调者收到的消息中包含“No”消息，则向所有参与者发送“DoAbort”消息，此时发送“Yes”的参与者则会根据之前执行操作时的回滚日志对操作进行回滚，然后所有参与者会向协调者发送“HaveCommitted”消息；<br>
协调者接收到“HaveCommitted”消息，就意味着整个事务结束了。</p>
<p>二阶段提交的算法思路可以概括为：<strong>协调者下发请求事务操作，参与者将操作结果通知协调者，协调者根据所有参与者的反馈结果决定各参与者是要提交操作还是撤销操作。</strong></p>
<p>虽然基于 XA 的二阶段提交算法基本满足了事务的 ACID 特性，但依然有些不足。</p>
<pre><code>1. 同步阻塞问题：二阶段提交算法在执行过程中，所有参与节点都是事务阻塞型的。也就是说，当本地资源管理器占有临界资源时，其他资源管理器如果要访问同一临界资源，会处于阻塞状态。

2. 单点故障问题：基于 XA 的二阶段提交算法类似于集中式算法，一旦事务管理器发生故障，整个系统都处于停滞状态。尤其是在提交阶段，一旦事务管理器发生故障，资源管理器会由于等待管理器的消息，而一直锁定事务资源，导致整个系统被阻塞。

3. 数据不一致问题：在提交阶段，当协调者向参与者发送 DoCommit 请求之后，如果发生了局部网络异常，或者在发送提交请求的过程中协调者发生了故障，就会导致只有一部分参与者接收到了提交请求并执行提交操作，但其他未接到提交请求的那部分参与者则无法执行事务提交。于是整个分布式系统便出现了数据不一致的问题。
</code></pre>
<h1 id="三阶段提交方法">三阶段提交方法</h1>
<p>三阶段提交协议（Three-phase commit protocol，3PC），是对二阶段提交（2PC）的改进。为了解决两阶段提交的同步阻塞和数据不一致问题，三阶段提交引入了<strong>超时机制</strong>和<strong>准备阶段</strong>。</p>
<p>同时在协调者和参与者中引入超时机制。<strong>如果协调者或参与者在规定的时间内没有接收到来自其他节点的响应，就会根据当前的状态选择提交或者终止整个事务</strong>。</p>
<p><strong>在第一阶段和第二阶段中间引入了一个准备阶段</strong>，也就是在提交阶段之前，加入了一个预提交阶段。在预提交阶段排除一些不一致的情况，保证在最后提交之前各参与节点的状态是一致的。</p>
<p>也就是说，除了引入超时机制之外，3PC 把 2PC 的提交阶段一分为二，这样三阶段提交协议就有 CanCommit、PreCommit、DoCommit 三个阶段。</p>
<h2 id="第一cancommit-阶段">第一，CanCommit 阶段。</h2>
<p>CanCommit 阶段与 2PC 的投票阶段类似：协调者向参与者发送请求操作（CanCommit请求），询问参与者是否可以执行事务提交操作，然后等待参与者的响应；参与者收到CanCommit 请求之后，回复 Yes，表示可以顺利执行事务；否则回复 No。</p>
<p>CanCommit 阶段不同节点之间的事务请求成功和失败的流程，如下所示。</p>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1646725943605.png" alt="3pc第一阶段" loading="lazy"></figure>
<h2 id="第二precommit-阶段">第二，PreCommit 阶段。</h2>
<p>协调者根据参与者的回复情况，来决定是否可以进行 PreCommit 操作</p>
<p>如果所有参与者回复的都是“Yes”，那么协调者就会执行事务的预执行：</p>
<pre><code>- 发送预提交请求。协调者向参与者发送 PreCommit 请求，进入预提交阶段。
- 事务预提交。参与者接收到 PreCommit 请求后执行事务操作，并将 Undo 和 Redo信息记录到事务日志中。
- 响应反馈。如果参与者成功执行了事务操作，则返回 ACK 响应，同时开始等待最终指令。
</code></pre>
<p>假如任何一个参与者向协调者发送了“No”消息，或者等待超时之后，协调者都没有收到参与者的响应，就执行中断事务的操作：</p>
<pre><code> - 发送中断请求。协调者向所有参与者发送“Abort”消息。
 - 终断事务。参与者收到“Abort”消息之后，或超时后仍未收到协调者的消息，执行事务的终断操作。
</code></pre>
<p>预执行阶段，不同节点上事务执行成功和失败的流程，如下所示。</p>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1646726217417.png" alt="3pc2阶段" loading="lazy"></figure>
<h2 id="第三docommit-阶段">第三，DoCommit 阶段。</h2>
<p>DoCmmit 阶段进行真正的事务提交，根据 PreCommit 阶段协调者发送的消息，进入执行提交阶段或事务中断阶段。</p>
<ul>
<li>
<p><strong>执行提交阶段</strong>：</p>
<ul>
<li>发送提交请求。协调者接收到所有参与者发送的 Ack 响应，从预提交状态进入到提交状态，并向所有参与者发送 DoCommit 消息。</li>
<li>事务提交。参与者接收到 DoCommit 消息之后，正式提交事务。完成事务提交之后，释放所有锁住的资源。</li>
<li>响应反馈。参与者提交完事务之后，向协调者发送 Ack 响应。</li>
<li>完成事务。协调者接收到所有参与者的 Ack 响应之后，完成事务。</li>
</ul>
</li>
<li>
<p><strong>事务中断阶段</strong>：</p>
<ul>
<li>发送中断请求。协调者向所有参与者发送 Abort 请求。</li>
<li>事务回滚。参与者接收到 Abort 消息之后，利用其在 PreCommit 阶段记录的 Undo信息执行事务的回滚操作，并释放所有锁住的资源。</li>
<li>反馈结果。参与者完成事务回滚之后，向协调者发送 Ack 消息。</li>
<li>终断事务。协调者接收到参与者反馈的 Ack 消息之后，执行事务的终断，并结束事务。</li>
</ul>
</li>
</ul>
<p>执行阶段不同节点上事务执行成功和失败 (事务终断) 的流程，如下所示。</p>
<figure data-type="image" tabindex="3"><img src="https://q456qq520.github.io/post-images/1646729143957.png" alt="3pc3阶段" loading="lazy"></figure>
<p>在 DoCommit 阶段，当参与者向协调者发送 Ack 消息后，如果长时间没有得到协调者的响应，在默认情况下，参与者会自动将超时的事务进行提交，不会像两阶段提交那样被阻塞住。</p>
<h1 id="基于分布式消息的最终一致性方案">基于分布式消息的最终一致性方案</h1>
<p>2PC 和 3PC 这两种方法，有两个共同的缺点，一是都需要锁定资源，降低系统性能；二是，没有解决数据不一致的问题。因此，便有了通过分布式消息来确保事务最终一致性的方案。</p>
<p>在 eBay 的分布式系统架构中，架构师解决一致性问题的核心思想就是：将需要分布式处理的事务通过消息或者日志的方式异步执行，消息或日志可以存到本地文件、数据库或消息队列中，再通过业务规则进行失败重试。这个案例，就是使用基于<strong>分布式消息的最终一致性方案</strong>解决了分布式事务的问题。</p>
<p>基于分布式消息的最终一致性方案的事务处理，引入了一个消息中间件（MessageQueue，MQ），用于在多个应用之间进行消息传递。</p>
<p>基于消息中间件协商多个节点分布式事务执行操作的示意图，如下所示。</p>
<figure data-type="image" tabindex="4"><img src="https://q456qq520.github.io/post-images/1646813542498.png" alt="最终一致性示意图" loading="lazy"></figure>
<p>以网上购物为例。假设用户 A 在某电商平台下了一个订单，需要支付 50 元，发现自己的账户余额共 150 元，就使用余额支付，支付成功之后，订单状态修改为支付成功，然后通知仓库发货。</p>
<p>在该事件中，涉及到了订单系统、支付系统、仓库系统，这三个系统是相互独立的应用，通过远程服务进行调用。</p>
<figure data-type="image" tabindex="5"><img src="https://q456qq520.github.io/post-images/1646813778051.png" alt="最终一致性时序图" loading="lazy"></figure>
<p>根据基于分布式消息的最终一致性方案，用户 A 通过终端手机首先在订单系统上操作，然后整个购物的流程如下所示。</p>
<figure data-type="image" tabindex="6"><img src="https://q456qq520.github.io/post-images/1646813800623.png" alt="最终一致性流程图" loading="lazy"></figure>
<ol>
<li>订单系统把订单消息发给消息中间件，消息状态标记为“待确认”。</li>
<li>消息中间件收到消息后，进行消息持久化操作，即在消息存储系统中新增一条状态为“待发送”的消息。</li>
<li>消息中间件返回消息持久化结果（成功 / 失败），订单系统根据返回结果判断如何进行业务操作。失败，放弃订单，结束（必要时向上层返回失败结果）；成功，则创建订单。</li>
<li>订单操作完成后，把操作结果（成功 / 失败）发送给消息中间件。</li>
<li>消息中间件收到业务操作结果后，根据结果进行处理：失败，删除消息存储中的消息，结束；成功，则更新消息存储中的消息状态为“待发送（可发送）”，并执行消息投递。</li>
<li>如果消息状态为“可发送”，则 MQ 会将消息发送给支付系统，表示已经创建好订单，需要对订单进行支付。支付系统也按照上述方式进行订单支付操作。</li>
<li>订单系统支付完成后，会将支付消息返回给消息中间件，中间件将消息传送给订单系统。订单系统再调用库存系统，进行出货操作。</li>
</ol>
<p>分布式事务中，当且仅当所有的事务均成功时整个流程才成功。所以，<strong>分布式事务的一致性是实现分布式事务的关键问题，目前来看还没有一种很简单、完美的方案可以应对所有场景</strong>。</p>
<h1 id="三种实现方式对比">三种实现方式对比</h1>
<figure data-type="image" tabindex="7"><img src="https://q456qq520.github.io/post-images/1646813912330.png" alt="分布式事务对比图" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分布式锁]]></title>
        <id>https://q456qq520.github.io/post/fen-bu-shi-shi-wu/</id>
        <link href="https://q456qq520.github.io/post/fen-bu-shi-shi-wu/">
        </link>
        <updated>2022-03-08T01:54:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="为什么要使用分布锁">为什么要使用分布锁？</h1>
<h2 id="什么是锁">什么是锁</h2>
<p>在单机多线程环境中，我们经常遇到多个线程访问同一个共享资源（这里需要注意的是：在很多地方，这种资源会称为临界资源，也称之为共享资源）的情况。为了维护数据的一致性，我们需要某种机制来保证只有满足某个条件的线程才能访问资源，不满足条件的线程只能等待，在下一轮竞争中重新满足条件时才能访问资源。</p>
<p>这个机制指的是，为了实现分布式互斥，在某个地方做个标记，这个标记每个线程都能看到，到标记不存在时可以设置该标记，当标记被设置后，其他线程只能等待拥有该标记的线程执行完成，并释放该标记后，才能去设置该标记和访问共享资源。这里的标记，就是我们常说的锁。</p>
<p>也就是说，<strong>锁是实现多线程同时访问同一共享资源，保证同一时刻只有一个线程可访问共享资源所做的一种标记</strong>。</p>
<p>与普通锁不同的是，<strong>分布式锁</strong>是指分布式环境下，系统部署在多个机器中，实现多进程分布式互斥的一种锁。为了保证多个进程能看到锁，锁被存在公共存储（比如 Redis、Memcache、数据库等三方存储中），以实现多个进程并发访问同一个临界资源，同一时刻只有一个进程可访问共享资源，确保数据的一致性。</p>
<h1 id="分布式锁的三种实现方法及对比">分布式锁的三种实现方法及对比</h1>
<p>接下来，我带你看看实现分布式锁的 3 种主流方法，即：</p>
<pre><code>1. 基于数据库实现分布式锁，这里的数据库指的是关系型数据库；

2. 基于缓存实现分布式锁；

3. 基于 ZooKeeper 实现分布式锁。
</code></pre>
<h2 id="基于数据库实现分布式锁">基于数据库实现分布式锁</h2>
<p>要实现分布式锁，最简单的方式就是创建一张锁表，然后通过操作该表中的数据来实现。</p>
<p>当我们要锁住某个资源时，就在该表中增加一条记录，想要释放锁的时候就删除这条记录。数据库对共享资源做了唯一性约束，如果有多个请求被同时提交到数据库的话，数据库会保证只有一个操作可以成功，操作成功的那个线程就获得了访问共享资源的锁，可以进行操作。</p>
<p>基于数据库实现的分布式锁，是最容易理解的。但是，因为数据库需要落到硬盘上，频繁读取数据库会导致 IO 开销大，因此这种分布式锁适用于并发量低，对性能要求低的场景。对于双 11、双 12 等需求量激增场景，数据库锁是无法满足其性能要求的。而在平日的购物中，我们可以在局部场景中使用数据库锁实现对资源的互斥访问。</p>
<p>以电商售卖吹风机的场景为例。吹风机库存是 2 个，有 5 个来自不同地区的用户{A,B,C,D,E}想要购买，其中用户 A 想买 1 个，用户 B 想买 2 个，用户 C 想买 1个。</p>
<p>用户 A 和用户 B 几乎同时下单，但用户 A 的下单请求最先到达服务器。因此，该商家的产品数据库中增加了一条关于用户 A 的记录，用户 A 获得了锁，他的订单请求被处理，服务器修改吹风机库存数，减去 1 后还剩下 1 个。</p>
<p>当用户 A 的订单请求处理完成后，有关用户 A 的记录被删除，服务器开始处理用户 B 的订单请求。这时，库存只有 1 个了，无法满足用户 B 的订单需求，因此用户 B 购买失败。从数据库中，删除用户 B 的记录，服务器开始处理用户 C 的订单请求，库存中 1 个吹风机满足用户 C 的订单需求。所以，数据库中增加了一条关于用户 C 的记录，用户 C 获得了锁，他的订单请求被处理，服务器修改吹风机数量，减去 1 后还剩下 0 个。</p>
<p><strong>基于数据库实现分布式锁比较简单，主要在于创建一张锁表，为申请者在锁表里建立一条记录，记录建立成功则获得锁，消除记录则释放锁</strong>。该方法依赖于数据库，主要有两个缺点：</p>
<pre><code>1. 单点故障问题。一旦数据库不可用，会导致整个系统崩溃。

2. 死锁问题。数据库锁没有失效时间，未获得锁的进程只能一直等待已获得锁的进程主动释放锁。一旦已获得锁的进程挂掉或者解锁操作失败，会导致锁记录一直存在数据库中，其他进程无法获得锁。
</code></pre>
<h2 id="基于缓存实现分布式锁">基于缓存实现分布式锁</h2>
<p>基于缓存实现分布式锁的方式。所谓基于缓存，也就是说把数据存放在计算机内存中，不需要写入磁盘，减少了 IO 读写。</p>
<p>Redis 通常可以使用 setnx(key, value) 函数来实现分布式锁。key 和 value 就是基于缓存的分布式锁的两个属性，其中 key 表示锁 id，value = currentTime + timeOut，表示当前时间 + 超时时间。也就是说，某个进程获得 key 这把锁后，如果在 value 的时间内未释放锁，系统就会主动释放锁。</p>
<p>setnx 函数的返回值有 0 和 1：</p>
<p>返回 1，说明该服务器获得锁，setnx 将 key 对应的 value 设置为当前时间 + 锁的有效时间。</p>
<p>返回 0，说明其他服务器已经获得了锁，进程不能进入临界区。该服务器可以不断尝试setnx 操作，以获得锁。</p>
<p>以电商售卖吹风机的场景为例，和你说明基于缓存实现的分布式锁，假设现在库存数量是足够的。</p>
<p>用户 A 的请求因为网速快，最先到达 Server2，setnx 操作返回 1，并获取到购买吹风机的锁；用户 B 和用户 C 的请求，几乎同时到达了 Server1 和 Server3，但因为这时 Server2获取到了吹风机数据的锁，所以只能加入等待队列。</p>
<p>Server2 获取到锁后，负责管理吹风机的服务器执行业务逻辑，只用了 1s 就完成了订单。订单请求完成后，删除锁的 key，从而释放锁。此时，排在第二顺位的 Server1 获得了锁，可以访问吹风机的数据资源。但不巧的是，Server1 在完成订单后发生了故障，无法主动释放锁。</p>
<p>于是，排在第三顺位的 Server3 只能等设定的有效时间（比如 30 分钟）到期，锁自动释放后，才能访问吹风机的数据资源，也就是说用户 C 只能到 00:30:01 以后才能继续抢购。</p>
<p>Redis 通过队列来维持进程访问共享资源的先后顺序。Redis 锁主要基于 setnx函数实现分布式锁，当进程通过 setnx&lt;key,value&gt; 函数返回 1 时，表示已经获得锁。排在后面的进程只能等待前面的进程主动释放锁，或者等到时间超时才能获得锁。</p>
<p>相对于基于数据库实现分布式锁的方案来说，基于缓存实现的分布式锁的优势表现在以下几个方面：</p>
<pre><code>1. 性能更好。数据被存放在内存，而不是磁盘，避免了频繁的 IO 操作。

2. 很多缓存可以跨集群部署，避免了单点故障问题。

3. 很多缓存服务都提供了可以用来实现分布式锁的方法，比如 Redis 的 setnx 方法等。可以直接设置超时时间来控制锁的释放，因为这些缓存服务器一般支持自动删除过期数据。
</code></pre>
<p>这个方案的不足是，通过超时时间来控制锁的失效时间，并不是十分靠谱，因为一个进程执行时间可能比较长，或受系统进程做内存回收等影响，导致时间超时，从而不正确地释放了锁。</p>
<h2 id="基于-zookeeper-实现分布式锁">基于 ZooKeeper 实现分布式锁</h2>
<p>ZooKeeper 基于树形数据存储结构实现分布式锁，来解决多个进程同时访问同一临界资源时，数据的一致性问题。ZooKeeper 的树形数据存储结构主要由 4 种节点构成：</p>
<pre><code>1. 持久节点。这是默认的节点类型，一直存在于 ZooKeeper 中。

2. 持久顺序节点。也就是说，在创建节点时，ZooKeeper 根据节点创建的时间顺序对节点进行编号。

3. 临时节点。与持久节点不同，当客户端与 ZooKeeper 断开连接后，该进程创建的临时节点就会被删除。

4. 临时顺序节点，就是按时间顺序编号的临时节点。
</code></pre>
<p>根据它们的特征，ZooKeeper 基于临时顺序节点实现了分布锁。</p>
<p>还是以电商售卖吹风机的场景为例。假设用户 A、B、C 同时在 11 月 11 日的零点整提交了购买吹风机的请求，ZooKeeper 会采用如下方法来实现分布式锁：</p>
<ol>
<li>
<p>在与该方法对应的持久节点 shared_lock 的目录下，为每个进程创建一个临时顺序节点。吹风机就是一个拥有 shared_lock 的目录，当有人买吹风机时，会为他创建一个临时顺序节点。</p>
</li>
<li>
<p>每个进程获取 shared_lock 目录下的所有临时节点列表，注册子节点变更的Watcher，并监听节点。</p>
</li>
<li>
<p>每个节点确定自己的编号是否是 shared_lock 下所有子节点中最小的，若最小，则获得锁。例如，用户 A 的订单最先到服务器，因此创建了编号为 1 的临时顺序节点LockNode1。该节点的编号是持久节点目录下最小的，因此获取到分布式锁，可以访问临界资源，从而可以购买吹风机。</p>
</li>
<li>
<p>若本进程对应的临时节点编号不是最小的，则分为两种情况：</p>
<p>a. 本进程为读请求，如果比自己序号小的节点中有写请求，则等待；</p>
<p>b. 本进程为写请求，如果比自己序号小的节点中有读请求，则等待。</p>
</li>
</ol>
<p>例如，用户 B 也想要买吹风机，但在他之前，用户 C 想看看吹风机的库存量。因此，用户B 只能等用户 A 买完吹风机、用户 C 查询完库存量后，才能购买吹风机。</p>
<p>使用 ZooKeeper 可以完美解决设计分布式锁时遇到的各种问题，比如单点故障、不可重入、死锁等问题。虽然 ZooKeeper 实现的分布式锁，几乎能涵盖所有分布式锁的特性，且易于实现，但需要频繁地添加和删除节点，所以性能不如基于缓存实现的分布式锁。</p>
<table>
<thead>
<tr>
<th>特征</th>
<th style="text-align:center">对比</th>
</tr>
</thead>
<tbody>
<tr>
<td>理解的容易程度</td>
<td style="text-align:center">数据库&gt;缓存&gt;zk</td>
</tr>
<tr>
<td>实现复杂性</td>
<td style="text-align:center">zk&gt;=缓存&gt;数据库</td>
</tr>
<tr>
<td>性能</td>
<td style="text-align:center">缓存&gt;zk&gt;=数据库</td>
</tr>
<tr>
<td>可靠性</td>
<td style="text-align:center">zk&gt;缓存&gt;数据库</td>
</tr>
</tbody>
</table>
<p>ZooKeeper 分布式锁的可靠性最高，有封装好的框架，很容易实现分布式锁的功能，并且几乎解决了数据库锁和缓存式锁的不足，因此是实现分布式锁的首选方法。</p>
<p>为了确保分布式锁的可用性，我们在设计时应考虑到以下几点：</p>
<pre><code>1. 互斥性，即在分布式系统环境下，分布式锁应该能保证一个资源或一个方法在同一时间只能被一个机器的一个线程或进程操作。

2. 具备锁失效机制，防止死锁。即使有一个进程在持有锁的期间因为崩溃而没有主动解锁，也能保证后续其他进程可以获得锁。

3. 可重入性，即进程未释放锁时，可以多次访问临界资源。

4. 有高可用的获取锁和释放锁的功能，且性能要好。
</code></pre>
<h1 id="如何解决分布式锁的羊群效应问题">如何解决分布式锁的羊群效应问题？</h1>
<p>在分布式锁问题中，会经常遇到羊群效应。所谓羊群效应，就是在整个分布式锁的竞争过程中，大量的“Watcher 通知”和“子节点列表的获取”操作重复运行，并且大多数节点的运行结果都是判断出自己当前并不是编号最小的节点，继续等待下一次通知，而不是执行业务逻辑。</p>
<p>这，就会对 ZooKeeper 服务器造成巨大的性能影响和网络冲击。更甚的是，如果同一时间多个节点对应的客户端完成事务或事务中断引起节点消失，ZooKeeper 服务器就会在短时间内向其他客户端发送大量的事件通知。</p>
<p>那如何解决这个问题呢？具体方法可以分为以下三步。</p>
<ol>
<li>
<p>在与该方法对应的持久节点的目录下，为每个进程创建一个临时顺序节点。</p>
</li>
<li>
<p>每个进程获取所有临时节点列表，对比自己的编号是否最小，若最小，则获得锁。</p>
</li>
<li>
<p>若本进程对应的临时节点编号不是最小的，则继续判断：</p>
<p>a. 若本进程为读请求，则向比自己序号小的最后一个写请求节点注册 watch 监听，当监听到该节点释放锁后，则获取锁；</p>
<p>b. 若本进程为写请求，则向比自己序号小的最后一个读请求节点注册 watch 监听，当监听到该节点释放锁后，获取锁。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 分布式选举]]></title>
        <id>https://q456qq520.github.io/post/fen-bu-shi-xuan-ju/</id>
        <link href="https://q456qq520.github.io/post/fen-bu-shi-xuan-ju/">
        </link>
        <updated>2022-03-07T11:24:59.000Z</updated>
        <content type="html"><![CDATA[<h1 id="为什么要有分布式选举">为什么要有分布式选举？</h1>
<p>主节点，在一个分布式集群中负责对其他节点的协调和管理，也就是说，其他节点都必须听从主节点的安排。</p>
<p>主节点的存在，就可以保证其他节点的有序运行，以及数据库集群中的写入数据在每个节点上的一致性。这里的一致性是指，数据在每个集群节点中都是一样的，不存在不同的情况。当然，如果主故障了，集群就会天下大乱，就好比一个国家的皇帝驾崩了，国家大乱一样。比如，数据库集群中主节点故障后，可能导致每个节点上的数据会不一致。</p>
<p>这，就应了那句话“国不可一日无君”，对应到分布式系统中就是“集群不可一刻无主”。总结来说，选举的作用就是选出一个主节点，由它来协调和管理其他节点，以保证集群有序运行和节点间数据的一致性。</p>
<h1 id="分布式选举的算法">分布式选举的算法</h1>
<p>目前常见的选主方法有基于序号选举的算法（ 比如，Bully 算法）、多数派算法（比如，Raft 算法、ZAB 算法）等。</p>
<h1 id="bully-算法">Bully 算法</h1>
<p>Bully 算法是一种集群选主算法，因为它的选举原则是“长者”为大，即在所有活着的节点中，选取 ID 最大的节点作为主节点。</p>
<p>在 Bully 算法中，节点的角色有两种：普通节点和主节点。初始化时，所有节点都是平等的，都是普通节点，并且都有成为主的权利。但是，当选主成功后，有且仅有一个节点成为主节点，其他所有节点都是普通节点。当且仅当主节点故障或与其他节点失去联系后，才会重新选主。</p>
<p>Bully 算法在选举过程中，需要用到以下 3 种消息：</p>
<pre><code>1. Election 消息，用于发起选举；
2. Alive 消息，对 Election 消息的应答；
3. Victory 消息，竞选成功的主节点向其他节点发送的宣誓主权的消息。
</code></pre>
<p>Bully 算法选举的原则是“长者为大”，意味着它的假设条件是，集群中每个节点均知道其他节点的 ID。在此前提下，其具体的选举过程是：</p>
<ol>
<li>集群中每个节点判断自己的 ID 是否为当前活着的节点中 ID 最大的，如果是，则直接向其他节点发送 Victory 消息，宣誓自己的主权；</li>
<li>如果自己不是当前活着的节点中 ID 最大的，则向比自己 ID 大的所有节点发送Election 消息，并等待其他节点的回复；</li>
<li>若在给定的时间范围内，本节点没有收到其他节点回复的 Alive 消息，则认为自己成为主节点，并向其他节点发送 Victory 消息，宣誓自己成为主节点；若接收到来自比自己ID 大的节点的 Alive 消息，则等待其他节点发送 Victory 消息；</li>
<li>若本节点收到比自己 ID 小的节点发送的 Election 消息，则回复一个 Alive 消息，告知其他节点，我比你大，重新选举。</li>
</ol>
<p>目前已经有很多开源软件采用了 Bully 算法进行选主，比如 MongoDB 的副本集故障转移功能。MongoDB 的分布式选举中，采用节点的最后操作时间戳来表示 ID，时间戳最新的节点其 ID 最大，也就是说时间戳最新的、活着的节点是主节点。</p>
<p>小结一下。Bully 算法的选择特别霸道和简单，谁活着且谁的 ID 最大谁就是主节点，其他节点必须无条件服从。这种算法的优点是，选举速度快、算法复杂度低、简单易实现。</p>
<p>但这种算法的缺点在于，需要每个节点有全局的节点信息，因此额外信息存储较多；其次，任意一个比当前主节点 ID 大的新节点或节点故障后恢复加入集群的时候，都可能会触发重新选举，成为新的主节点，如果该节点频繁退出、加入集群，就会导致频繁切主。</p>
<h1 id="raft-算法">Raft 算法</h1>
<p>Raft 算法是典型的多数派投票选举算法，其选举机制与我们日常生活中的民主投票机制类似，核心思想是“<strong>少数服从多数</strong>”。也就是说，Raft 算法中，获得投票最多的节点成为主。</p>
<p>采用 Raft 算法选举，集群节点的角色有 3 种：</p>
<pre><code>- **Leader**，即主节点，同一时刻只有一个 Leader，负责协调和管理其他节点；

- **Candidate**，即候选者，每一个节点都可以成为 Candidate，节点在该角色下才可以被

    选为新的 Leader；

- **Follower**，Leader 的跟随者，不可以发起选举。
</code></pre>
<p>Raft 选举的流程，可以分为以下几步：</p>
<ol>
<li>初始化时，所有节点均为 Follower 状态。</li>
<li>开始选主时，所有节点的状态由 Follower 转化为 Candidate，并向其他节点发送选举请求。</li>
<li>其他节点根据接收到的选举请求的先后顺序，回复是否同意成为主。这里需要注意的<br>
是，在每一轮选举中，一个节点只能投出一张票。</li>
<li>若发起选举请求的节点获得超过一半的投票，则成为主节点，其状态转化为 Leader，<br>
其他节点的状态则由 Candidate 降为 Follower。Leader 节点与 Follower 节点之间会<br>
定期发送心跳包，以检测主节点是否活着。</li>
<li>当 Leader 节点的任期到了，即发现其他服务器开始下一轮选主周期时，Leader 节点<br>
的状态由 Leader 降级为 Follower，进入新一轮选主。</li>
</ol>
<p><strong>每一轮选举，每个节点只能投一次票。</strong></p>
<p>小结一下。Raft 算法具有选举速度快、算法复杂度低、易于实现的优点；缺点是，它要求系统内每个节点都可以相互通信，且需要获得过半的投票数才能选主成功，因此通信量大。该算法选举稳定性比 Bully 算法好，这是因为当有新节点加入或节点故障恢复后，会触发选主，但不一定会真正切主，除非新节点或故障后恢复的节点获得投票数过半，才会导致切主。</p>
<h2 id="扩展">扩展</h2>
<p>两主的情况出现在集群因为网络原因，被划分了两部分局部可通信的区域。下面的链接详细讲解了Raft算法，及双主出现后集群是如何恢复的。<br>
https://www.infoq.cn/article/coreos-analyse-etcd/</p>
<p>还有一个Raft算法动画链接<br>
http://thesecretlivesofdata.com/raft/#election</p>
<p>一文搞懂Raft算法<br>
https://www.cnblogs.com/xybaby/p/10124083.html</p>
<h1 id="具有优先级的民主投票zab-算法">具有优先级的民主投票：ZAB 算法</h1>
<p>ZAB（ZooKeeper Atomic Broadcast）选举算法是为 ZooKeeper 实现分布式协调功能而设计的。相较于 Raft 算法的投票机制，ZAB 算法增加了通过节点 ID 和数据 ID 作为参考进行选主，节点 ID 和数据 ID 越大，表示数据越新，优先成为主。相比较于 Raft 算法，ZAB 算法尽可能保证数据的最新性。所以，ZAB 算法可以说是对 Raft 算法的改进。</p>
<p>使用 ZAB 算法选举时，集群中每个节点拥有 3 种角色：</p>
<pre><code>- ** Leader**，主节点；
- **Follower**，跟随者节点；
- **Observer**，观察者，无投票权。
</code></pre>
<p>选举过程中，集群中的节点拥有 4 个状态：</p>
<pre><code>- **Looking**状态，即选举状态。当节点处于该状态时，它会认为当前集群中没有 Leader，因此自己进入选举状态。
- **Leading**状态，即领导者状态，表示已经选出主，且当前节点为 Leader。
- **Following**状态，即跟随者状态，集群中已经选出主后，其他非主节点状态更新为Following，表示对 Leader 的追随。
- **Observing**状态，即观察者状态，表示当前节点为 Observer，持观望态度，没有投票权和选举权。
</code></pre>
<p>投票过程中，每个节点都有一个唯一的三元组 (server_id, server_zxID, epoch)，其中server_id 表示本节点的唯一 ID；server_zxID 表示本节点存放的数据 ID，数据 ID 越大表示数据越新，选举权重越大；epoch 表示当前选取轮数，一般用逻辑时钟表示。</p>
<p>ZAB 选举算法的核心是“少数服从多数，ID 大的节点优先成为主”，因此选举过程中通过(vote_id, vote_zxID) 来表明投票给哪个节点，其中 vote_id 表示被投票节点的 ID，vote_zxID 表示被投票节点的服务器 zxID。ZAB 算法选主的原则是：<strong>server_zxID 最大者成为 Leader；若 server_zxID 相同，则 server_id 最大者成为 Leader。</strong></p>
<p>接下来，我以 3 个 Server 的集群为例，此处每个 Server 代表一个节点，与你介绍 ZAB 选主的过程。</p>
<p>第一步：当系统刚启动时，3 个服务器当前投票均为第一轮投票，即 epoch=1，且 zxID均为 0。此时每个服务器都推选自己，并将选票信息 &lt;epoch, vote_id, vote_zxID&gt; 广播出去。</p>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1646703805954.png" alt="zab1" loading="lazy"></figure>
<p>第二步：根据判断规则，由于 3 个 Server 的 epoch、zxID 都相同，因此比较 server_id，较大者即为推选对象，因此 Server 1 和 Server 2 将 vote_id 改为 3，更新自己的投票箱并重新广播自己的投票。</p>
<figure data-type="image" tabindex="2"><img src="https://q456qq520.github.io/post-images/1646703819106.png" alt="zab2" loading="lazy"></figure>
<p>第三步：此时系统内所有服务器都推选了 Server 3，因此 Server 3 当选 Leader，处于Leading 状态，向其他服务器发送心跳包并维护连接；Server1 和 Server2 处于Following 状态。</p>
<figure data-type="image" tabindex="3"><img src="https://q456qq520.github.io/post-images/1646703831617.png" alt="zab3" loading="lazy"></figure>
<p>小结一下。ZAB 算法性能高，对系统无特殊要求，采用广播方式发送信息，若节点中有 n个节点，每个节点同时广播，则集群中信息量为 n*(n-1) 个消息，容易出现广播风暴；且除了投票，还增加了对比节点 ID 和数据 ID，这就意味着还需要知道所有节点的 ID 和数据ID，所以选举时间相对较长。但该算法选举稳定性比较好，当有新节点加入或节点故障恢复后，会触发选主，但不一定会真正切主，除非新节点或故障后恢复的节点数据 ID 和节点ID 最大，且获得投票数过半，才会导致切主。</p>
<p>#三种选举算法的对比分析</p>
<figure data-type="image" tabindex="4"><img src="https://q456qq520.github.io/post-images/1646703947766.png" alt="算法对比1" loading="lazy"></figure>
<h1 id="为什么多数派选主算法通常采用奇数节点而不是偶数节点呢">为什么“多数派”选主算法通常采用奇数节点，而不是偶数节点呢？</h1>
<p>多数派选主算法的核心是少数服从多数，获得投票多的节点胜出。想象一下，如果现在采用偶数节点集群，当两个节点均获得一半投票时，到底应该选谁为主呢？</p>
<p>答案是，在这种情况下，无法选出主，必须重新投票选举。但即使重新投票选举，两个节点拥有相同投票数的概率也会很大。因此，多数派选主算法通常采用奇数节点。</p>
]]></content>
    </entry>
</feed>