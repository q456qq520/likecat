<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://q456qq520.github.io</id>
    <title>LIKE CAT</title>
    <updated>2021-12-08T10:08:48.321Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://q456qq520.github.io"/>
    <link rel="self" href="https://q456qq520.github.io/atom.xml"/>
    <subtitle>一条小咸鱼</subtitle>
    <logo>https://q456qq520.github.io/images/avatar.png</logo>
    <icon>https://q456qq520.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, LIKE CAT</rights>
    <entry>
        <title type="html"><![CDATA[原型模式]]></title>
        <id>https://q456qq520.github.io/post/yuan-xing-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/yuan-xing-mo-shi/">
        </link>
        <updated>2021-12-08T08:51:25.000Z</updated>
        <content type="html"><![CDATA[<h4 id="概念">概念</h4>
<p>原型模式是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。</p>
<h4 id="问题">问题</h4>
<p>如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中。</p>
<p>但有个小问题。 并非所有对象都能通过这种方式进行复制， 因为有些对象可能拥有私有成员变量， 它们在对象本身以外是不可见的。</p>
<p>直接复制还有另外一个问题。 因为你必须知道对象所属的类才能创建复制品， 所以代码必须依赖该类。 即使你可以接受额外的依赖性， 那还有另外一个问题： 有时你只知道对象所实现的接口， 而不知道其所属的具体类， 比如可向方法的某个参数传入实现了某个接口的任何对象。</p>
<h4 id="原型模式解决方案">原型模式解决方案</h4>
<p>原型模式将克隆过程委派给被克隆的实际对象。 模式为所有支持<strong>克隆</strong>的对象声明了一个通用接口， 该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合。 通常情况下， 这样的接口中仅包含一个 克隆方法。</p>
<p>所有的类对<strong>克隆</strong>方法的实现都非常相似。 该方法会创建一个当前类的对象， 然后将原始对象所有的成员变量值复制到新建的类中。 你甚至可以复制私有成员变量， 因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。</p>
<p>支持克隆的对象即为原型。 当你的对象有几十个成员变量和几百种类型时， 对其进行<strong>克隆</strong>甚至可以代替子类的构造。</p>
<p>其运作方式如下： 创建一系列不同类型的对象并不同的方式对其进行配置。 如果所需对象与预先配置的对象相同， 那么你只需克隆原型即可， 无需新建一个对象。</p>
<h4 id="原型模式结构">原型模式结构</h4>
<h5 id="基本实现">基本实现</h5>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/diagrams/prototype/structure-2x.png?id=ba75079f42f08028ae4c" alt="原型模式结构" title="原型模式结构" loading="lazy"></figure>
<p>其中几个名次解释如下：</p>
<ul>
<li><strong>原型 （Prototype）</strong> 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 clone克隆的方法。</li>
<li>** 具体原型 （Concrete Prototype）**  类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。</li>
<li>** 客户端 （Client）**  可以复制实现了原型接口的任何对象。</li>
</ul>
<h5 id="原型注册表实现">原型注册表实现</h5>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/prototype/structure-prototype-cache-2x.png?id=a1e4514bbcc9b10968b8" alt="原型注册表实现" title="原型注册表实现" loading="lazy"></figure>
<ul>
<li><strong>原型注册表 （Prototype Registry）</strong> 提供了一种访问常用原型的简单方法， 其中存储了一系列可供随时复制的预生成对象。 最简单的注册表原型是一个 名称 → 原型的哈希表。 但如果需要使用名称以外的条件进行搜索， 你可以创建更加完善的注册表版本。</li>
</ul>
<h4 id="原型模式适合应用场景">原型模式适合应用场景</h4>
<ul>
<li>如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。</li>
<li>如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。</li>
</ul>
<h4 id="实现方式">实现方式</h4>
<ol>
<li>创建原型接口， 并在其中声明<strong>克隆</strong>方法。 如果你已有类层次结构， 则只需在其所有类中添加该方法即可。</li>
<li>原型类必须另行定义一个以该类对象为参数的构造函数。 构造函数必须复制参数对象中的所有成员变量值到新建实体中。 如果你需要修改子类， 则必须调用父类构造函数， 让父类复制其私有成员变量值。</li>
<li>克隆方法通常只有一行代码： 使用<strong>new</strong>运算符调用原型版本的构造函数。 注意， 每个类都必须显式重写克隆方法并使用自身类名调用<strong>new</strong>运算符。 否则， 克隆方法可能会生成父类的对象。</li>
<li>你还可以创建一个中心化原型注册表， 用于存储常用原型。<br>
<em>你可以新建一个工厂类来实现注册表，或者在原型基类中添加一个获取原型的静态方法。 该方法必须能够根据客户端代码设定的条件进行搜索。 搜索条件可以是简单的字符串， 或者是一组复杂的搜索参数。 找到合适的原型后， 注册表应对原型进行克隆， 并将复制生成的对象返回给客户端。最后还要将对子类构造函数的直接调用替换为对原型注册表工厂方法的调用。</em>`</li>
</ol>
<h4 id="优缺点">优缺点</h4>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>你可以克隆对象， 而无需与它们所属的具体类相耦合。</td>
<td style="text-align:center">克隆包含循环引用的复杂对象可能会非常麻烦。</td>
</tr>
<tr>
<td>你可以克隆预生成原型， 避免反复运行初始化代码。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>你可以更方便地生成复杂对象。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>你可以用继承以外的方式来处理复杂对象的不同配置。</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="与其他模式的关系">与其他模式的关系</h4>
<ul>
<li>在许多设计工作的初期都会使用<strong>工厂方法模式 <strong>（较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用</strong>抽象工厂模式、 原型模式</strong>或**生成器模式 **（更灵活但更加复杂）。</li>
<li><strong>抽象工厂模式</strong>通常基于一组<strong>工厂方法</strong>， 但你也可以使用<strong>原型模式</strong>来生成这些类的方法。</li>
<li>原型可用于保存<strong>命令模式</strong>的历史记录。</li>
<li>大量使用<strong>组合模式</strong>和<strong>装饰模式</strong>的设计通常可从对于<strong>原型</strong>的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</li>
<li><strong>原型</strong>并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 <strong>工厂方法</strong>基于继承， 但是它不需要初始化步骤。</li>
<li>有时候<strong>原型</strong>可以作为<strong>备忘录模式的</strong>一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。</li>
<li><strong>抽象工厂</strong>、 <strong>生成器</strong>和<strong>原型</strong>都可以用<strong>单例模式</strong>来实现。</li>
</ul>
<h4 id="伪代码">伪代码</h4>
<p>使用示例： Java 的 Cloneable  （可克隆） 接口就是立即可用的原型模式。任何类都可通过实现该接口来实现可被克隆的性质。<br>
java.lang.Object#clone() （类必须实现 java.lang.Cloneable 接口）<br>
识别方法： 原型可以简单地通过 clone或 copy等方法来识别。</p>
<p>下面就是一个复制图形的例子</p>
<h5 id="shapes-形状列表">shapes: 形状列表</h5>
<h6 id="shapesshapejava-通用形状接口">shapes/Shape.java: 通用形状接口</h6>
<pre><code>package refactoring_guru.prototype.example.shapes;

import java.util.Objects;

public abstract class Shape {
    public int x;
    public int y;
    public String color;

    public Shape() {
    }

    public Shape(Shape target) {
        if (target != null) {
            this.x = target.x;
            this.y = target.y;
            this.color = target.color;
        }
    }

    public abstract Shape clone();

    @Override
    public boolean equals(Object object2) {
        if (!(object2 instanceof Shape)) return false;
        Shape shape2 = (Shape) object2;
        return shape2.x == x &amp;&amp; shape2.y == y &amp;&amp; Objects.equals(shape2.color, color);
    }
}
</code></pre>
<h6 id="shapescirclejava-简单形状">shapes/Circle.java: 简单形状</h6>
<pre><code> package refactoring_guru.prototype.example.shapes;

public class Circle extends Shape {
    public int radius;

    public Circle() {
    }

    public Circle(Circle target) {
        super(target);
        if (target != null) {
            this.radius = target.radius;
        }
    }

    @Override
    public Shape clone() {
        return new Circle(this);
    }

    @Override
    public boolean equals(Object object2) {
        if (!(object2 instanceof Circle) || !super.equals(object2)) return false;
        Circle shape2 = (Circle) object2;
        return shape2.radius == radius;
    }
}
</code></pre>
<h6 id="shapesrectanglejava-另一个形状">shapes/Rectangle.java: 另一个形状</h6>
<pre><code>  package refactoring_guru.prototype.example.shapes;

public class Rectangle extends Shape {
    public int width;
    public int height;

    public Rectangle() {
    }

    public Rectangle(Rectangle target) {
        super(target);
        if (target != null) {
            this.width = target.width;
            this.height = target.height;
        }
    }

    @Override
    public Shape clone() {
        return new Rectangle(this);
    }

    @Override
    public boolean equals(Object object2) {
        if (!(object2 instanceof Rectangle) || !super.equals(object2)) return false;
        Rectangle shape2 = (Rectangle) object2;
        return shape2.width == width &amp;&amp; shape2.height == height;
    }
}
</code></pre>
<h6 id="demojava-克隆示例">Demo.java: 克隆示例</h6>
<pre><code>package refactoring_guru.prototype.example;

import refactoring_guru.prototype.example.shapes.Circle;
import refactoring_guru.prototype.example.shapes.Rectangle;
import refactoring_guru.prototype.example.shapes.Shape;

import java.util.ArrayList;
import java.util.List;

public class Demo {
    public static void main(String[] args) {
        List&lt;Shape&gt; shapes = new ArrayList&lt;&gt;();
        List&lt;Shape&gt; shapesCopy = new ArrayList&lt;&gt;();

        Circle circle = new Circle();
        circle.x = 10;
        circle.y = 20;
        circle.radius = 15;
        circle.color = &quot;red&quot;;
        shapes.add(circle);

        Circle anotherCircle = (Circle) circle.clone();
        shapes.add(anotherCircle);

        Rectangle rectangle = new Rectangle();
        rectangle.width = 10;
        rectangle.height = 20;
        rectangle.color = &quot;blue&quot;;
        shapes.add(rectangle);

        cloneAndCompare(shapes, shapesCopy);
    }

    private static void cloneAndCompare(List&lt;Shape&gt; shapes, List&lt;Shape&gt; shapesCopy) {
        for (Shape shape : shapes) {
            shapesCopy.add(shape.clone());
        }

        for (int i = 0; i &lt; shapes.size(); i++) {
            if (shapes.get(i) != shapesCopy.get(i)) {
                System.out.println(i + &quot;: Shapes are different objects (yay!)&quot;);
                if (shapes.get(i).equals(shapesCopy.get(i))) {
                    System.out.println(i + &quot;: And they are identical (yay!)&quot;);
                } else {
                    System.out.println(i + &quot;: But they are not identical (booo!)&quot;);
                }
            } else {
                System.out.println(i + &quot;: Shape objects are the same (booo!)&quot;);
            }
        }
    }
}
</code></pre>
<h6 id="outputdemotxt-执行结果">OutputDemo.txt: 执行结果</h6>
<pre><code>0: Shapes are different objects (yay!)
0: And they are identical (yay!)
1: Shapes are different objects (yay!)
1: And they are identical (yay!)
2: Shapes are different objects (yay!)
2: And they are identical (yay!)
</code></pre>
<h5 id="原型注册站">原型注册站</h5>
<p>你可以实现中心化的原型注册站 （或工厂）， 其中包含一系列预定义的原型对象。 这样一来， 你就可以通过传递对象名称或其他参数的方式从工厂处获得新的对象。 工厂将搜索合适的原型， 然后对其进行克隆复制， 最后将副本返回给你。</p>
<h5 id="cache">cache</h5>
<h6 id="cachebundledshapecachejava-原型工厂">cache/BundledShapeCache.java: 原型工厂</h6>
<pre><code>package refactoring_guru.prototype.caching.cache;

import refactoring_guru.prototype.example.shapes.Circle;
import refactoring_guru.prototype.example.shapes.Rectangle;
import refactoring_guru.prototype.example.shapes.Shape;

import java.util.HashMap;
import java.util.Map;

public class BundledShapeCache {
    private Map&lt;String, Shape&gt; cache = new HashMap&lt;&gt;();

    public BundledShapeCache() {
        Circle circle = new Circle();
        circle.x = 5;
        circle.y = 7;
        circle.radius = 45;
        circle.color = &quot;Green&quot;;

        Rectangle rectangle = new Rectangle();
        rectangle.x = 6;
        rectangle.y = 9;
        rectangle.width = 8;
        rectangle.height = 10;
        rectangle.color = &quot;Blue&quot;;

        cache.put(&quot;Big green circle&quot;, circle);
        cache.put(&quot;Medium blue rectangle&quot;, rectangle);
    }

    public Shape put(String key, Shape shape) {
        cache.put(key, shape);
        return shape;
    }

    public Shape get(String key) {
        return cache.get(key).clone();
    }
}
</code></pre>
<h6 id="demojava-克隆示例-2">Demo.java: 克隆示例</h6>
<pre><code>package refactoring_guru.prototype.caching;

import refactoring_guru.prototype.caching.cache.BundledShapeCache;
import refactoring_guru.prototype.example.shapes.Shape;

public class Demo {
    public static void main(String[] args) {
        BundledShapeCache cache = new BundledShapeCache();

        Shape shape1 = cache.get(&quot;Big green circle&quot;);
        Shape shape2 = cache.get(&quot;Medium blue rectangle&quot;);
        Shape shape3 = cache.get(&quot;Medium blue rectangle&quot;);

        if (shape1 != shape2 &amp;&amp; !shape1.equals(shape2)) {
            System.out.println(&quot;Big green circle != Medium blue rectangle (yay!)&quot;);
        } else {
            System.out.println(&quot;Big green circle == Medium blue rectangle (booo!)&quot;);
        }

        if (shape2 != shape3) {
            System.out.println(&quot;Medium blue rectangles are two different objects (yay!)&quot;);
            if (shape2.equals(shape3)) {
                System.out.println(&quot;And they are identical (yay!)&quot;);
            } else {
                System.out.println(&quot;But they are not identical (booo!)&quot;);
            }
        } else {
            System.out.println(&quot;Rectangle objects are the same (booo!)&quot;);
        }
    }
}
</code></pre>
<h6 id="outputdemotxt-执行结果-2">OutputDemo.txt: 执行结果</h6>
<pre><code>Big green circle != Medium blue rectangle (yay!)
Medium blue rectangles are two different objects (yay!)
And they are identical (yay!)
</code></pre>
<p><a href="https://refactoringguru.cn/design-patterns/prototype">参考地址：https://refactoringguru.cn/design-patterns/prototype</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jedis连接池]]></title>
        <id>https://q456qq520.github.io/post/jedis-lian-jie-chi/</id>
        <link href="https://q456qq520.github.io/post/jedis-lian-jie-chi/">
        </link>
        <updated>2021-10-25T06:32:56.000Z</updated>
        <content type="html"><![CDATA[<h5 id="一-为什么使用-jedis-连接池">一 为什么使用 Jedis 连接池</h5>
<pre><code>   当使用 Jedis 直连 Redis 的时候，存在每次新建、关闭连接的开销，极端情况可能出现连接泄漏的问题。而使用连接池是说在一个池子里面对连接进行管理，当请求过来之后先从连接池里面借用连接，用完之后再次归还连接。连接池的连接可以得到复用，有利于降低系统开销，提升系统性能。
</code></pre>
<h5 id="二-jedis-使用连接池">二 Jedis 使用连接池</h5>
<h3 id="21-jedispool-代码">2.1 JedisPool 代码</h3>
<p>(```)</p>
<p>@Configuration<br>
public class JedisClient {</p>
<pre><code>private int minIdle = 1;
private int maxIdle = 8;
private int maxTotal = 256;
private int maxWait = 50;

@Bean
public JedisPoolConfig jedisPoolConfig() {
    JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
    jedisPoolConfig.setMinIdle(minIdle);
    jedisPoolConfig.setMaxIdle(maxIdle);
    jedisPoolConfig.setMaxTotal(maxTotal);
    jedisPoolConfig.setTestOnBorrow(true);
    jedisPoolConfig.setTestOnReturn(true);
    jedisPoolConfig.setBlockWhenExhausted(true);
    jedisPoolConfig.setMaxWaitMillis(maxWait);
    jedisPoolConfig.setFairness(false);
    return jedisPoolConfig;
}
</code></pre>
<p>}<br>
(```)</p>
<h3 id="22-genericobjectpoolconfig-参数配置说明">2.2 GenericObjectPoolConfig 参数配置说明</h3>
<ul>
<li>maxIdle ：连接池中最大的空闲连接数，默认为 8。</li>
<li>minIdle：连接池中最少空闲连接数，默认为 0。</li>
<li>maxTotal：连接池中最大连接数，默认为 8。</li>
<li>maxWaitMillis：当连接池资源用尽后，调用者的最大等待时间（单位为毫秒），一般不建议使用默认值，该默认值为-1，表示永远不超时，一直等待。</li>
<li>testOnBorrow：向连接池借用连接时是否做连接有效性检测（ping），无效连接会被移除，每次借用多执行一次 ping 命令，默认值为 false。</li>
<li>testOnReturn：向连接池归还连接时是否做连接有效性检测（ping），无效连接会被移除，每次归还多执行一次 ping 命令，默认值为 false。</li>
<li>testOWhileIdle：向连接池借用连接时是否做连接空闲检测，空闲超时的连接会被移除，默认值为 false。</li>
<li>blockWhenExhausted：当连接池用尽后，调用者是否要等待，这个参数是和 maxWaitMillis 对应的，只有当此参数为 true 时，maxWaitMillis 才会生效。默认值为 true。</li>
<li>minEvictableIdleTimeMillis：连接的最小空闲时间，达到此值后空闲连接将被移除，默认值 30 分钟。</li>
<li>timeBetweenEvictionRunsMillis：空闲连接的检测周期（单位为毫秒），默认值为 -1，表示不做检测。</li>
<li>numTestsPerEvictionRun：做空闲连接检测时，每次的采样数，默认为 3。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis内存模型]]></title>
        <id>https://q456qq520.github.io/post/redis-nei-cun-mo-xing/</id>
        <link href="https://q456qq520.github.io/post/redis-nei-cun-mo-xing/">
        </link>
        <updated>2021-10-08T08:40:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="基本数据类型">基本数据类型</h3>
<p>String（字符串）、List（列表）、Hash（哈希）、Set（集合）和Sorted Set（有序集合）</p>
<h3 id="底层数据结构">底层数据结构</h3>
<p>动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组</p>
<p><img src="https://static001.geekbang.org/resource/image/f2/2d/f204bdcf37f31c7abcee065daed8dd2d.jpg" alt="底层数据结构" title="底层数据结构" loading="lazy"><br>
可以看到String类型下只要一种数据结构，但是List（列表）、Hash（哈希）、Set（集合）和Sorted Set（有序集合）每个都有2种数据结构，所以也被称之为集合类型。它们均是<strong>一个键对应了一个集合的数据</strong></p>
<h3 id="redis中kv如何保存">Redis中KV如何保存</h3>
<ol>
<li>
<h4 id="一个哈希表来保存所有键值对">一个哈希表来保存所有键值对。</h4>
一个哈希表，也是一个数组，数组的每个元素称为一个哈希桶。一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。<br>
但是哈希表中保存对键值对并不是真实保存对数据，而是指向数据的指针。这样一来不管是字符串还是聚合类型查找所需的时间复杂度均是O(1)。</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/8d/54/8dfc3abd55a2262049b9b77394186554.jpg" alt="redis哈希表" title="redis哈希表" loading="lazy"></figure>
<ol start="2">
<li>
<h4 id="哈希冲突">哈希冲突</h4>
<p>一般来说，哈希桶的个数通常要少于key的数量，这也就是说，难免会有一些key的哈希值对应到了同一个哈希桶中。<br>
当数据量越来越大时，哈希冲突是不可避免的问题。<br>
Redis解决哈希冲突的方式，就是链式哈希。就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。<br>
<img src="https://static001.geekbang.org/resource/image/a5/16/a5cf457ef10cc97b60521ba6caf3d016.jpg" alt="哈希冲突" title="哈希冲突" loading="lazy"><br>
使用链式哈希也有一定当缺陷，就是当链表越来越长时，查询速度也会极具下降。</p>
</li>
<li>
<h4 id="rehash">Rehash</h4>
<p>为了解决上述带来当问题，Redis会对哈希表做rehash操作。rehash也就是增加现有的哈希桶数量，让逐渐增多的entry元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。<br>
Redis默认使用了两个全局哈希表：哈希表1和哈希表2。一开始，当你刚插入数据时，默认使用哈希表1，此时的哈希表2并没有被分配空间。随着数据逐步增多，Redis开始执行rehash，这个过程分为三步：</p>
<ul>
<li>给哈希表2分配更大的空间，例如是当前哈希表1大小的两倍；</li>
<li>把哈希表1中的数据重新映射并拷贝到哈希表2中；</li>
<li>释放哈希表1的空间。<br>
这样就完成了从哈希表1切换到哈希表2，用增大的哈希表2保存更多数据，而原来的哈希表1留作下一次rehash扩容备用。</li>
</ul>
<hr>
<p>但是如果一次性拷贝全部数据会带来线程阻塞，这样就无法正常提供服务了。所以redis采取了<strong>渐进式rehash</strong>。也就是当请求进来时，从哈希表1中依次把这个哈希桶链表下的元素复制到哈希表2中（一个请求一次）。<br>
<img src="https://static001.geekbang.org/resource/image/d0/88/d05c0yy6af25088175a0ac9cdbe2de88.jpg" alt="渐进式rehash" title="渐进式rehash" loading="lazy"><br>
对于String类型来说，找到哈希桶就能直接增删改查了，所以，哈希表的O(1)操作复杂度也就是它的复杂度了。<br>
但是，对于集合类型来说，即使找到哈希桶了，还要在集合中再进一步操作。</p>
</li>
<li>
<h4 id="集合数据操作效率">集合数据操作效率</h4>
<p>集合数据中到数据结构主要有5种：双向链表、压缩列表、哈希表、跳表和整数数组<br>
和String类型不同，一个集合类型的值，第一步是通过全局哈希表找到对应的哈希桶位置，第二步是在集合中再增删改查。<br>
哈希表就是数组加链表，整数数组和双向链表也很常见，它们的操作特征都是顺序读写，也就是通过数组下标或者链表的指针逐个元素访问，操作复杂度基本是O(N)，<br>
压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段zlbytes(列表长度)、zltail(列表尾的偏移量)和zllen(列表中的entry个数)，压缩列表在表尾还有一个zlend，表示列表结束。<br>
在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是O(1)。而查找其他元素时，只能逐个查找，复杂度就是O(N)了。<br>
<img src="https://static001.geekbang.org/resource/image/5d/22/5df168dcafa0db242b0221ab10114e22.jpg" alt="压缩列表" title="压缩列表" loading="lazy"></p>
<p>有序链表只能逐一查找元素，导致操作起来非常缓慢，于是就出现了跳表。具体来说，跳表<strong>在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位</strong>，跳表的查找复杂度为O(logN)。<br>
<img src="https://static001.geekbang.org/resource/image/4e/11/4ecf630ea2bce0b11ecc0397487b3111.jpg" alt="跳表" title="跳表" loading="lazy"></p>
</li>
<li>
<h4 id="数据结构时间复杂度">数据结构时间复杂度</h4>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">数据结构类型</th>
<th style="text-align:center">时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">哈希表</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center">跳表</td>
<td style="text-align:center">O(logN)</td>
</tr>
<tr>
<td style="text-align:center">双向链表</td>
<td style="text-align:center">O(N)</td>
</tr>
<tr>
<td style="text-align:center">压缩列表</td>
<td style="text-align:center">O(N)</td>
</tr>
<tr>
<td style="text-align:center">整数数组</td>
<td style="text-align:center">O(N)</td>
</tr>
</tbody>
</table>
<ol start="6">
<li>
<h4 id="不同操作的复杂度">不同操作的复杂度</h4>
</li>
</ol>
<p>集合类型的操作类型很多，有读写单个集合元素的，例如HGET、HSET，也有操作多个元素的，例如SADD，还有对整个集合进行遍历操作的，例如SMEMBERS。这么多操作，它们的复杂度也各不相同。而复杂度的高低又是选择集合类型的重要依据。</p>
<p>第一，单元素操作，是指每一种集合类型对单个数据实现的增删改查操作。例如，Hash类型的HGET、HSET和HDEL，Set类型的SADD、SREM、SRANDMEMBER等。这些操作的复杂度由集合采用的数据结构决定，例如，HGET、HSET和HDEL是对哈希表做操作，所以它们的复杂度都是O(1)；Set类型用哈希表作为底层数据结构时，它的SADD、SREM、SRANDMEMBER复杂度也是O(1)。</p>
<p>这里，有个地方你需要注意一下，集合类型支持同时对多个元素进行增删改查，例如Hash类型的HMGET和HMSET，Set类型的SADD也支持同时增加多个元素。此时，这些操作的复杂度，就是由单个元素操作复杂度和元素个数决定的。例如，HMSET增加M个元素时，复杂度就从O(1)变成O(M)了。</p>
<p>第二，范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据，比如Hash类型的HGETALL和Set类型的SMEMBERS，或者返回一个范围内的部分数据，比如List类型的LRANGE和ZSet类型的ZRANGE。这类操作的复杂度一般是O(N)，比较耗时，我们应该尽量避免。</p>
<p>不过，Redis从2.8版本开始提供了SCAN系列操作（包括HSCAN，SSCAN和ZSCAN），这类操作实现了渐进式遍历，每次只返回有限数量的数据。这样一来，相比于HGETALL、SMEMBERS这类操作来说，就避免了一次性返回所有元素而导致的Redis阻塞。</p>
<p>第三，统计操作，是指集合类型对集合中所有元素个数的记录，例如LLEN和SCARD。这类操作复杂度只有O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。</p>
<p>第四，例外情况，是指某些数据结构的特殊记录，例如压缩列表和双向链表都会记录表头和表尾的偏移量。这样一来，对于List类型的LPOP、RPOP、LPUSH、RPUSH这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有O(1)，可以实现快速操作。</p>
<p>Redis之所以能快速操作键值对，一方面是因为O(1)复杂度的哈希表被广泛使用，包括String、Hash和Set，它们的操作复杂度基本由哈希表决定，另一方面，Sorted Set也采用了O(logN)复杂度的跳表。不过，集合类型的范围操作，因为要遍历底层数据结构，复杂度通常是O(N)。这里，我的建议是：用其他命令来替代，例如可以用SCAN来代替，避免在Redis内部产生费时的全集合遍历操作。<br>
当然，我们不能忘了复杂度较高的List类型，它的两种底层实现结构：双向链表和压缩列表的操作复杂度都是O(N)。因此，我的建议是：因地制宜地使用List类型。例如，既然它的POP/PUSH效率很高，那么就将它主要用于FIFO队列场景，而不是作为一个可以随机读写的集合。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Springboot中tomcat的启动流程]]></title>
        <id>https://q456qq520.github.io/post/spcat/</id>
        <link href="https://q456qq520.github.io/post/spcat/">
        </link>
        <updated>2021-07-13T09:16:41.000Z</updated>
        <content type="html"><![CDATA[<h5 id="一">一、</h5>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[生成器模式]]></title>
        <id>https://q456qq520.github.io/post/scj/</id>
        <link href="https://q456qq520.github.io/post/scj/">
        </link>
        <updated>2021-07-12T07:35:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-什么是生成器模式">一、什么是生成器模式</h3>
<h5 id="1-使用相同的创建代码生成不同类型和形式的对象">1. 使用相同的创建代码生成不同类型和形式的对象。</h5>
<p>读起来有点拗口对吧，其实就是说给创建对象提供一个统一对入口，你不用去管内部发生了什么，只需要提取你所需要对结果。<br>
举个例子，你现在需要创建一个房子对象，假设第一栋房子需要四面墙和地板、门和窗，但是第二栋房子在次基础之上额外需要天然气、水、电等，按正常等逻辑我们是可以在前者基础上拓展基类，但是每新增一种房型就需要新增一个子类，要是新增一个参数那就更加麻烦了。还有一个比较简单等实现就是在房屋类上写一个涵盖所有属性等构造函数，但是对于绝大部分情况而言，很多参数都是不需要使用的，这样就会造成构造函数的臃肿。<br>
这个时候就可以使用生成器模式了。</p>
<h3 id="二-怎么实现生成器模式">二、怎么实现生成器模式</h3>
<h5 id="1-将对象构造代码从产品类中抽取出来-并将其放在一个名为生成器的独立对象中">1. 将对象构造代码从产品类中抽取出来， 并将其放在一个名为生成器的独立对象中。</h5>
<p>还是拿上面的例子来说，生成器模式可以将建造房子对象拆分成一组步骤，每次创建对象时， 你都需要通过生成器对象执行一系列步骤。 重点在于你无需调用所有步骤， 而只需调用创建特定对象配置所需的那些步骤即可。<br>
<img src="https://q456qq520.github.io/post-images/1626077781879.png" alt="" loading="lazy"><br>
当你需要创建不同形式的产品时， 其中的一些构造步骤可能需要不同的实现。 例如， 木屋的房门可能需要使用木头制造， 而城堡的房门则必须使用石头制造。<br>
在这种情况下， 你可以创建多个不同的生成器， 用不同方式实现一组相同的创建步骤。 然后你就可以在创建过程中使用这些生成器 （例如按顺序调用多个构造步骤） 来生成不同类型的对象。</p>
<h5 id="2-生成器模式中的主管">2. 生成器模式中的主管。</h5>
<p>你可以进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类。 主管类可定义创建步骤的执行顺序， 而生成器则提供这些步骤的实现。<br>
对于客户端代码来说， 主管类完全隐藏了产品构造细节。 客户端只需要将一个生成器与主管类关联， 然后使用主管类来构造产品， 就能从生成器处获得构造结果了。<br>
主管类不是必须的，取决与开发者自身。</p>
<h3 id="三-生成器模式结构">三、生成器模式结构</h3>
<figure data-type="image" tabindex="1"><img src="https://q456qq520.github.io/post-images/1626077964299.png" alt="" loading="lazy"></figure>
<ol>
<li>生成器 （Builder） 接口声明在所有类型生成器中通用的产品构造步骤。</li>
<li>具体生成器 （Concrete Builders） 提供构造过程的不同实现。 具体生成器也可以构造不遵循通用接口的产品。</li>
<li>产品 （Products） 是最终生成的对象。 由不同生成器构造的产品无需属于同一类层次结构或接口。</li>
<li>主管 （Director） 类定义调用构造步骤的顺序， 这样你就可以创建和复用特定的产品配置。</li>
<li>客户端 （Client） 必须将某个生成器对象与主管类关联。 一般情况下， 你只需通过主管类构造函数的参数进行一次性关联即可。 此后主管类就能使用生成器对象完成后续所有的构造任务。 但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。 在这种情况下， 你在使用主管类生产产品时每次都可以使用不同的生成器。</li>
</ol>
<h3 id="四-生成器模式适合应用场景">四、生成器模式适合应用场景</h3>
<h5 id="1使用生成器模式可避免-重叠构造函数-的出现">1.使用生成器模式可避免 “重叠构造函数）” 的出现。</h5>
<p><em>也就是上文所说的一个构造函数涵盖全部的属性行为</em></p>
<h5 id="2创建不同形式的产品">2.创建不同形式的产品</h5>
<p><em>如果你需要创建的各种形式的产品， 它们的制造过程相似且仅有细节上的差异， 此时可使用生成器模式。</em></p>
<h5 id="3使用生成器构造组合树或其他复杂对象">3.使用生成器构造组合树或其他复杂对象</h5>
<p><em>生成器模式让你能分步骤构造产品。 你可以延迟执行某些步骤而不会影响最终产品。 你甚至可以递归调用这些步骤， 这在创建对象树时非常方便。</em></p>
<h3 id="五-生成器模式优缺点">五、生成器模式优缺点</h3>
<h5 id="优点">优点</h5>
<ul>
<li>分步创建对象， 暂缓创建步骤或递归运行创建步骤。</li>
<li>生成不同形式的产品时，复用相同的制造代码。</li>
<li>单一职责原则。 将复杂构造代码从产品的业务逻辑中分离出来。</li>
</ul>
<h5 id="缺点">缺点</h5>
<ul>
<li>由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。</li>
</ul>
<h3 id="六-伪代码">六、伪代码</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单例模式]]></title>
        <id>https://q456qq520.github.io/post/Singleton/</id>
        <link href="https://q456qq520.github.io/post/Singleton/">
        </link>
        <updated>2021-07-09T09:18:24.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-什么是单例模式">一、什么是单例模式</h3>
<h5 id="1-只能保证类只有一个实例">1. 只能保证类只有一个实例。</h5>
<p><em>普通构造函数无法实现上述行为， 因为构造函数的设计决定了它必须总是返回一个新对象。</em></p>
<h5 id="2-为该实例提供一个全局访问节点">2.  为该实例提供一个全局访问节点。</h5>
<p><em>也就是对外部提供一个统一的获取实例的入口</em></p>
<h3 id="二-怎么实现单例模式">二、怎么实现单例模式</h3>
<h5 id="1-将默认构造函数设为私有-防止其他对象使用单例类的-new运算符">1. 将默认构造函数设为私有， 防止其他对象使用单例类的 new运算符。</h5>
<h5 id="2-新建一个静态构建方法作-该方法用来调用私有构造函数来创建对象-并将其保存在一个静态成员变量中-此后所有对于该函数的调用都将返回这一缓存对象">2. 新建一个静态构建方法作。该方法用来调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。</h5>
<p>下图是我从网上“偷”来的一张单例模式类图，从图中很明显的可以看出单例模式的结构模式<br>
<img src="https://q456qq520.github.io/post-images/1625823739270.png" alt="" loading="lazy"></p>
<h3 id="三-适用场景">三、适用场景</h3>
<h5 id="1-对于程序中的某个类全局共用一个实例">1. 对于程序中的某个类全局共用一个实例</h5>
<p>单例模式并不等同于全局变量，因为它只保证类存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。</p>
<h3 id="四-伪代码">四、伪代码</h3>
<h5 id="1-eager-initialization">1. Eager initialization</h5>
<p>这种模式下单例类的实例是在类加载时创建的，这是创建单例类的最简单方法，但它有一个缺点，即即使客户端应用程序可能不会使用它，也会创建实例。</p>
<pre><code class="language-Eager">public class EagerInitialization {
    public static final EagerInitialization eagerInitialization= new EagerInitialization();

    private EagerInitialization() {
    }

    public static EagerInitialization getInstance(){
        return eagerInitialization;
    }
}
</code></pre>
<h5 id="2-static-block-initialization">2. Static block initialization</h5>
<p>静态块初始化实现类似于预先初始化，不同之处在于类的实例是在静态块中创建的，</p>
<pre><code class="language-Static">public class StaticBlockSingleton {
    private static StaticBlockSingleton staticBlockSingleton;

    private StaticBlockSingleton() {
    }

    static{
        try{
            staticBlockSingleton = new StaticBlockSingleton();
        }catch(Exception e){
            throw new RuntimeException(&quot;creating singleton instance exception&quot;);
        }
    }

    public static StaticBlockSingleton getInstance(){
        return staticBlockSingleton;
    }
}
</code></pre>
<h5 id="3-lazy-initialization懒汉式">3. Lazy Initialization（懒汉式）</h5>
<p>实现单例模式的延迟初始化方法在全局访问方法中创建实例。并不会类加载时就创建实例，而时在客户端第一次访问时才会初始化。</p>
<pre><code class="language-Lazy">public class LazyInitializedSingleton {
    public static LazyInitializedSingleton lazyInitializedSingleton;

    private LazyInitializedSingleton() {
    }

    public static LazyInitializedSingleton getInstance(){
        if(lazyInitializedSingleton == null){
            lazyInitializedSingleton =  new LazyInitializedSingleton();
        }
        return lazyInitializedSingleton;
    }
}
</code></pre>
<p>在多线程环境下，上述生成单例模式是不安全的，下面会讲述几种线程安全的创建方式。</p>
<h5 id="4-thread-safe-singleton">4. Thread Safe Singleton</h5>
<p>最简单的是使全局访问方法同步，以便一次只有一个线程可以执行此方法。</p>
<pre><code class="language-Thread">public class ThreadSafeSingleton {
    public static ThreadSafeSingleton threadSafeSingleton;

    private ThreadSafeSingleton() {
    }

    public static synchronized ThreadSafeSingleton getInstance(){
        if(threadSafeSingleton == null){
            threadSafeSingleton =  new ThreadSafeSingleton();
        }
        return threadSafeSingleton;
    }
}
</code></pre>
<p>其实并不需要每次获取实例都进行锁，为了每次都避免这种额外的开销，还可以使用下面都双重校验锁都方式</p>
<pre><code class="language-UsingDoubleLocking">public static ThreadSafeSingleton getInstanceUsingDoubleLocking(){
    if(threadSafeSingleton == null){
        synchronized (ThreadSafeSingleton.class) {
             if(threadSafeSingleton == null){
                 threadSafeSingleton = new ThreadSafeSingleton();
             }
         }
    }
    return threadSafeSingleton;
 }
</code></pre>
<h5 id="5-bill-pugh-singleton-implementation静态内部类">5. Bill Pugh Singleton Implementation（静态内部类）</h5>
<p>当加载单例类时，<em>SingletonHelper</em>类不会加载到内存中，只有当有人调用getInstance方法时，才会加载这个类并创建单例类实例。</p>
<pre><code class="language-Bill">public class BillPughSingleton {

    private BillPughSingleton() {
    }

    private static class SingletonHelper{
        private static final BillPughSingleton INSTANCE = new BillPughSingleton();
    }

    public static BillPughSingleton getInstance(){
        return SingletonHelper.INSTANCE;
    }
}
</code></pre>
<h5 id="6-using-reflection-to-destroy-singleton-pattern反射">6. Using Reflection to destroy Singleton Pattern（反射）</h5>
<p>反射会破坏单例模式，下面例子生成的hashcode是不同的，感兴趣的可以试试。</p>
<pre><code class="language-Using"> public static void main(String[] args) {
        EagerInitialization instanceOne = EagerInitialization.getInstance();
        EagerInitialization instanceTwo = null;
        try {
            Constructor[] constructors = EagerInitialization.class.getDeclaredConstructors();
            for (Constructor constructor : constructors) {
                constructor.setAccessible(true);
                instanceTwo = (EagerInitialization) constructor.newInstance();
                break;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(instanceOne.hashCode());
        System.out.println(instanceTwo.hashCode());
    }
</code></pre>
<h5 id="7-enum-singleton枚举">7. Enum Singleton（枚举）</h5>
<p>Java 确保任何枚举值在 Java 程序中仅被实例化一次。由于Java 枚举值是全局可访问的，因此单例也是如此。缺点是枚举类型有点不灵活；例如，它不允许延迟初始化。</p>
<pre><code class="language-Enum">public enum EnumSingleton {
    INSTANCE;

    public static void doSomething(){
        //do something
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RocketMq消息及其应用]]></title>
        <id>https://q456qq520.github.io/post/rocketmq/</id>
        <link href="https://q456qq520.github.io/post/rocketmq/">
        </link>
        <updated>2021-07-09T04:42:00.000Z</updated>
        <content type="html"><![CDATA[<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">一</mi><mi mathvariant="normal">、</mi><mi mathvariant="normal">延</mi><mi mathvariant="normal">迟</mi><mi mathvariant="normal">消</mi><mi mathvariant="normal">息</mi></mrow><annotation encoding="application/x-tex">一、延迟消息</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">、</span><span class="mord cjk_fallback">延</span><span class="mord cjk_fallback">迟</span><span class="mord cjk_fallback">消</span><span class="mord cjk_fallback">息</span></span></span></span><br>
定时消息（延迟队列）是指消息发送到broker后，不会立即被消费，等待特定时间投递给真正的topic。</p>
<p>broker有配置项messageDelayLevel，默认值为“<s>1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</s>”，18个level。<br>
配置自定义messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 10m 15m 20m 30m 1h 3h 6h 12h 24h</p>
<p>注意，messageDelayLevel是broker的属性，不属于某个topic。<br>
发消息时，设置delayLevel等级即可。level有以下三种情况：</p>
<ul>
<li>level == 0，消息为非延迟消息</li>
<li>1&lt;=level&lt;=maxLevel，消息延迟特定时间，例如level==1，延迟1s</li>
<li>level &gt; maxLevel，则level== maxLevel，例如level==20，延迟24h</li>
</ul>
<p>定时消息会暂存在名为SCHEDULE_TOPIC_XXXX的topic中，并根据delayTimeLevel存入特定的queue，queueId = delayTimeLevel – 1，即一个queue只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。broker会调度地消费SCHEDULE_TOPIC_XXXX，将消息写入真实的topic。</p>
<p>需要注意的是，定时消息会在第一次写入和调度写入真实topic时都会计数，因此发送数量、tps都会变高。</p>
<pre><code class="language-java">/**
   * 重试次数--延迟级别对应关系
   */
    static ConcurrentHashMap&lt;Integer,Integer&gt; retryTimeDelayLevelMap = new ConcurrentHashMap&lt;&gt;();
    static{
        retryTimeDelayLevelMap.put(1,5);//1min
        retryTimeDelayLevelMap.put(4,14);//1h
        retryTimeDelayLevelMap.put(2,7);//3min
        retryTimeDelayLevelMap.put(3,10);//10min
    }
//发送延迟消息
public void sendDelayNotify(VideoStateChangeEvent event) {
        try{
            if(event.getRetryTimes()&gt;4 || event.getRetryTimes()&lt;1){
                LOG.warn(&quot;仅仅支持重发4次 retryTimes:{}&quot;,event.getRetryTimes());
                return;
            }
            org.springframework.messaging.Message mmm = MessageBuilder.withPayload(event).build();
            ResultDTO r = rocketMQTemplate.syncSendDelay(mediaCallbackTopic + &quot;:&quot; + event.getEventType(), mmm, retryTimeDelayLevelMap.get(event.getRetryTimes()));
        }catch(Exception e){
            //dosomething
        }
    }
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">二</mi><mi mathvariant="normal">、</mi><mi mathvariant="normal">重</mi><mi mathvariant="normal">试</mi><mi mathvariant="normal">消</mi><mi mathvariant="normal">息</mi></mrow><annotation encoding="application/x-tex">二、重试消息</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">、</span><span class="mord cjk_fallback">重</span><span class="mord cjk_fallback">试</span><span class="mord cjk_fallback">消</span><span class="mord cjk_fallback">息</span></span></span></span><br>
Consumer消费消息失败后，要提供一种重试机制，令消息再消费一次。Consumer消费消息失败通常可以认为有以下几种情况：</p>
<p>由于消息本身的原因，例如反序列化失败，消息数据本身无法处理（例如话费充值，当前消息的手机号被注销，无法充值）等。这种错误通常需要跳过这条消息，再消费其它消息，而这条失败的消息即使立刻重试消费，99%也不成功，所以最好提供一种定时重试机制，即过10秒后再重试。<br>
由于依赖的下游应用服务不可用，例如db连接不可用，外系统网络不可达等。遇到这种错误，即使跳过当前失败的消息，消费其他消息同样也会报错。这种情况建议应用sleep 30s，再消费下一条消息，这样可以减轻Broker重试消息的压力。<br>
RocketMQ会为每个消费组都设置一个Topic名称为“%RETRY%+consumerGroup”的重试队列（这里需要注意的是，这个Topic的重试队列是针对消费组，而不是针对每个Topic设置的），用于暂时保存因为各种异常而导致Consumer端无法消费的消息。考虑到异常恢复起来需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有与之对应的重新投递延时，重试次数越多投递延时就越大。RocketMQ对于重试消息的处理是先保存至Topic名称为“SCHEDULE_TOPIC_XXXX”的延迟队列中，后台定时任务按照对应的时间进行Delay后重新保存至“%RETRY%+consumerGroup”的重试队列中。</p>
<pre><code class="language-java">/**
 * 消费者
 */
@Service
@RocketMQMessageListener(
        consumerGroup = &quot;${consumer}&quot;,
        topic = &quot;${topic}&quot;,
        selectorExpression = &quot;*&quot;)
public class CallbackTopicConsumer implements RocketMQListener&lt;MessageExt&gt;{(CallbackTopicConsumer.class);
    @Override
    public void onMessage(MessageExt msg) {
        try {
            byte[] bytes = msg.getBody();
            //dosomething
        }catch (MediaStorePlatformException e1){
            //对于特定异常类型，如果异常被catch后，没有往外抛，client认为消息已经被消费。
            //此时，消息会丢弃
          //dosomething
        }catch (Exception e) {
            //dosomething
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git冲突相关解决方案]]></title>
        <id>https://q456qq520.github.io/post/git/</id>
        <link href="https://q456qq520.github.io/post/git/">
        </link>
        <updated>2021-07-07T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>拉取远程分支失败，如果是git未忽略文件，可以cd至该工程目录下使用   <code>git rm --cached xxx.iml</code>删除完后再次尝试拉取。</p>
]]></content>
    </entry>
</feed>