<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://q456qq520.github.io</id>
    <title>LIKE CAT</title>
    <updated>2022-02-25T08:15:13.483Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://q456qq520.github.io"/>
    <link rel="self" href="https://q456qq520.github.io/atom.xml"/>
    <subtitle>一条小咸鱼</subtitle>
    <logo>https://q456qq520.github.io/images/avatar.png</logo>
    <icon>https://q456qq520.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, LIKE CAT</rights>
    <entry>
        <title type="html"><![CDATA[外观模式]]></title>
        <id>https://q456qq520.github.io/post/wai-guan-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/wai-guan-mo-shi/">
        </link>
        <updated>2022-02-25T07:49:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="意图">意图</h2>
<p><strong>外观模式</strong>是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。</p>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/content/facade/facade-2x.png" alt="likecat" loading="lazy"></figure>
<h2 id="问题">问题</h2>
<p>假设你必须在代码中使用某个复杂的库或框架中的众多对象。 正常情况下， 你需要负责所有对象的初始化工作、 管理其依赖关系并按正确的顺序执行方法等。</p>
<p>最终， 程序中类的业务逻辑将与第三方类的实现细节紧密耦合， 使得理解和维护代码的工作很难进行。</p>
<h2 id="解决方案">解决方案</h2>
<p>外观类为包含许多活动部件的复杂子系统提供一个简单的接口。 与直接调用子系统相比， 外观提供的功能可能比较有限， 但它却包含了客户端真正关心的功能。</p>
<p>如果你的程序需要与包含几十种功能的复杂库整合， 但只需使用其中非常少的功能， 那么使用外观模式会非常方便，</p>
<p>例如， 上传猫咪搞笑短视频到社交媒体网站的应用可能会用到专业的视频转换库， 但它只需使用一个包含 encode­(filename, format)方法 （以文件名与文件格式为参数进行编码的方法） 的类即可。 在创建这个类并将其连接到视频转换库后， 你就拥有了自己的第一个外观。</p>
<h2 id="外观模式结构">外观模式结构</h2>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/facade/structure-2x.png" alt="likecat" loading="lazy"></figure>
<ol>
<li>
<p><strong>外观 （Facade）</strong> 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。</p>
</li>
<li>
<p>创建<strong>附加外观 （Additional Facade）</strong> 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。</p>
</li>
<li>
<p><strong>复杂子系统 （Complex Subsystem）</strong> 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。</p>
<p>子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。</p>
</li>
<li>
<p><strong>客户端 （Client）</strong> 使用外观代替对子系统对象的直接调用</p>
</li>
</ol>
<h2 id="伪代码">伪代码</h2>
<p>复杂视频转换库的简单接口</p>
<p>在本例中， 外观简化了复杂视频转换框架所进行的沟通工作。</p>
<p>外观提供了仅包含一个方法的类， 可用于处理对框架中所需类的配置与以正确格式获取结果的复杂工作。</p>
<p>复杂视频转换程序库</p>
<p>VideoFile</p>
<pre><code>package com.exterior;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:03
 */
public class VideoFile {
    private String name;
    private String codecType;

    public VideoFile(String name) {
        this.name = name;
        this.codecType = name.substring(name.indexOf(&quot;.&quot;) + 1);
    }

    public String getCodecType() {
        return codecType;
    }

    public String getName() {
        return name;
    }
}

</code></pre>
<p>Codec</p>
<pre><code>package com.exterior;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:05
 */
public interface Codec {
}

</code></pre>
<p>MPEG4CompressionCodec</p>
<pre><code>package com.exterior;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:06
 */
public class MPEG4CompressionCodec implements Codec{
    public String type = &quot;mp4&quot;;
}

</code></pre>
<p>OggCompressionCodec</p>
<pre><code>package com.exterior;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:06
 */
public class OggCompressionCodec implements Codec{
    public String type = &quot;ogg&quot;;
}


</code></pre>
<p>CodecFactory</p>
<pre><code>package com.exterior;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:07
 */
public class CodecFactory {
    public static Codec extract(VideoFile file) {
        String type = file.getCodecType();
        if (type.equals(&quot;mp4&quot;)) {
            System.out.println(&quot;CodecFactory: extracting mpeg audio...&quot;);
            return new MPEG4CompressionCodec();
        }
        else {
            System.out.println(&quot;CodecFactory: extracting ogg audio...&quot;);
            return new OggCompressionCodec();
        }
    }
}


</code></pre>
<p>BitrateReader</p>
<pre><code>package com.exterior;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:08
 */
public class BitrateReader {
    public static VideoFile read(VideoFile file, Codec codec) {
        System.out.println(&quot;BitrateReader: reading file...&quot;);
        return file;
    }

    public static VideoFile convert(VideoFile buffer, Codec codec) {
        System.out.println(&quot;BitrateReader: writing file...&quot;);
        return buffer;
    }
}
   
</code></pre>
<p>AudioMixer</p>
<pre><code>package com.exterior;

import java.io.File;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:09
 */
public class AudioMixer {
    public File fix(VideoFile result){
        System.out.println(&quot;AudioMixer: fixing audio...&quot;);
        return new File(&quot;tmp&quot;);
    }
}

</code></pre>
<p>VideoConversionFacade.java: 外观提供了进行视频转换的简单接口</p>
<pre><code>package com.exterior;

import java.io.File;

/**
 * 外观提供了进行视频转换的简单接口
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:10
 */
public class VideoConversionFacade {
    public File convertVideo(String fileName, String format) {
        System.out.println(&quot;VideoConversionFacade: conversion started.&quot;);
        VideoFile file = new VideoFile(fileName);
        Codec sourceCodec = CodecFactory.extract(file);
        Codec destinationCodec;
        if (format.equals(&quot;mp4&quot;)) {
            destinationCodec = new MPEG4CompressionCodec();
        } else {
            destinationCodec = new OggCompressionCodec();
        }
        VideoFile buffer = BitrateReader.read(file, sourceCodec);
        VideoFile intermediateResult = BitrateReader.convert(buffer, destinationCodec);
        File result = (new AudioMixer()).fix(intermediateResult);
        System.out.println(&quot;VideoConversionFacade: conversion completed.&quot;);
        return result;
    }
}

</code></pre>
<p>客户端代码</p>
<pre><code>package com.exterior;

import java.io.File;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/25 16:11
 */
public class Demo {
    public static void main(String[] args) {
        VideoConversionFacade converter = new VideoConversionFacade();
        File mp4Video = converter.convertVideo(&quot;youtubevideo.ogg&quot;, &quot;mp4&quot;);
        // ...
    }
}

</code></pre>
<p>执行结果</p>
<pre><code>VideoConversionFacade: conversion started.
CodecFactory: extracting ogg audio...
BitrateReader: reading file...
BitrateReader: writing file...
AudioMixer: fixing audio...
VideoConversionFacade: conversion completed.
</code></pre>
<h2 id="外观模式适合应用场景">外观模式适合应用场景</h2>
<ol>
<li>
<p>如果你需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。<br>
子系统通常会随着时间的推进变得越来越复杂。 即便是应用了设计模式， 通常你也会创建更多的类。 尽管在多种情形中子系统可能是更灵活或易于复用的， 但其所需的配置和样板代码数量将会增长得更快。 为了解决这个问题， 外观将会提供指向子系统中最常用功能的快捷方式， 能够满足客户端的大部分需求。</p>
</li>
<li>
<p>如果需要将子系统组织为多层结构， 可以使用外观。<br>
创建外观来定义子系统中各层次的入口。 你可以要求子系统仅使用外观来进行交互， 以减少子系统之间的耦合。</p>
<p>让我们回到视频转换框架的例子。 该框架可以拆分为两个层次： 音频相关和视频相关。 你可以为每个层次创建一个外观， 然后要求各层的类必须通过这些外观进行交互。 这种方式看上去与<strong>中介者模式</strong>非常相似。</p>
</li>
</ol>
<h2 id="实现方式">实现方式</h2>
<ol>
<li>
<p>考虑能否在现有子系统的基础上提供一个更简单的接口。 如果该接口能让客户端代码独立于众多子系统类， 那么你的方向就是正确的。</p>
</li>
<li>
<p>在一个新的外观类中声明并实现该接口。 外观应将客户端代码的调用重定向到子系统中的相应对象处。 如果客户端代码没有对子系统进行初始化， 也没有对其后续生命周期进行管理， 那么外观必须完成此类工作。</p>
</li>
<li>
<p>如果要充分发挥这一模式的优势， 你必须确保所有客户端代码仅通过外观来与子系统进行交互。 此后客户端代码将不会受到任何由子系统代码修改而造成的影响， 比如子系统升级后， 你只需修改外观中的代码即可。</p>
</li>
<li>
<p>如果外观变得过于臃肿， 你可以考虑将其部分行为抽取为一个新的专用外观类。</p>
</li>
</ol>
<h2 id="责任链模式优缺点">责任链模式优缺点</h2>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>你可以让自己的代码独立于复杂子系统。。</td>
<td style="text-align:center">外观可能成为与程序中所有类都耦合的上帝对象。</td>
</tr>
</tbody>
</table>
<h2 id="与其他模式的关系">与其他模式的关系</h2>
<ol>
<li>
<p><strong>外观模式</strong>为现有对象定义了一个新接口， <strong>适配器模式</strong>则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。</p>
</li>
<li>
<p>当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用<strong>抽象工厂模式</strong>来代替外观。</p>
</li>
<li>
<p><strong>享元模式</strong>展示了如何生成大量的小型对象， 外观则展示了如何用一个对象来代表整个子系统。</p>
</li>
<li>
<p><strong>外观</strong>和<strong>中介者模式</strong>的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。</p>
<p>外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。</p>
<p>中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。</p>
</li>
<li>
<p><strong>外观类</strong>通常可以转换为<strong>单例模式类</strong>， 因为在大部分情况下一个外观对象就足够了。</p>
</li>
<li>
<p><strong>外观</strong>与<strong>代理模式</strong>的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《人人都是产品经理》]]></title>
        <id>https://q456qq520.github.io/post/lesslessren-ren-du-shi-chan-pin-jing-li-greatergreater/</id>
        <link href="https://q456qq520.github.io/post/lesslessren-ren-du-shi-chan-pin-jing-li-greatergreater/">
        </link>
        <updated>2022-02-25T06:33:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="好产品能改变世界">好产品能改变世界</h1>
<h1 id="一-什么是产品经理">一 什么是产品经理</h1>
<p>1 什么是产品</p>
<p>百度百科：<br>
产品是一组将输入转化为输出的相互关联或相互作用的活动”的结果，即“过程”的结果。在经济领域中，通常也可理解为组织制造的任何制品或制品的组合。产品的狭义概念：被生产出的物品；产品的广义概念：可以满足人们需求的载体。</p>
<p>也即：产品是用来解决某个问题的具体物质</p>
<p>2 为什么要有产品经理</p>
<p>产品经理的出现是为了适应公司发展的需要。随着企业越来越大，产品越来越多，越来越复杂，原来按职能划分部门的组织结构已经无法适应，所以出现了产品管理的矩阵型组织。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis数据类型-GEO]]></title>
        <id>https://q456qq520.github.io/post/redis-shu-ju-lei-xing-geo/</id>
        <link href="https://q456qq520.github.io/post/redis-shu-ju-lei-xing-geo/">
        </link>
        <updated>2022-02-21T09:33:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="面向lbs应用的geo数据类型">面向LBS应用的GEO数据类型</h2>
<p>在日常生活中，我们越来越依赖搜索“附近的餐馆”、在打车软件上叫车，这些都离不开基于位置信息服务（Location-Based Service，LBS）的应用。LBS应用访问的数据是和人或物关联的一组经纬度信息，而且要能查询相邻的经纬度范围，GEO就非常适合应用在LBS服务的场景中，我们来看一下它的底层结构。</p>
<h2 id="geo的底层结构">GEO的底层结构</h2>
<p>一般来说，在设计一个数据类型的底层结构时，我们首先需要知道，要处理的数据有什么访问特点。所以，我们需要先搞清楚位置信息到底是怎么被存取的。</p>
<p>我以叫车服务为例，来分析下LBS应用中经纬度的存取特点。</p>
<ol>
<li>每一辆网约车都有一个编号（例如33），网约车需要将自己的经度信息（例如116.034579）和纬度信息（例如39.000452 ）发给叫车应用。</li>
<li>用户在叫车的时候，叫车应用会根据用户的经纬度位置（例如经度116.054579，纬度39.030452），查找用户的附近车辆，并进行匹配。</li>
<li>等把位置相近的用户和车辆匹配上以后，叫车应用就会根据车辆的编号，获取车辆的信息，并返回给用户。</li>
</ol>
<p>可以看到，一辆车（或一个用户）对应一组经纬度，并且随着车（或用户）的位置移动，相应的经纬度也会变化。</p>
<p>这种数据记录模式属于一个key（例如车ID）对应一个value（一组经纬度）。当有很多车辆信息要保存时，就需要有一个集合来保存一系列的key和value。Hash集合类型可以快速存取一系列的key和value，正好可以用来记录一系列车辆ID和经纬度的对应关系，所以，我们可以把不同车辆的ID和它们对应的经纬度信息存在Hash集合中，如下图所示：</p>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/c8/0e/c8d3f1951874da0d916ed51ccdce9e0e.jpg" alt="likecat" loading="lazy"></figure>
<p>同时，Hash类型的HSET操作命令，会根据key来设置相应的value值，所以，我们可以用它来快速地更新车辆变化的经纬度信息。</p>
<p>到这里，Hash类型看起来是一个不错的选择。但问题是，对于一个LBS应用来说，除了记录经纬度信息，还需要根据用户的经纬度信息在车辆的Hash集合中进行范围查询。一旦涉及到范围查询，就意味着集合中的元素需要有序，但Hash类型的元素是无序的，显然不能满足我们的要求。</p>
<p>我们再来看看使用Sorted Set类型是不是合适。</p>
<p>Sorted Set类型也支持一个key对应一个value的记录模式，其中，key就是Sorted Set中的元素，而value则是元素的权重分数。更重要的是，Sorted Set可以根据元素的权重分数排序，支持范围查询。这就能满足LBS服务中查找相邻位置的需求了。</p>
<p>实际上，GEO类型的底层数据结构就是用Sorted Set来实现的。咱们还是借着叫车应用的例子来加深下理解。</p>
<p>用Sorted Set来保存车辆的经纬度信息时，Sorted Set的元素是车辆ID，元素的权重分数是经纬度信息，如下图所示：</p>
<figure data-type="image" tabindex="2"><img src="https://static001.geekbang.org/resource/image/a9/4e/a9a6bc78ea3bb652ef1404020dd2934e.jpg" alt="likecat" loading="lazy"></figure>
<p>这时问题来了，Sorted Set元素的权重分数是一个浮点数（float类型），而一组经纬度包含的是经度和纬度两个值，是没法直接保存为一个浮点数的，那具体该怎么进行保存呢？</p>
<p>这就要用到GEO类型中的GeoHash编码了。</p>
<h2 id="geohash的编码方法">GeoHash的编码方法</h2>
<p>为了能高效地对经纬度进行比较，Redis采用了业界广泛使用的GeoHash编码方法，这个方法的基本原理就是“<strong>二分区间，区间编码</strong>”。</p>
<p>当我们要对一组经纬度进行GeoHash编码时，我们要先对经度和纬度分别编码，然后再把经纬度各自的编码组合成一个最终编码。</p>
<p>首先，我们来看下经度和纬度的单独编码过程。</p>
<p>对于一个地理位置信息来说，它的经度范围是[-180,180]。GeoHash编码会把一个经度值编码成一个N位的二进制值，我们来对经度范围[-180,180]做N次的二分区操作，其中N可以自定义。</p>
<p>在进行第一次二分区时，经度范围[-180,180]会被分成两个子区间：[-180,0)和[0,180]（我称之为左、右分区）。此时，我们可以查看一下要编码的经度值落在了左分区还是右分区。如果是落在左分区，我们就用0表示；如果落在右分区，就用1表示。这样一来，每做完一次二分区，我们就可以得到1位编码值。</p>
<p>然后，我们再对经度值所属的分区再做一次二分区，同时再次查看经度值落在了二分区后的左分区还是右分区，按照刚才的规则再做1位编码。当做完N次的二分区后，经度值就可以用一个N bit的数来表示了。</p>
<p>举个例子，假设我们要编码的经度值是116.37，我们用5位编码值（也就是N=5，做5次分区）。</p>
<p>我们先做第一次二分区操作，把经度区间[-180,180]分成了左分区[-180,0)和右分区[0,180]，此时，经度值116.37是属于右分区[0,180]，所以，我们用1表示第一次二分区后的编码值。</p>
<p>接下来，我们做第二次二分区：把经度值116.37所属的[0,180]区间，分成[0,90)和[90, 180]。此时，经度值116.37还是属于右分区[90,180]，所以，第二次分区后的编码值仍然为1。等到第三次对[90,180]进行二分区，经度值116.37落在了分区后的左分区[90, 135)中，所以，第三次分区后的编码值就是0。</p>
<p>按照这种方法，做完5次分区后，我们把经度值116.37定位在[112.5, 123.75]这个区间，并且得到了经度值的5位编码值，即11010。这个编码过程如下表所示：</p>
<figure data-type="image" tabindex="3"><img src="https://static001.geekbang.org/resource/image/3c/f2/3cb007yy63c820d6dd2e4999608683f2.jpg" alt="likecat" loading="lazy"></figure>
<p>对纬度的编码方式，和对经度的一样，只是纬度的范围是[-90，90]，下面这张表显示了对纬度值39.86的编码过程。</p>
<figure data-type="image" tabindex="4"><img src="https://static001.geekbang.org/resource/image/65/6d/65f41469866cb94963b4c9afbf2b016d.jpg" alt="likecat" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[装饰模式]]></title>
        <id>https://q456qq520.github.io/post/zhuang-shi-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/zhuang-shi-mo-shi/">
        </link>
        <updated>2022-02-21T08:33:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="意图">意图</h2>
<p><strong>装饰模式</strong>是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</p>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/content/decorator/decorator-2x.png" alt="likecat" loading="lazy"></figure>
<h2 id="问题">问题</h2>
<p>假设你正在开发一个提供通知功能的库， 其他程序可使用它向用户发送关于重要事件的通知。</p>
<p>库的最初版本基于 通知器Notifier类， 其中只有很少的几个成员变量， 一个构造函数和一个 send发送方法。 该方法可以接收来自客户端的消息参数， 并将该消息发送给一系列的邮箱， 邮箱列表则是通过构造函数传递给通知器的。 作为客户端的第三方程序仅会创建和配置通知器对象一次， 然后在有重要事件发生时对其进行调用。</p>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/decorator/problem1-zh-2x.png" alt="likecat" title="程序可以使用通知器类向预定义的邮箱发送重要事件通知。" loading="lazy"></figure>
<!-- <div align=center>
<img width="400px" height="244px" title="韩孝周" src="https://refactoringguru.cn/images/patterns/diagrams/decorator/problem1-zh-2x.png"/>
</div> -->
<p>此后某个时刻， 你会发现库的用户希望使用除邮件通知之外的功能。 许多用户会希望接收关于紧急事件的手机短信， 还有些用户希望在微信上接收消息， 而公司用户则希望在 QQ 上接收消息。</p>
<figure data-type="image" tabindex="3"><img src="https://refactoringguru.cn/images/patterns/diagrams/decorator/problem2-zh-2x.png?id=269155b9fb40015e85ce" alt="likecat" loading="lazy"></figure>
<p>这有什么难的呢？ 首先扩展 通知器类， 然后在新的子类中加入额外的通知方法。 现在客户端要对所需通知形式的对应类进行初始化， 然后使用该类发送后续所有的通知消息。</p>
<p>但是很快有人会问： ​ “为什么不同时使用多种通知形式呢？ 如果房子着火了， 你大概会想在所有渠道中都收到相同的消息吧。”</p>
<p>你可以尝试创建一个特殊子类来将多种通知方法组合在一起以解决该问题。 但这种方式会使得代码量迅速膨胀， 不仅仅是程序库代码， 客户端代码也会如此。</p>
<figure data-type="image" tabindex="4"><img src="https://refactoringguru.cn/images/patterns/diagrams/decorator/problem3-zh-2x.png?id=4e4a0ce28a97ee56f47a" alt="likecat" loading="lazy"></figure>
<h2 id="解决方案">解决方案</h2>
<p>当你需要更改一个对象的行为时， 第一个跳入脑海的想法就是扩展它所属的类。 但是， 你不能忽视继承可能引发的几个严重问题。</p>
<p>继承是静态的。 你无法在运行时更改已有对象的行为， 只能使用由不同子类创建的对象来替代当前的整个对象。</p>
<p>子类只能有一个父类。 大部分编程语言不允许一个类同时继承多个类的行为。</p>
<p>其中一种方法是用聚合或组合 ， 而不是继承。 两者的工作方式几乎一模一样： 一个对象包含指向另一个对象的引用， 并将部分工作委派给引用对象； 继承中的对象则继承了父类的行为， 它们自己能够完成这些工作。</p>
<p>你可以使用这个新方法来轻松替换各种连接的 “小帮手” 对象， 从而能在运行时改变容器的行为。 一个对象可以使用多个类的行为， 包含多个指向其他对象的引用， 并将各种工作委派给引用对象。</p>
<p>聚合 （或组合） 组合是许多设计模式背后的关键原则 （包括装饰在内）。 记住这一点后， 让我们继续关于模式的讨论。</p>
<figure data-type="image" tabindex="5"><img src="https://refactoringguru.cn/images/patterns/diagrams/decorator/solution1-zh-2x.png?id=6e018cc1ce5d4987999f" alt="likecat" loading="lazy"></figure>
<p>封装器是装饰模式的别称， 这个称谓明确地表达了该模式的主要思想。 ​ “封装器” 是一个能与其他 “目标” 对象连接的对象。 封装器包含与目标对象相同的一系列方法， 它会将所有接收到的请求委派给目标对象。 但是， 封装器可以在将请求委派给目标前后对其进行处理， 所以可能会改变最终结果。</p>
<p>那么什么时候一个简单的封装器可以被称为是真正的装饰呢？ 正如之前提到的， 封装器实现了与其封装对象相同的接口。 因此从客户端的角度来看， 这些对象是完全一样的。 封装器中的引用成员变量可以是遵循相同接口的任意对象。 这使得你可以将一个对象放入多个封装器中， 并在对象中添加所有这些封装器的组合行为。</p>
<p>比如在消息通知示例中， 我们可以将简单邮件通知行为放在基类 通知器中， 但将所有其他通知方法放入装饰中。</p>
<figure data-type="image" tabindex="6"><img src="https://refactoringguru.cn/images/patterns/diagrams/decorator/solution2-zh-2x.png?id=2833359975d33419b2ec" alt="likecat" loading="lazy"></figure>
<p>客户端代码必须将基础通知器放入一系列自己所需的装饰中。 因此最后的对象将形成一个栈结构。</p>
<figure data-type="image" tabindex="7"><img src="https://refactoringguru.cn/images/patterns/diagrams/decorator/solution3-zh-2x.png?id=8c9f86759d233505d4be" alt="likecat" loading="lazy"></figure>
<p>实际与客户端进行交互的对象将是最后一个进入栈中的装饰对象。 由于所有的装饰都实现了与通知基类相同的接口， 客户端的其他代码并不在意自己到底是与 “纯粹” 的通知器对象， 还是与装饰后的通知器对象进行交互。</p>
<p>我们可以使用相同方法来完成其他行为 （例如设置消息格式或者创建接收人列表）。 只要所有装饰都遵循相同的接口， 客户端就可以使用任意自定义的装饰来装饰对象。</p>
<h2 id="装饰模式结构">装饰模式结构</h2>
<figure data-type="image" tabindex="8"><img src="https://refactoringguru.cn/images/patterns/diagrams/decorator/structure-2x.png?id=3cfa1f10417a4ef0c125" alt="likecat" loading="lazy"></figure>
<ol>
<li><strong>部件 （Component））</strong>  声明封装器和被封装对象的公用接口。</li>
<li><strong>具体部件 （Concrete Component））</strong>  类是被封装对象所属的类。 它定义了基础行为， 但装饰类可以改变这些行为。</li>
<li>**基础装饰 （Base Decorator） ** 类拥有一个指向被封装对象的引用成员变量。 该变量的类型应当被声明为通用部件接口， 这样它就可以引用具体的部件和装饰。 装饰基类会将所有操作委派给被封装的对象。</li>
<li><strong>具体装饰类 （Concrete Decorators）</strong> 定义了可动态添加到部件的额外行为。 具体装饰类会重写装饰基类的方法， 并在调用父类方法之前或之后进行额外的行为。</li>
<li>**客户端 （Client） ** 可以使用多层装饰来封装部件， 只要它能使用通用接口与所有对象互动即可。</li>
</ol>
<h2 id="伪代码">伪代码</h2>
<p>编码和压缩装饰</p>
<p>本例展示了如何在不更改对象代码的情况下调整其行为。</p>
<p>最初的业务逻辑类仅能读取和写入纯文本的数据。 此后， 我们创建了几个小的封装器类， 以便在执行标准操作后添加新的行为。</p>
<p>第一个封装器负责加密和解密数据， 而第二个则负责压缩和解压数据。</p>
<p>你甚至可以让这些封装器嵌套封装以将它们组合起来。</p>
<p>定义了读取和写入操作的通用数据接口</p>
<pre><code>package decorator;

/**
 * 定义了读取和写入操作的通用数据接口
 * @author likecat
 * @version 1.0
 * @date 2022/2/21 17:19
 */
public interface DataSource {
    void writeData(String data);

    String readData();
}

</code></pre>
<p>简单数据读写器</p>
<pre><code>package decorator;

import java.io.*;

/**
 * 简单数据读写器
 * @author likecat
 * @version 1.0
 * @date 2022/2/21 17:20
 */
public class FileDataSource implements DataSource{
    private String name;

    public FileDataSource(String name) {
        this.name = name;
    }

    @Override
    public void writeData(String data) {
        File file = new File(name);
        try (OutputStream fos = new FileOutputStream(file)) {
            fos.write(data.getBytes(), 0, data.length());
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }

    @Override
    public String readData() {
        char[] buffer = null;
        File file = new File(name);
        try (FileReader reader = new FileReader(file)) {
            buffer = new char[(int) file.length()];
            reader.read(buffer);
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
        return new String(buffer);
    }
}

</code></pre>
<p>抽象基础装饰</p>
<pre><code>package decorator;

/**
 * 抽象基础装饰
 * @author likecat
 * @version 1.0
 * @date 2022/2/21 17:22
 */
public class DataSourceDecorator implements DataSource{
    private DataSource wrappee;

    DataSourceDecorator(DataSource source) {
        this.wrappee = source;
    }

    @Override
    public void writeData(String data) {
        wrappee.writeData(data);
    }

    @Override
    public String readData() {
        return wrappee.readData();
    }
}


</code></pre>
<p>加密装饰</p>
<pre><code>package decorator;

import java.util.Base64;

/**
 * 加密装饰
 * @author likecat
 * @version 1.0
 * @date 2022/2/21 17:23
 */
public class EncryptionDecorator extends DataSourceDecorator {

    public EncryptionDecorator(DataSource source) {
        super(source);
    }

    @Override
    public void writeData(String data) {
        super.writeData(encode(data));
    }

    @Override
    public String readData() {
        return decode(super.readData());
    }

    private String encode(String data) {
        byte[] result = data.getBytes();
        for (int i = 0; i &lt; result.length; i++) {
            result[i] += (byte) 1;
        }
        return Base64.getEncoder().encodeToString(result);
    }

    private String decode(String data) {
        byte[] result = Base64.getDecoder().decode(data);
        for (int i = 0; i &lt; result.length; i++) {
            result[i] -= (byte) 1;
        }
        return new String(result);
    }
}

</code></pre>
<p>压缩装饰</p>
<pre><code>package decorator;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Base64;
import java.util.zip.Deflater;
import java.util.zip.DeflaterOutputStream;
import java.util.zip.InflaterInputStream;

/**
 * 压缩装饰
 * @author likecat
 * @version 1.0
 * @date 2022/2/21 17:24
 */
public class CompressionDecorator extends DataSourceDecorator {
    private int compLevel = 6;

    public CompressionDecorator(DataSource source) {
        super(source);
    }

    public int getCompressionLevel() {
        return compLevel;
    }

    public void setCompressionLevel(int value) {
        compLevel = value;
    }

    @Override
    public void writeData(String data) {
        super.writeData(compress(data));
    }

    @Override
    public String readData() {
        return decompress(super.readData());
    }

    private String compress(String stringData) {
        byte[] data = stringData.getBytes();
        try {
            ByteArrayOutputStream bout = new ByteArrayOutputStream(512);
            DeflaterOutputStream dos = new DeflaterOutputStream(bout, new Deflater(compLevel));
            dos.write(data);
            dos.close();
            bout.close();
            return Base64.getEncoder().encodeToString(bout.toByteArray());
        } catch (IOException ex) {
            return null;
        }
    }

    private String decompress(String stringData) {
        byte[] data = Base64.getDecoder().decode(stringData);
        try {
            InputStream in = new ByteArrayInputStream(data);
            InflaterInputStream iin = new InflaterInputStream(in);
            ByteArrayOutputStream bout = new ByteArrayOutputStream(512);
            int b;
            while ((b = iin.read()) != -1) {
                bout.write(b);
            }
            in.close();
            iin.close();
            bout.close();
            return new String(bout.toByteArray());
        } catch (IOException ex) {
            return null;
        }
    }
}

</code></pre>
<p>客户端代码</p>
<pre><code>package decorator;

/**
 * @author likecat
 * @version 1.0
 * @date 2022/2/21 17:26
 */
public class Demo {
    public static void main(String[] args) {
        String salaryRecords = &quot;Name,Salary\nJohn Smith,100000\nSteven Jobs,912000&quot;;
        DataSourceDecorator encoded = new CompressionDecorator(
                new EncryptionDecorator(
                        new FileDataSource(&quot;out/OutputDemo.txt&quot;)));
        encoded.writeData(salaryRecords);
        DataSource plain = new FileDataSource(&quot;out/OutputDemo.txt&quot;);

        System.out.println(&quot;- Input ----------------&quot;);
        System.out.println(salaryRecords);
        System.out.println(&quot;- Encoded --------------&quot;);
        System.out.println(plain.readData());
        System.out.println(&quot;- Decoded --------------&quot;);
        System.out.println(encoded.readData());
    }
}

        
</code></pre>
<p>执行结果</p>
<pre><code>- Input ----------------
Name,Salary
John Smith,100000
Steven Jobs,912000
- Encoded --------------
Zkt7e1Q5eU8yUm1Qe0ZsdHJ2VXp6dDBKVnhrUHtUe0sxRUYxQkJIdjVLTVZ0dVI5Q2IwOXFISmVUMU5rcENCQmdxRlByaD4+
- Decoded --------------
Name,Salary
John Smith,100000
Steven Jobs,912000
</code></pre>
<h2 id="装饰模式适合应用场景">装饰模式适合应用场景</h2>
<ol>
<li>
<p>如果你希望在无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式。<br>
装饰能将业务逻辑组织为层次结构， 你可为各层创建一个装饰， 在运行时将各种不同逻辑组合成对象。 由于这些对象都遵循通用接口， 客户端代码能以相同的方式使用这些对象。</p>
</li>
<li>
<p>如果用继承来扩展对象行为的方案难以实现或者根本不可行， 你可以使用该模式。<br>
许多编程语言使用 final最终关键字来限制对某个类的进一步扩展。 复用最终类已有行为的唯一方法是使用装饰模式： 用封装器对其进行封装。</p>
</li>
</ol>
<h2 id="实现方式">实现方式</h2>
<ol>
<li>
<p>确保业务逻辑可用一个基本组件及多个额外可选层次表示。</p>
</li>
<li>
<p>找出基本组件和可选层次的通用方法。 创建一个组件接口并在其中声明这些方法。</p>
</li>
<li>
<p>创建一个具体组件类， 并定义其基础行为。</p>
</li>
<li>
<p>创建装饰基类， 使用一个成员变量存储指向被封装对象的引用。 该成员变量必须被声明为组件接口类型， 从而能在运行时连接具体组件和装饰。 装饰基类必须将所有工作委派给被封装的对象。</p>
</li>
<li>
<p>确保所有类实现组件接口。</p>
</li>
<li>
<p>将装饰基类扩展为具体装饰。 具体装饰必须在调用父类方法 （总是委派给被封装对象） 之前或之后执行自身的行为。</p>
</li>
<li>
<p>客户端代码负责创建装饰并将其组合成客户端所需的形式。</p>
</li>
</ol>
<h2 id="责任链模式优缺点">责任链模式优缺点</h2>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>你无需创建新子类即可扩展对象的行为。</td>
<td style="text-align:center">在封装器栈中删除特定封装器比较困难。</td>
</tr>
<tr>
<td>你可以在运行时添加或删除对象的功能。</td>
<td style="text-align:center">实现行为不受装饰栈顺序影响的装饰比较困难。</td>
</tr>
<tr>
<td>你可以用多个装饰封装对象来组合几种行为。</td>
<td style="text-align:center">各层的初始化配置代码看上去可能会很糟糕。</td>
</tr>
<tr>
<td>单一职责原则。 你可以将实现了许多不同行为的一个大类拆分为多个较小的类。</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h2 id="与其他模式的关系">与其他模式的关系</h2>
<ol>
<li>
<p><strong>适配器模式</strong>可以对已有对象的接口进行修改， <strong>装饰模式</strong>则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。</p>
</li>
<li>
<p><strong>适配器</strong>能为被封装对象提供不同的接口， <strong>代理模式</strong>能为对象提供相同的接口， <strong>装饰</strong>则能为对象提供加强的接口。</p>
</li>
<li>
<p><strong>责任链模式</strong>和<strong>装饰模式</strong>的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。</p>
<p><strong>责任链</strong>的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。</p>
</li>
<li>
<p><strong>组合模式</strong>和<strong>装饰</strong>的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。</p>
<p>装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。</p>
<p>但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。</p>
</li>
<li>
<p>大量使用<strong>组合</strong>和<strong>装饰</strong>的设计通常可从对于<strong>原型模式</strong>的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</p>
</li>
<li>
<p><strong>装饰</strong>可让你更改对象的外表， <strong>策略模式</strong>则让你能够改变其本质。</p>
</li>
<li>
<p><strong>装饰</strong>和<strong>代理</strong>有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[责任链模式]]></title>
        <id>https://q456qq520.github.io/post/ze-ren-lian-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/ze-ren-lian-mo-shi/">
        </link>
        <updated>2022-01-14T07:28:33.000Z</updated>
        <content type="html"><![CDATA[<h2 id="意图">意图</h2>
<p><strong>责任链模式</strong>是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。</p>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/content/chain-of-responsibility/chain-of-responsibility-2x.png" alt="likecat" loading="lazy"></figure>
<h2 id="问题">问题</h2>
<p>假如你正在开发一个在线订购系统。 你希望对系统访问进行限制， 只允许认证用户创建订单。 此外， 拥有管理权限的用户也拥有所有订单的完全访问权限。</p>
<p>简单规划后， 你会意识到这些检查必须依次进行。 只要接收到包含用户凭据的请求， 应用程序就可尝试对进入系统的用户进行认证。 但如果由于用户凭据不正确而导致认证失败， 那就没有必要进行后续检查了。</p>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/chain-of-responsibility/problem1-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>请求必须经过一系列检查后才能由订购系统来处理。</p>
<p>在接下来的几个月里， 你实现了后续的几个检查步骤。</p>
<ul>
<li>一位同事认为直接将原始数据传递给订购系统存在安全隐患。 因此你新增了额外的验证步骤来清理请求中的数据。</li>
<li>过了一段时间， 有人注意到系统无法抵御暴力密码破解方式的攻击。 为了防范这种情况， 你立刻添加了一个检查步骤来过滤来自同一 IP 地址的重复错误请求。</li>
<li>又有人提议你可以对包含同样数据的重复请求返回缓存中的结果， 从而提高系统响应速度。 因此， 你新增了一个检查步骤， 确保只有没有满足条件的缓存结果时请求才能通过并被发送给系统。</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://refactoringguru.cn/images/patterns/diagrams/chain-of-responsibility/problem2-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>代码变得越来越多， 也越来越混乱。</p>
<p>检查代码本来就已经混乱不堪， 而每次新增功能都会使其更加臃肿。 修改某个检查步骤有时会影响其他的检查步骤。 最糟糕的是， 当你希望复用这些检查步骤来保护其他系统组件时， 你只能复制部分代码， 因为这些组件只需部分而非全部的检查步骤。</p>
<p>系统会变得让人非常费解， 而且其维护成本也会激增。 你在艰难地和这些代码共处一段时间后， 有一天终于决定对整个系统进行重构。</p>
<h2 id="解决方案">解决方案</h2>
<p>与许多其他行为设计模式一样， 责任链会将特定行为转换为被称作处理者的独立对象。 在上述示例中， 每个检查步骤都可被抽取为仅有单个方法的类， 并执行检查操作。 请求及其数据则会被作为参数传递给该方法。</p>
<p>模式建议你将这些处理者连成一条链。 链上的每个处理者都有一个成员变量来保存对于下一处理者的引用。 除了处理请求外， 处理者还负责沿着链传递请求。 请求会在链上移动， 直至所有处理者都有机会对其进行处理。</p>
<p>最重要的是： 处理者可以决定不再沿着链传递请求， 这可高效地取消所有后续处理步骤。</p>
<p>在我们的订购系统示例中， 处理者会在进行请求处理工作后决定是否继续沿着链传递请求。 如果请求中包含正确的数据， 所有处理者都将执行自己的主要行为， 无论该行为是身份验证还是数据缓存。</p>
<figure data-type="image" tabindex="4"><img src="https://refactoringguru.cn/images/patterns/diagrams/chain-of-responsibility/solution1-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>处理者依次排列， 组成一条链。</p>
<p>不过还有一种稍微不同的方式 （也是更经典一种）， 那就是处理者接收到请求后自行决定是否能够对其进行处理。 如果自己能够处理， 处理者就不再继续传递请求。 因此在这种情况下， 每个请求要么最多有一个处理者对其进行处理， 要么没有任何处理者对其进行处理。 在处理图形用户界面元素栈中的事件时， 这种方式非常常见。</p>
<p>例如， 当用户点击按钮时， 按钮产生的事件将沿着 GUI 元素链进行传递， 最开始是按钮的容器 （如窗体或面板）， 直至应用程序主窗口。 链上第一个能处理该事件的元素会对其进行处理。 此外， 该例还有另一个值得我们关注的地方： 它表明我们总能从对象树中抽取出链来。</p>
<figure data-type="image" tabindex="5"><img src="https://refactoringguru.cn/images/patterns/diagrams/chain-of-responsibility/solution2-zh-2x.png" alt="likecat" loading="lazy"></figure>
<p>所有处理者类均实现同一接口是关键所在。 每个具体处理者仅关心下一个包含 execute执行方法的处理者。 这样一来， 你就可以在运行时使用不同的处理者来创建链， 而无需将相关代码与处理者的具体类进行耦合。</p>
<h2 id="责任链模式结构">责任链模式结构</h2>
<figure data-type="image" tabindex="6"><img src="https://refactoringguru.cn/images/patterns/diagrams/chain-of-responsibility/structure-2x.png" alt="likecat" loading="lazy"></figure>
<ol>
<li>
<p><strong>处理者 （Handler）</strong> 声明了所有具体处理者的通用接口。 该接口通常仅包含单个方法用于请求处理， 但有时其还会包含一个设置链上下个处理者的方法。</p>
</li>
<li>
<p><strong>基础处理者 （Base Handler）</strong> 是一个可选的类， 你可以将所有处理者共用的样本代码放置在其中。</p>
<p>通常情况下， 该类中定义了一个保存对于下个处理者引用的成员变量。 客户端可通过将处理者传递给上个处理者的构造函数或设定方法来创建链。 该类还可以实现默认的处理行为： 确定下个处理者存在后再将请求传递给它。</p>
</li>
<li>
<p><strong>具体处理者 （Concrete Handlers）</strong> 包含处理请求的实际代码。 每个处理者接收到请求后， 都必须决定是否进行处理， 以及是否沿着链传递请求。</p>
</li>
</ol>
<p>处理者通常是独立且不可变的， 需要通过构造函数一次性地获得所有必要地数据。</p>
<ol start="4">
<li><strong>客户端 （Client）</strong> 可根据程序逻辑一次性或者动态地生成链。 值得注意的是， 请求可发送给链上的任意一个处理者， 而非必须是第一个处理者。</li>
</ol>
<h2 id="伪代码">伪代码</h2>
<p>在本例中， 责任链模式负责为活动的 GUI 元素显示上下文帮助信息。<br>
<img src="https://refactoringguru.cn/images/patterns/diagrams/chain-of-responsibility/example-zh-2x.png" alt="likecat" loading="lazy"></p>
<p>GUI 类使用组合模式生成。 每个元素都链接到自己的容器元素。 你可随时构建从当前元素开始的、 遍历其所有容器的元素链。</p>
<p>使用案例之一是在 GUI 类中将事件向上传递给父组件。 另一个值得注意的使用案例是依次访问过滤器。</p>
<p>基础验证接口</p>
<pre><code>package com.middleware;

/**
 * 基础验证接口
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 16:13
 */
public abstract class Middleware {

    private Middleware next;

    /**
     * Builds chains of middleware objects.
     */
    public Middleware linkWith(Middleware next) {
        this.next = next;
        return next;
    }

    /**
     * Subclasses will implement this method with concrete checks.
     */
    public abstract boolean check(String email, String password);

    /**
     * Runs check on the next object in chain or ends traversing if we're in
     * last object in chain.
     */
    protected boolean checkNext(String email, String password) {
        if (next == null) {
            return true;
        }
        return next.check(email, password);
    }
}

</code></pre>
<p>检查请求数量限制</p>
<pre><code>package com.middleware;

/**
 * 检查请求数量限制
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 16:14
 */
public class ThrottlingMiddleware extends Middleware{
    private int requestPerMinute;
    private int request;
    private long currentTime;

    public ThrottlingMiddleware(int requestPerMinute) {
        this.requestPerMinute = requestPerMinute;
        this.currentTime = System.currentTimeMillis();
    }

    /**
     * Please, not that checkNext() call can be inserted both in the beginning
     * of this method and in the end.
     *
     * This gives much more flexibility than a simple loop over all middleware
     * objects. For instance, an element of a chain can change the order of
     * checks by running its check after all other checks.
     */
    public boolean check(String email, String password) {
        if (System.currentTimeMillis() &gt; currentTime + 60_000) {
            request = 0;
            currentTime = System.currentTimeMillis();
        }

        request++;

        if (request &gt; requestPerMinute) {
            System.out.println(&quot;Request limit exceeded!&quot;);
            Thread.currentThread().stop();
        }
        return checkNext(email, password);
    }
}

</code></pre>
<p>检查用户登录信息</p>
<pre><code>package com.middleware;


/**
 * 检查用户登录信息
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 16:15
 */
public class UserExistsMiddleware extends Middleware {
    private Server server;

    public UserExistsMiddleware(Server server) {
        this.server = server;
    }

    public boolean check(String email, String password) {
        if (!server.hasEmail(email)) {
            System.out.println(&quot;This email is not registered!&quot;);
            return false;
        }
        if (!server.isValidPassword(email, password)) {
            System.out.println(&quot;Wrong password!&quot;);
            return false;
        }
        return checkNext(email, password);
    }
}
</code></pre>
<p>检查用户角色</p>
<pre><code>package com.middleware;

/**
 * 检查用户角色
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 16:17
 */
public class RoleCheckMiddleware extends Middleware {
    public boolean check(String email, String password) {
        if (email.equals(&quot;admin@example.com&quot;)) {
            System.out.println(&quot;Hello, admin!&quot;);
            return true;
        }
        System.out.println(&quot;Hello, user!&quot;);
        return checkNext(email, password);
    }
}
</code></pre>
<p>授权目标</p>
<pre><code>package com.middleware;

import java.util.HashMap;
import java.util.Map;

/**
 * 授权目标
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 16:16
 */
public class Server {
    private Map&lt;String, String&gt; users = new HashMap&lt;&gt;();
    private Middleware middleware;

    /**
     * Client passes a chain of object to server. This improves flexibility and
     * makes testing the server class easier.
     */
    public void setMiddleware(Middleware middleware) {
        this.middleware = middleware;
    }

    /**
     * Server gets email and password from client and sends the authorization
     * request to the chain.
     */
    public boolean logIn(String email, String password) {
        if (middleware.check(email, password)) {
            System.out.println(&quot;Authorization have been successful!&quot;);

            // Do something useful here for authorized users.

            return true;
        }
        return false;
    }

    public void register(String email, String password) {
        users.put(email, password);
    }

    public boolean hasEmail(String email) {
        return users.containsKey(email);
    }

    public boolean isValidPassword(String email, String password) {
        return users.get(email).equals(password);
    }
}

</code></pre>
<p>客户端代码</p>
<pre><code>package com.middleware;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * 客户端代码
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 16:17
 */
public class Demo {
    private static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    private static Server server;

    private static void init() {
        server = new Server();
        server.register(&quot;admin@example.com&quot;, &quot;admin_pass&quot;);
        server.register(&quot;user@example.com&quot;, &quot;user_pass&quot;);

        // All checks are linked. Client can build various chains using the same
        // components.
        Middleware middleware = new ThrottlingMiddleware(2);
        middleware.linkWith(new UserExistsMiddleware(server))
                .linkWith(new RoleCheckMiddleware());

        // Server gets a chain from client code.
        server.setMiddleware(middleware);
    }

    public static void main(String[] args) throws IOException {
        init();

        boolean success;
        do {
            System.out.print(&quot;Enter email: &quot;);
            String email = reader.readLine();
            System.out.print(&quot;Input password: &quot;);
            String password = reader.readLine();
            success = server.logIn(email, password);
        } while (!success);
    }
}

</code></pre>
<p>执行结果</p>
<pre><code>Enter email: admin@example.com
Input password: admin_pass
Hello, admin!
Authorization have been successful!


Enter email: user@example.com
Input password: user_pass
Hello, user!
Authorization have been successful!
</code></pre>
<h2 id="责任链模式适合应用场景">责任链模式适合应用场景</h2>
<ol>
<li>
<p>当程序需要使用不同方式处理不同种类请求， 而且请求类型和顺序预先未知时， 可以使用责任链模式。<br>
该模式能将多个处理者连接成一条链。 接收到请求后， 它会 “询问” 每个处理者是否能够对其进行处理。 这样所有处理者都有机会来处理请求。</p>
</li>
<li>
<p>当必须按顺序执行多个处理者时， 可以使用该模式。<br>
无论你以何种顺序将处理者连接成一条链， 所有请求都会严格按照顺序通过链上的处理者。</p>
</li>
<li>
<p>如果所需处理者及其顺序必须在运行时进行改变， 可以使用责任链模式。<br>
如果在处理者类中有对引用成员变量的设定方法， 你将能动态地插入和移除处理者， 或者改变其顺序。</p>
</li>
</ol>
<h2 id="实现方式">实现方式</h2>
<ol>
<li>
<p>声明处理者接口并描述请求处理方法的签名。</p>
<p>确定客户端如何将请求数据传递给方法。 最灵活的方式是将请求转换为对象， 然后将其以参数的形式传递给处理函数。</p>
</li>
<li>
<p>为了在具体处理者中消除重复的样本代码， 你可以根据处理者接口创建抽象处理者基类。</p>
<p>该类需要有一个成员变量来存储指向链上下个处理者的引用。 你可以将其设置为不可变类。 但如果你打算在运行时对链进行改变， 则需要定义一个设定方法来修改引用成员变量的值。</p>
<p>为了使用方便， 你还可以实现处理方法的默认行为。 如果还有剩余对象， 该方法会将请求传递给下个对象。 具体处理者还能够通过调用父对象的方法来使用这一行为。</p>
</li>
<li>
<p>依次创建具体处理者子类并实现其处理方法。 每个处理者在接收到请求后都必须做出两个决定：</p>
<p>是否自行处理这个请求。</p>
<p>是否将该请求沿着链进行传递。</p>
</li>
<li>
<p>客户端可以自行组装链， 或者从其他对象处获得预先组装好的链。 在后一种情况下， 你必须实现工厂类以根据配置或环境设置来创建链。</p>
</li>
<li>
<p>客户端可以触发链中的任意处理者， 而不仅仅是第一个。 请求将通过链进行传递， 直至某个处理者拒绝继续传递， 或者请求到达链尾。</p>
</li>
<li>
<p>由于链的动态性， 客户端需要准备好处理以下情况：</p>
<p>链中可能只有单个链接。</p>
<p>部分请求可能无法到达链尾。</p>
<p>其他请求可能直到链尾都未被处理。</p>
</li>
</ol>
<h2 id="责任链模式优缺点">责任链模式优缺点</h2>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>你可以控制请求处理的顺序。</td>
<td style="text-align:center">部分请求可能未被处理。</td>
</tr>
<tr>
<td>单一职责原则。 你可对发起操作和执行操作的类进行解耦。</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>开闭原则。 你可以在不更改现有代码的情况下在程序中新增处理者。</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h2 id="与其他模式的关系">与其他模式的关系</h2>
<ol>
<li>
<p><strong>责任链模式</strong>、<strong>命令模式</strong>、 <strong>中介者模式</strong>和<strong>观察者模式</strong>用于处理请求发送者和接收者之间的不同连接方式：</p>
<ul>
<li>责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。</li>
<li>命令在发送者和请求者之间建立单向连接。</li>
<li>中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。</li>
<li>观察者允许接收者动态地订阅或取消接收请求。</li>
</ul>
</li>
<li>
<p><strong>责任链</strong>通常和<strong>组合模式</strong>结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。</p>
</li>
<li>
<p><strong>责任链</strong>的管理者可使用命令模式实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。</p>
<p>还有另外一种实现方式， 那就是请求自身就是一个命令对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。</p>
</li>
<li>
<p><strong>责任链</strong>和<strong>装饰模式</strong>的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。</p>
<p><strong>责任链</strong>的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[组合模式]]></title>
        <id>https://q456qq520.github.io/post/zu-he-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/zu-he-mo-shi/">
        </link>
        <updated>2022-01-12T08:22:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="意图">意图</h2>
<p><strong>组合模式</strong>是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。</p>
<h2 id="问题">问题</h2>
<p>如果应用的核心模型能用树状结构表示， 在应用中使用组合模式才有价值。</p>
<p>例如， 你有两类对象： ​ 产品和 盒子 。 一个盒子中可以包含多个 产品或者几个较小的 盒子 。 这些小 盒子中同样可以包含一些 产品或更小的 盒子 ， 以此类推。</p>
<p>假设你希望在这些类的基础上开发一个定购系统。 订单中可以包含无包装的简单产品， 也可以包含装满产品的盒子……以及其他盒子。 此时你会如何计算每张订单的总价格呢？</p>
<p><img src="https://refactoringguru.cn/images/patterns/diagrams/composite/problem-zh-2x.png" alt="likecat" loading="lazy"><br>
订单中可能包括各种产品， 这些产品放置在盒子中， 然后又被放入一层又一层更大的盒子中。 整个结构看上去像是一棵倒过来的树。</p>
<p>你可以尝试直接计算： 打开所有盒子， 找到每件产品， 然后计算总价。 这在真实世界中或许可行， 但在程序中， 你并不能简单地使用循环语句来完成该工作。 你必须事先知道所有 产品和 盒子的类别， 所有盒子的嵌套层数以及其他繁杂的细节信息。 因此， 直接计算极不方便， 甚至完全不可行。</p>
<h2 id="解决方案">解决方案</h2>
<p>组合模式建议使用一个通用接口来与 产品和 盒子进行交互， 并且在该接口中声明一个计算总价的方法。</p>
<p>那么方法该如何设计呢？ 对于一个产品， 该方法直接返回其价格； 对于一个盒子， 该方法遍历盒子中的所有项目， 询问每个项目的价格， 然后返回该盒子的总价格。 如果其中某个项目是小一号的盒子， 那么当前盒子也会遍历其中的所有项目， 以此类推， 直到计算出所有内部组成部分的价格。 你甚至可以在盒子的最终价格中增加额外费用， 作为该盒子的包装费用。</p>
<p><img src="https://refactoringguru.cn/images/patterns/content/composite/composite-comic-1-zh-2x.png" alt="likecat" loading="lazy"><br>
组合模式以递归方式处理对象树中的所有项目</p>
<p>该方式的最大优点在于你无需了解构成树状结构的对象的具体类。 你也无需了解对象是简单的产品还是复杂的盒子。 你只需调用通用接口以相同的方式对其进行处理即可。 当你调用该方法后， 对象会将请求沿着树结构传递下去。</p>
<h2 id="组合模式结构">组合模式结构</h2>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/diagrams/composite/structure-zh-2x.png" alt="likecat" loading="lazy"></figure>
<ol>
<li><strong>组件 （Component）</strong> 接口描述了树中简单项目和复杂项目所共有的操作。</li>
<li><strong>叶节点 （Leaf）</strong> 是树的基本结构， 它不包含子项目。<br>
一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。</li>
<li><strong>容器 （Container）</strong>——又名 “<strong>组合 （Composite）</strong>”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。<br>
容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。</li>
<li><strong>客户端 （Client）</strong> 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。</li>
</ol>
<h2 id="伪代码">伪代码</h2>
<p>简单和复合图形</p>
<p>本例展示了如何利用较为简单的形状来组成复杂图形， 以及如何统一处理简单和复杂图形。</p>
<ol>
<li>通用形状接口</li>
</ol>
<pre><code>package com.composite;

import java.awt.*;

/**
 * 通用形状接口
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 09:26
 */
public interface Shape {
    int getX();
    int getY();
    int getWidth();
    int getHeight();
    void move(int x, int y);
    boolean isInsideBounds(int x, int y);
    void select();
    void unSelect();
    boolean isSelected();
    void paint(Graphics graphics);
}

</code></pre>
<ol start="2">
<li>提供基本功能的抽象形状</li>
</ol>
<pre><code>package com.composite;

import java.awt.*;

/**
 * 提供基本功能的抽象形状
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 10:48
 */
abstract class BaseShape implements Shape{
    public int x;
    public int y;
    public Color color;
    private boolean selected = false;

    BaseShape(int x, int y, Color color) {
        this.x = x;
        this.y = y;
        this.color = color;
    }

    @Override
    public int getX() {
        return x;
    }

    @Override
    public int getY() {
        return y;
    }

    @Override
    public int getWidth() {
        return 0;
    }

    @Override
    public int getHeight() {
        return 0;
    }

    @Override
    public void move(int x, int y) {
        this.x += x;
        this.y += y;
    }

    @Override
    public boolean isInsideBounds(int x, int y) {
        return x &gt; getX() &amp;&amp; x &lt; (getX() + getWidth()) &amp;&amp;
                y &gt; getY() &amp;&amp; y &lt; (getY() + getHeight());
    }

    @Override
    public void select() {
        selected = true;
    }

    @Override
    public void unSelect() {
        selected = false;
    }

    @Override
    public boolean isSelected() {
        return selected;
    }

    void enableSelectionStyle(Graphics graphics) {
        graphics.setColor(Color.LIGHT_GRAY);

        Graphics2D g2 = (Graphics2D) graphics;
        float dash1[] = {2.0f};
        g2.setStroke(new BasicStroke(1.0f,
                BasicStroke.CAP_BUTT,
                BasicStroke.JOIN_MITER,
                2.0f, dash1, 0.0f));
    }

    void disableSelectionStyle(Graphics graphics) {
        graphics.setColor(color);
        Graphics2D g2 = (Graphics2D) graphics;
        g2.setStroke(new BasicStroke());
    }


    @Override
    public void paint(Graphics graphics) {
        if (isSelected()) {
            enableSelectionStyle(graphics);
        }
        else {
            disableSelectionStyle(graphics);
        }

        // ...
    }
}

</code></pre>
<ol start="3">
<li>点</li>
</ol>
<pre><code>package com.composite;

import java.awt.*;

/**
 * 点
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 10:49
 */
public class Dot extends BaseShape {
    private final int DOT_SIZE = 3;

    public Dot(int x, int y, Color color) {
        super(x, y, color);
    }

    @Override
    public int getWidth() {
        return DOT_SIZE;
    }

    @Override
    public int getHeight() {
        return DOT_SIZE;
    }

    @Override
    public void paint(Graphics graphics) {
        super.paint(graphics);
        graphics.fillRect(x - 1, y - 1, getWidth(), getHeight());
    }
}

</code></pre>
<ol start="4">
<li>圆</li>
</ol>
<pre><code>package com.composite;

import java.awt.*;

/**
 * 圆
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 10:50
 */
public class Circle extends BaseShape{
    public int radius;

    public Circle(int x, int y, int radius, Color color) {
        super(x, y, color);
        this.radius = radius;
    }

    @Override
    public int getWidth() {
        return radius * 2;
    }

    @Override
    public int getHeight() {
        return radius * 2;
    }

    public void paint(Graphics graphics) {
        super.paint(graphics);
        graphics.drawOval(x, y, getWidth() - 1, getHeight() - 1);
    }
}

</code></pre>
<ol start="5">
<li>三角形</li>
</ol>
<pre><code>package com.composite;

import java.awt.*;

/**
 * 三角形
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 10:50
 */
public class Rectangle extends BaseShape{
    public int width;
    public int height;

    public Rectangle(int x, int y, int width, int height, Color color) {
        super(x, y, color);
        this.width = width;
        this.height = height;
    }

    @Override
    public int getWidth() {
        return width;
    }

    @Override
    public int getHeight() {
        return height;
    }

    @Override
    public void paint(Graphics graphics) {
        super.paint(graphics);
        graphics.drawRect(x, y, getWidth() - 1, getHeight() - 1);
    }
}

</code></pre>
<ol start="6">
<li>由其他形状对象组成的复合形状</li>
</ol>
<pre><code>package com.composite;

import java.awt.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * 由其他形状对象组成的复合形状
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 10:51
 */
public class CompoundShape extends BaseShape{
    protected List&lt;Shape&gt; children = new ArrayList&lt;&gt;();

    public CompoundShape(Shape... components) {
        super(0, 0, Color.BLACK);
        add(components);
    }

    public void add(Shape component) {
        children.add(component);
    }

    public void add(Shape... components) {
        children.addAll(Arrays.asList(components));
    }

    public void remove(Shape child) {
        children.remove(child);
    }

    public void remove(Shape... components) {
        children.removeAll(Arrays.asList(components));
    }

    public void clear() {
        children.clear();
    }

    @Override
    public int getX() {
        if (children.size() == 0) {
            return 0;
        }
        int x = children.get(0).getX();
        for (Shape child : children) {
            if (child.getX() &lt; x) {
                x = child.getX();
            }
        }
        return x;
    }

    @Override
    public int getY() {
        if (children.size() == 0) {
            return 0;
        }
        int y = children.get(0).getY();
        for (Shape child : children) {
            if (child.getY() &lt; y) {
                y = child.getY();
            }
        }
        return y;
    }

    @Override
    public int getWidth() {
        int maxWidth = 0;
        int x = getX();
        for (Shape child : children) {
            int childsRelativeX = child.getX() - x;
            int childWidth = childsRelativeX + child.getWidth();
            if (childWidth &gt; maxWidth) {
                maxWidth = childWidth;
            }
        }
        return maxWidth;
    }

    @Override
    public int getHeight() {
        int maxHeight = 0;
        int y = getY();
        for (Shape child : children) {
            int childsRelativeY = child.getY() - y;
            int childHeight = childsRelativeY + child.getHeight();
            if (childHeight &gt; maxHeight) {
                maxHeight = childHeight;
            }
        }
        return maxHeight;
    }

    @Override
    public void move(int x, int y) {
        for (Shape child : children) {
            child.move(x, y);
        }
    }

    @Override
    public boolean isInsideBounds(int x, int y) {
        for (Shape child : children) {
            if (child.isInsideBounds(x, y)) {
                return true;
            }
        }
        return false;
    }

    @Override
    public void unSelect() {
        super.unSelect();
        for (Shape child : children) {
            child.unSelect();
        }
    }

    public boolean selectChildAt(int x, int y) {
        for (Shape child : children) {
            if (child.isInsideBounds(x, y)) {
                child.select();
                return true;
            }
        }
        return false;
    }

    @Override
    public void paint(Graphics graphics) {
        if (isSelected()) {
            enableSelectionStyle(graphics);
            graphics.drawRect(getX() - 1, getY() - 1, getWidth() + 1, getHeight() + 1);
            disableSelectionStyle(graphics);
        }

        for (Shape child : children) {
            child.paint(graphics);
        }
    }
}

</code></pre>
<ol start="7">
<li>形状编辑器</li>
</ol>
<pre><code>package com.composite;

import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

/**
 * 形状编辑器
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 10:53
 */
public class ImageEditor {
    private EditorCanvas canvas;
    private CompoundShape allShapes = new CompoundShape();

    public ImageEditor() {
        canvas = new EditorCanvas();
    }

    public void loadShapes(Shape... shapes) {
        allShapes.clear();
        allShapes.add(shapes);
        canvas.refresh();
    }

    private class EditorCanvas extends Canvas {
        JFrame frame;

        private static final int PADDING = 10;

        EditorCanvas() {
            createFrame();
            refresh();
            addMouseListener(new MouseAdapter() {
                @Override
                public void mousePressed(MouseEvent e) {
                    allShapes.unSelect();
                    allShapes.selectChildAt(e.getX(), e.getY());
                    e.getComponent().repaint();
                }
            });
        }

        void createFrame() {
            frame = new JFrame();
            frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
            frame.setLocationRelativeTo(null);

            JPanel contentPanel = new JPanel();
            Border padding = BorderFactory.createEmptyBorder(PADDING, PADDING, PADDING, PADDING);
            contentPanel.setBorder(padding);
            frame.setContentPane(contentPanel);

            frame.add(this);
            frame.setVisible(true);
            frame.getContentPane().setBackground(Color.LIGHT_GRAY);
        }

        public int getWidth() {
            return allShapes.getX() + allShapes.getWidth() + PADDING;
        }

        public int getHeight() {
            return allShapes.getY() + allShapes.getHeight() + PADDING;
        }

        void refresh() {
            this.setSize(getWidth(), getHeight());
            frame.pack();
        }

        public void paint(Graphics graphics) {
            allShapes.paint(graphics);
        }
    }
}

</code></pre>
<ol start="8">
<li>客户端代码</li>
</ol>
<pre><code>package com.composite;

import java.awt.*;

/**
 * 客户端代码
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 10:54
 */
public class Demo {
    public static void main(String[] args) {
        ImageEditor editor = new ImageEditor();

        editor.loadShapes(
                new Circle(10, 10, 10, Color.BLUE),

                new CompoundShape(
                        new Circle(110, 110, 50, Color.RED),
                        new Dot(160, 160, Color.RED)
                ),

                new CompoundShape(
                        new Rectangle(250, 250, 100, 100, Color.GREEN),
                        new Dot(240, 240, Color.GREEN),
                        new Dot(240, 360, Color.GREEN),
                        new Dot(360, 360, Color.GREEN),
                        new Dot(360, 240, Color.GREEN)
                )
        );
    }
}

</code></pre>
<h2 id="组合模式适合应用场景">组合模式适合应用场景</h2>
<ol>
<li>
<p>如果你需要实现树状对象结构， 可以使用组合模式。</p>
<p>组合模式为你提供了两种共享公共接口的基本元素类型： 简单叶节点和复杂容器。 容器中可以包含叶节点和其他容器。 这使得你可以构建树状嵌套递归对象结构。</p>
</li>
<li>
<p>如果你希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。</p>
<p>组合模式中定义的所有元素共用同一个接口。 在这一接口的帮助下， 客户端不必在意其所使用的对象的具体类。</p>
</li>
</ol>
<h2 id="实现方式">实现方式</h2>
<ol>
<li>
<p>确保应用的核心模型能够以树状结构表示。 尝试将其分解为简单元素和容器。 记住， 容器必须能够同时包含简单元素和其他容器。</p>
</li>
<li>
<p>声明组件接口及其一系列方法， 这些方法对简单和复杂元素都有意义。</p>
</li>
<li>
<p>创建一个叶节点类表示简单元素。 程序中可以有多个不同的叶节点类。</p>
</li>
<li>
<p>创建一个容器类表示复杂元素。 在该类中， 创建一个数组成员变量来存储对于其子元素的引用。 该数组必须能够同时保存叶节点和容器， 因此请确保将其声明为组合接口类型。</p>
<p>实现组件接口方法时， 记住容器应该将大部分工作交给其子元素来完成。</p>
</li>
<li>
<p>最后， 在容器中定义添加和删除子元素的方法。</p>
</li>
</ol>
<p>记住， 这些操作可在组件接口中声明。 这将会违反<strong>接口隔离原则</strong>， 因为叶节点类中的这些方法为空。 但是， 这可以让客户端无差别地访问所有元素， 即使是组成树状结构的元素。</p>
<h2 id="组合模式优缺点">组合模式优缺点</h2>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>你可以利用多态和递归机制更方便地使用复杂树结构。</td>
<td style="text-align:center">对于功能差异较大的类， 提供公共接口或许会有困难。 在特定情况下， 你需要过度一般化组件接口， 使其变得令人难以理解。</td>
</tr>
<tr>
<td>开闭原则。 无需更改现有代码， 你就可以在应用中添加新元素， 使其成为对象树的一部分。</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="与其他模式的关系">与其他模式的关系</h2>
<ol>
<li>
<p><strong>桥接模式</strong>、 <strong>状态模式</strong>和<strong>策略模式</strong> （在某种程度上包括<strong>适配器模式</strong>） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p>
</li>
<li>
<p>你可以在创建复杂<strong>组合树</strong>时使用<strong>生成器模式</strong>， 因为这可使其构造步骤以递归的方式运行。</p>
</li>
<li>
<p><strong>责任链模式</strong>通常和<strong>组合模式</strong>结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。</p>
</li>
<li>
<p>你可以使用<strong>迭代器模式</strong>来遍历组合树。</p>
</li>
<li>
<p>你可以使用<strong>访问者模式</strong>对整个<strong>组合树</strong>执行操作。</p>
</li>
<li>
<p>你可以使用<strong>享元模式</strong>实现组合树的共享叶节点以节省内存。</p>
</li>
<li>
<p><strong>组合</strong>和<strong>装饰模式</strong>的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。</p>
<p>装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。</p>
<p>但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。</p>
</li>
<li>
<p>大量使用<strong>组合</strong>和<strong>装饰</strong>的设计通常可从对于<strong>原型模式</strong>的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[适配器模式]]></title>
        <id>https://q456qq520.github.io/post/gua-pei-qi-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/gua-pei-qi-mo-shi/">
        </link>
        <updated>2022-01-12T03:39:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="意图">意图</h2>
<p>适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。</p>
<h2 id="问题">问题</h2>
<p>假如你正在开发一款股票市场监测程序， 它会从不同来源下载 XML 格式的股票数据， 然后向用户呈现出美观的图表。</p>
<p>在开发过程中， 你决定在程序中整合一个第三方智能分析函数库。 但是遇到了一个问题， 那就是分析函数库只兼容 JSON 格式的数据。<br>
<img src="https://refactoringguru.cn/images/patterns/diagrams/adapter/problem-zh-2x.png" alt="likecat" title="你无法 “直接” 使用分析函数库， 因为它所需的输入数据格式与你的程序不兼容。" loading="lazy"><br>
你可以修改程序库来支持 XML。 但是， 这可能需要修改部分依赖该程序库的现有代码。 甚至还有更糟糕的情况， 你可能根本没有程序库的源代码， 从而无法对其进行修改。</p>
<h2 id="解决方案">解决方案</h2>
<p>你可以创建一个适配器。 这是一个特殊的对象， 能够转换对象接口， 使其能与其他对象进行交互。</p>
<p>适配器模式通过封装对象将复杂的转换过程隐藏于幕后。 被封装的对象甚至察觉不到适配器的存在。 例如， 你可以使用一个将所有数据转换为英制单位 （如英尺和英里） 的适配器封装运行于米和千米单位制中的对象。</p>
<p>适配器不仅可以转换不同格式的数据， 其还有助于采用不同接口的对象之间的合作。 它的运作方式如下：</p>
<ol>
<li>适配器实现与其中一个现有对象兼容的接口。</li>
<li>现有对象可以使用该接口安全地调用适配器方法。</li>
<li>适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象。</li>
</ol>
<p>有时你甚至可以创建一个双向适配器来实现双向转换调用。<br>
<img src="https://refactoringguru.cn/images/patterns/diagrams/adapter/solution-zh-2x.png" alt="likecat" loading="lazy"></p>
<p>让我们回到股票市场程序。 为了解决数据格式不兼容的问题， 你可以为分析函数库中的每个类创建将 XML 转换为 JSON 格式的适配器， 然后让客户端仅通过这些适配器来与函数库进行交流。 当某个适配器被调用时， 它会将传入的 XML 数据转换为 JSON 结构， 并将其传递给被封装分析对象的相应方法。</p>
<h2 id="适配器模式结构">适配器模式结构</h2>
<h4 id="对象适配器">对象适配器</h4>
<p>实现时使用了构成原则： 适配器实现了其中一个对象的接口， 并对另一个对象进行封装。 所有流行的编程语言都可以实现适配器。</p>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/diagrams/adapter/structure-object-adapter-2x.png" alt="likecat" loading="lazy"></figure>
<ol>
<li>**客户端 （Client） **是包含当前程序业务逻辑的类。</li>
<li><strong>客户端接口 （Client Interface）</strong> 描述了其他类与客户端代码合作时必须遵循的协议。</li>
<li><strong>服务 （Service）</strong> 中有一些功能类 （通常来自第三方或遗留系统）。 客户端与其接口不兼容， 因此无法直接调用其功能。</li>
<li><strong>适配器 （Adapter）</strong> 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时封装了服务对象。 适配器接受客户端通过适配器接口发起的调用， 并将其转换为适用于被封装服务对象的调用。</li>
<li>客户端代码只需通过接口与适配器交互即可， 无需与具体的适配器类耦合。 因此， 你可以向程序中添加新类型的适配器而无需修改已有代码。 这在服务类的接口被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器类。</li>
</ol>
<h4 id="类适配器">类适配器</h4>
<p>这一实现使用了继承机制： 适配器同时继承两个对象的接口。</p>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/adapter/structure-class-adapter-2x.png" alt="likecat" title="类适配器" loading="lazy"></figure>
<ol>
<li><strong>类适配器</strong>不需要封装任何对象， 因为它同时继承了客户端和服务的行为。 适配功能在重写的方法中完成。 最后生成的适配器可替代已有的客户端类进行使用。</li>
</ol>
<h2 id="伪代码">伪代码</h2>
<p>下列适配器模式演示基于经典的 “方钉和圆孔” 问题。</p>
<p><img src="https://refactoringguru.cn/images/patterns/diagrams/adapter/example-2x.png" alt="likecat" title="方钉圆孔" loading="lazy"><br>
让方钉适配圆孔。</p>
<p>适配器假扮成一个圆钉 （Round­Peg）， 其半径等于方钉 （Square­Peg） 横截面对角线的一半 （即能够容纳方钉的最小外接圆的半径）。</p>
<p><strong>圆孔</strong></p>
<pre><code>package round;

/**
 * 圆孔
 * @author TZP
 * @version 1.0
 * @date 2022/1/12 14:26
 */
public class RoundHole {

    //半径
    private double radius;

    public RoundHole(double radius) {
        this.radius = radius;
    }

    public double getRadius() {
        return radius;
    }

    //打圆孔
    public boolean fits(RoundPeg peg) {
        boolean result;
        result = (this.getRadius() &gt;= peg.getRadius());
        return result;
    }
}

</code></pre>
<p><strong>圆钉</strong></p>
<pre><code>package round;

/**
 * 圆钉
 * @author TZP
 * @version 1.0
 * @date 2022/1/12 14:28
 */
public class RoundPeg {
    private double radius;

    public RoundPeg() {}

    public RoundPeg(double radius) {
        this.radius = radius;
    }

    public double getRadius() {
        return radius;
    }
}

</code></pre>
<p><strong>方钉</strong></p>
<pre><code>package round;

/**
 * 方钉
 * @author TZP
 * @version 1.0
 * @date 2022/1/12 14:31
 */
public class SquarePeg {
    private double width;

    public SquarePeg(double width) {
        this.width = width;
    }

    public double getWidth() {
        return width;
    }

    public double getSquare() {
        double result;
        result = Math.pow(this.width, 2);
        return result;
    }
}

</code></pre>
<p><strong>方钉到圆孔的适配器</strong></p>
<pre><code>package round;

/**
 * 方钉到圆孔的适配器
 * @author TZP
 * @version 1.0
 * @date 2022/1/12 14:33
 */
public class SquarePegAdapter extends RoundPeg{

    private SquarePeg peg;

    public SquarePegAdapter(SquarePeg peg) {
        this.peg = peg;
    }

    @Override
    public double getRadius() {
        double result;
        // Calculate a minimum circle radius, which can fit this peg.
        result = (Math.sqrt(Math.pow((peg.getWidth() / 2), 2) * 2));
        return result;
    }
}

</code></pre>
<p><strong>客户端代码</strong></p>
<pre><code>package round;

/**
 * 客户端代码
 * @author TZP
 * @version 1.0
 * @date 2022/1/12 14:36
 */
public class Demo {
    public static void main(String[] args) {
        // Round fits round, no surprise.
        RoundHole hole = new RoundHole(5);
        RoundPeg rpeg = new RoundPeg(5);
        if (hole.fits(rpeg)) {
            System.out.println(&quot;Round peg r5 fits round hole r5.&quot;);
        }

        SquarePeg smallSqPeg = new SquarePeg(2);
        SquarePeg largeSqPeg = new SquarePeg(20);
        // hole.fits(smallSqPeg); // Won't compile.

        // Adapter solves the problem.
        SquarePegAdapter smallSqPegAdapter = new SquarePegAdapter(smallSqPeg);
        SquarePegAdapter largeSqPegAdapter = new SquarePegAdapter(largeSqPeg);
        if (hole.fits(smallSqPegAdapter)) {
            System.out.println(&quot;Square peg w2 fits round hole r5.&quot;);
        }
        if (!hole.fits(largeSqPegAdapter)) {
            System.out.println(&quot;Square peg w20 does not fit into round hole r5.&quot;);
        }
    }
}

</code></pre>
<p><strong>执行结果</strong></p>
<pre><code>Round peg r5 fits round hole r5.
Square peg w2 fits round hole r5.
Square peg w20 does not fit into round hole r5.
</code></pre>
<h2 id="适配器模式适合应用场景">适配器模式适合应用场景</h2>
<p><strong>当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。</strong><br>
适配器模式允许你创建一个中间层类， 其可作为代码与遗留类、 第三方类或提供怪异接口的类之间的转换器。</p>
<p><strong>如果您需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。</strong><br>
你可以扩展每个子类， 将缺少的功能添加到新的子类中。 但是， 你必须在所有新子类中重复添加这些代码， 这样会使得代码有坏味道。</p>
<p>将缺失功能添加到一个适配器类中是一种优雅得多的解决方案。 然后你可以将缺少功能的对象封装在适配器中， 从而动态地获取所需功能。 如要这一点正常运作， 目标类必须要有通用接口， 适配器的成员变量应当遵循该通用接口。 这种方式同<strong>装饰模式</strong>非常相似。</p>
<h2 id="实现方式">实现方式</h2>
<ol>
<li>确保至少有两个类的接口不兼容：
<ul>
<li>一个无法修改 （通常是第三方、 遗留系统或者存在众多已有依赖的类） 的功能性服务类。</li>
<li>一个或多个将受益于使用服务类的客户端类。</li>
</ul>
</li>
<li>声明客户端接口， 描述客户端如何与服务交互。</li>
<li>创建遵循客户端接口的适配器类。 所有方法暂时都为空。</li>
<li>在适配器类中添加一个成员变量用于保存对于服务对象的引用。 通常情况下会通过构造函数对该成员变量进行初始化， 但有时在调用其方法时将该变量传递给适配器会更方便。</li>
<li>依次实现适配器类客户端接口的所有方法。 适配器会将实际工作委派给服务对象， 自身只负责接口或数据格式的转换。</li>
<li>客户端必须通过客户端接口使用适配器。 这样一来， 你就可以在不影响客户端代码的情况下修改或扩展适配器。</li>
</ol>
<h2 id="适配器模式优缺点">适配器模式优缺点</h2>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>单一职责原则_你可以将接口或数据转换代码从程序主要业务逻辑中分离。</td>
<td style="text-align:center">代码整体复杂度增加， 因为你需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。</td>
</tr>
<tr>
<td>开闭原则。 只要客户端代码通过客户端接口与适配器进行交互， 你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="与其他模式的关系">与其他模式的关系</h2>
<ul>
<li>
<p><strong>桥接模式</strong>通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， <strong>适配器模式</strong>通常在已有程序中使用， 让相互不兼容的类能很好地合作。</p>
</li>
<li>
<p><strong>适配器</strong>可以对已有对象的接口进行修改， <strong>装饰模式</strong>则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。</p>
</li>
<li>
<p><strong>适配器</strong>能为被封装对象提供不同的接口， <strong>代理模式</strong>能为对象提供相同的接口， <strong>装饰</strong>则能为对象提供加强的接口。</p>
</li>
<li>
<p><strong>外观模式</strong>为现有对象定义了一个新接口，** 适配器**则会试图运用已有的接口。 <strong>适配器</strong>通常只封装一个对象， <strong>外观</strong>通常会作用于整个对象子系统上。</p>
</li>
<li>
<p><strong>桥接</strong>、 <strong>状态模式</strong>和<strong>策略模式</strong> （在某种程度上包括<strong>适配器</strong>） 模式的接口非常相似。 实际上， 它们都基于<strong>组合模式</strong>——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[桥接模式]]></title>
        <id>https://q456qq520.github.io/post/qiao-jie-mo-shi/</id>
        <link href="https://q456qq520.github.io/post/qiao-jie-mo-shi/">
        </link>
        <updated>2022-01-11T10:24:16.000Z</updated>
        <content type="html"><![CDATA[<p>桥接模式是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。</p>
<p>先考虑一个简单的例子。</p>
<p>假如你有一个几何 形状Shape类， 从它能扩展出两个子类： ​ 圆形Circle和 方形Square 。 你希望对这样的类层次结构进行扩展以使其包含颜色， 所以你打算创建名为 红色Red和 蓝色Blue的形状子类。 但是， 由于你已有两个子类， 所以总共需要创建四个类才能覆盖所有组合， 例如 蓝色圆形Blue­Circle和 红色方形Red­Square 。</p>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/diagrams/bridge/problem-zh-2x.png" alt="likecat" title="桥接模式" loading="lazy"></figure>
<p>在层次结构中新增形状和颜色将导致代码复杂程度指数增长。 例如添加三角形状， 你需要新增两个子类， 也就是每种颜色一个； 此后新增一种新颜色需要新增三个子类， 即每种形状一个。 如此以往， 情况会越来越糟糕。</p>
<p>问题的根本原因是我们试图在两个独立的维度——形状与颜色——上扩展形状类。 这在处理类继承时是很常见的问题。</p>
<p>桥接模式通过将继承改为组合的方式来解决这个问题。 具体来说， 就是抽取其中一个维度并使之成为独立的类层次， 这样就可以在初始类中引用这个新层次的对象， 从而使得一个类不必拥有所有的状态和行为。</p>
<figure data-type="image" tabindex="2"><img src="https://refactoringguru.cn/images/patterns/diagrams/bridge/solution-zh-2x.png" alt="将一个类层次转化为多个相关的类层次， 避免单个类层次的失控。" title="将一个类层次转化为多个相关的类层次， 避免单个类层次的失控。" loading="lazy"></figure>
<p>根据该方法， 我们可以将颜色相关的代码抽取到拥有 红色和 蓝色两个子类的颜色类中， 然后在 形状类中添加一个指向某一颜色对象的引用成员变量。 现在， 形状类可以将所有与颜色相关的工作委派给连入的颜色对象。 这样的引用就成为了 形状和 颜色之间的桥梁。 此后， 新增颜色将不再需要修改形状的类层次， 反之亦然。</p>
<h4 id="抽象部分和实现部分">抽象部分和实现部分</h4>
<p>抽象部分 （也被称为接口） 是一些实体的高阶控制层。 该层自身不完成任何具体的工作， 它需要将工作委派给实现部分层 （也被称为平台）。</p>
<p>在实际的程序中， 抽象部分是图形用户界面 （GUI）， 而实现部分则是底层操作系统代码 （API）， GUI 层调用 API 层来对用户的各种操作做出响应。</p>
<p>一般来说， 你可以在两个独立方向上扩展这种应用：</p>
<ul>
<li>开发多个不同的 GUI （例如面向普通用户和管理员进行分别配置）</li>
<li>支持多个不同的 API （例如， 能够在 Windows、 Linux 和 macOS 上运行该程序）。</li>
</ul>
<p>在最糟糕的情况下， 程序可能会是一团乱麻， 其中包含数百种条件语句， 连接着代码各处不同种类的 GUI 和各种 API。</p>
<h4 id="桥接模式结构">桥接模式结构</h4>
<figure data-type="image" tabindex="3"><img src="https://refactoringguru.cn/images/patterns/diagrams/bridge/structure-zh-2x.png" alt="桥接模式" title="桥接模式" loading="lazy"></figure>
<ol>
<li><strong>抽象部分 （Abstraction）</strong> 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。</li>
<li><strong>实现部分 （Implementation） <strong>为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。<br>
抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作。<br>
3.</strong> 具体实现 （Concrete Implementations） <strong>中包括特定于平台的代码。<br>
4.</strong> 精确抽象 （Refined Abstraction）</strong> 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。</li>
<li>通常情况下， **客户端 （Client） **仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。</li>
</ol>
<h4 id="伪代码">伪代码</h4>
<p>所有设备的通用接口</p>
<pre><code>package com.bridge;

/**
 * 所有设备的通用接口
 * @author TZP
 * @version 1.0
 * @date 2022/1/11 23:48
 */
public interface Device {
    //是否在运行
    boolean isEnabled();

    //运行
    void enable();

    //关闭
    void disable();

    //获取体积
    int getVolume();

    void setVolume(int percent);

    //过去渠道
    int getChannel();

    void setChannel(int channel);

    //状态
    void printStatus();
}

</code></pre>
<p>收音机</p>
<pre><code>package com.bridge;

/**
 * 收音机
 * @author TZP
 * @version 1.0
 * @date 2022/1/11 23:51
 */
public class Radio implements Device{
    private boolean on = false;
    private int volume = 30;
    private int channel = 1;

    @Override
    public boolean isEnabled() {
        return on;
    }

    @Override
    public void enable() {
        on = true;
    }

    @Override
    public void disable() {
        on = false;
    }

    @Override
    public int getVolume() {
        return volume;
    }

    @Override
    public void setVolume(int volume) {
        if (volume &gt; 100) {
            this.volume = 100;
        } else if (volume &lt; 0) {
            this.volume = 0;
        } else {
            this.volume = volume;
        }
    }

    @Override
    public int getChannel() {
        return channel;
    }

    @Override
    public void setChannel(int channel) {
        this.channel = channel;
    }

    @Override
    public void printStatus() {
        System.out.println(&quot;------------------------------------&quot;);
        System.out.println(&quot;| I'm radio.&quot;);
        System.out.println(&quot;| I'm &quot; + (on ? &quot;enabled&quot; : &quot;disabled&quot;));
        System.out.println(&quot;| Current volume is &quot; + volume + &quot;%&quot;);
        System.out.println(&quot;| Current channel is &quot; + channel);
        System.out.println(&quot;------------------------------------\n&quot;);
    }
}

</code></pre>
<p>电视机</p>
<pre><code>package com.bridge;

/**
 * 电视机
 * @author TZP
 * @version 1.0
 * @date 2022/1/11 23:53
 */
public class Tv implements Device{
    private boolean on = false;
    private int volume = 30;
    private int channel = 1;

    @Override
    public boolean isEnabled() {
        return on;
    }

    @Override
    public void enable() {
        on = true;
    }

    @Override
    public void disable() {
        on = false;
    }

    @Override
    public int getVolume() {
        return volume;
    }

    @Override
    public void setVolume(int volume) {
        if (volume &gt; 100) {
            this.volume = 100;
        } else if (volume &lt; 0) {
            this.volume = 0;
        } else {
            this.volume = volume;
        }
    }

    @Override
    public int getChannel() {
        return channel;
    }

    @Override
    public void setChannel(int channel) {
        this.channel = channel;
    }

    @Override
    public void printStatus() {
        System.out.println(&quot;------------------------------------&quot;);
        System.out.println(&quot;| I'm TV set.&quot;);
        System.out.println(&quot;| I'm &quot; + (on ? &quot;enabled&quot; : &quot;disabled&quot;));
        System.out.println(&quot;| Current volume is &quot; + volume + &quot;%&quot;);
        System.out.println(&quot;| Current channel is &quot; + channel);
        System.out.println(&quot;------------------------------------\n&quot;);
    }
}
</code></pre>
<p>所有远程控制器的通用接口</p>
<pre><code>package com.bridge;

/**
 * 所有远程控制器的通用接口
 * @author TZP
 * @version 1.0
 * @date 2022/1/11 23:54
 */
public interface Remote {
    void power();

    void volumeDown();

    void volumeUp();

    void channelDown();

    void channelUp();
}

</code></pre>
<p>基础远程控制器</p>
<pre><code>package com.bridge;

/**
 * 基础远程控制器
 * @author TZP
 * @version 1.0
 * @date 2022/1/11 23:56
 */
public class BasicRemote implements Remote{
    protected Device device;

    public BasicRemote() {}

    public BasicRemote(Device device) {
        this.device = device;
    }

    @Override
    public void power() {
        System.out.println(&quot;Remote: power toggle&quot;);
        if (device.isEnabled()) {
            device.disable();
        } else {
            device.enable();
        }
    }

    @Override
    public void volumeDown() {
        System.out.println(&quot;Remote: volume down&quot;);
        device.setVolume(device.getVolume() - 10);
    }

    @Override
    public void volumeUp() {
        System.out.println(&quot;Remote: volume up&quot;);
        device.setVolume(device.getVolume() + 10);
    }

    @Override
    public void channelDown() {
        System.out.println(&quot;Remote: channel down&quot;);
        device.setChannel(device.getChannel() - 1);
    }

    @Override
    public void channelUp() {
        System.out.println(&quot;Remote: channel up&quot;);
        device.setChannel(device.getChannel() + 1);
    }
}

</code></pre>
<p>高级远程控制器</p>
<pre><code>package com.bridge;

/**
 * 高级远程控制器
 * @author TZP
 * @version 1.0
 * @date 2022/1/11 23:57
 */
public class AdvancedRemote extends BasicRemote {

    public AdvancedRemote(Device device) {
        super.device = device;
    }

    public void mute() {
        System.out.println(&quot;Remote: mute&quot;);
        device.setVolume(0);
    }
}

</code></pre>
<p>客户端代码</p>
<pre><code>package com.bridge;

/**
 * 客户端代码
 * @author TZP
 * @version 1.0
 * @date 2022/1/11 23:58
 */
public class Demo {
    public static void main(String[] args) {
        testDevice(new Tv());
        testDevice(new Radio());
    }

    public static void testDevice(Device device) {
        System.out.println(&quot;Tests with basic remote.&quot;);
        BasicRemote basicRemote = new BasicRemote(device);
        basicRemote.power();
        device.printStatus();

        System.out.println(&quot;Tests with advanced remote.&quot;);
        AdvancedRemote advancedRemote = new AdvancedRemote(device);
        advancedRemote.power();
        advancedRemote.mute();
        device.printStatus();
    }
}

</code></pre>
<p>执行结果</p>
<pre><code>Tests with basic remote.
Remote: power toggle
------------------------------------
| I'm TV set.
| I'm enabled
| Current volume is 30%
| Current channel is 1
------------------------------------

Tests with advanced remote.
Remote: power toggle
Remote: mute
------------------------------------
| I'm TV set.
| I'm disabled
| Current volume is 0%
| Current channel is 1
------------------------------------

Tests with basic remote.
Remote: power toggle
------------------------------------
| I'm radio.
| I'm enabled
| Current volume is 30%
| Current channel is 1
------------------------------------

Tests with advanced remote.
Remote: power toggle
Remote: mute
------------------------------------
| I'm radio.
| I'm disabled
| Current volume is 0%
| Current channel is 1
------------------------------------
</code></pre>
<h4 id="桥接模式适合应用场景">桥接模式适合应用场景</h4>
<p>####### 如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。</p>
<p>类的代码行数越多， 弄清其运作方式就越困难， 对其进行修改所花费的时间就越长。 一个功能上的变化可能需要在整个类范围内进行修改， 而且常常会产生错误， 甚至还会有一些严重的副作用。</p>
<p>桥接模式可以将庞杂类拆分为几个类层次结构。 此后， 你可以修改任意一个类层次结构而不会影响到其他类层次结构。 这种方法可以简化代码的维护工作， 并将修改已有代码的风险降到最低。</p>
<p>####### 如果你希望在几个独立维度上扩展一个类， 可使用该模式。<br>
桥接建议将每个维度抽取为独立的类层次。 初始类将相关工作委派给属于对应类层次的对象， 无需自己完成所有工作。</p>
<p>#######  如果你需要在运行时切换不同实现方法， 可使用桥接模式。<br>
当然并不是说一定要实现这一点， 桥接模式可替换抽象部分中的实现对象， 具体操作就和给成员变量赋新值一样简单。</p>
<p>顺便提一句， 最后一点是很多人混淆桥接模式和策略模式的主要原因。 记住， 设计模式并不仅是一种对类进行组织的方式， 它还能用于沟通意图和解决问题。</p>
<h4 id="实现方式">实现方式</h4>
<ol>
<li>
<p>明确类中独立的维度。 独立的概念可能是： 抽象/平台， 域/基础设施， 前端/后端或接口/实现。</p>
</li>
<li>
<p>了解客户端的业务需求， 并在抽象基类中定义它们。</p>
</li>
<li>
<p>确定在所有平台上都可执行的业务。 并在通用实现接口中声明抽象部分所需的业务。</p>
</li>
<li>
<p>为你域内的所有平台创建实现类， 但需确保它们遵循实现部分的接口。</p>
</li>
<li>
<p>在抽象类中添加指向实现类型的引用成员变量。 抽象部分会将大部分工作委派给该成员变量所指向的实现对象。</p>
</li>
<li>
<p>如果你的高层逻辑有多个变体， 则可通过扩展抽象基类为每个变体创建一个精确抽象。</p>
</li>
<li>
<p>客户端代码必须将实现对象传递给抽象部分的构造函数才能使其能够相互关联。 此后， 客户端只需与抽象对象进行交互， 无需和实现对象打交道。</p>
</li>
</ol>
<h4 id="桥接模式优缺点">桥接模式优缺点</h4>
<h5 id="优点">优点</h5>
<ul>
<li>你可以创建与平台无关的类和程序。</li>
<li>客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息。</li>
<li>开闭原则。 你可以新增抽象部分和实现部分， 且它们之间不会相互影响。</li>
<li>单一职责原则。 抽象部分专注于处理高层逻辑， 实现部分处理平台细节。</li>
</ul>
<h5 id="缺点">缺点</h5>
<ul>
<li>对高内聚的类使用该模式可能会让代码更加复杂。</li>
</ul>
<h4 id="与其他模式的关系">与其他模式的关系</h4>
<p>桥接模式通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器模式通常在已有程序中使用， 让相互不兼容的类能很好地合作。</p>
<p>桥接、 状态模式和策略模式 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p>
<p>你可以将抽象工厂模式和桥接搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</p>
<p>你可以结合使用生成器模式和桥接模式： 主管类负责抽象工作， 各种不同的生成器负责实现工作。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法设计的常用思想]]></title>
        <id>https://q456qq520.github.io/post/suan-fa-she-ji-de-chang-yong-si-xiang/</id>
        <link href="https://q456qq520.github.io/post/suan-fa-she-ji-de-chang-yong-si-xiang/">
        </link>
        <updated>2022-01-04T09:31:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="贪婪法">贪婪法</h3>
<p>贪婪法(greedy algorithm)，又称贪心算法，是寻找最优解问题的常用方法。这种方法模式 一般将求解过程分成若干个步骤，在每个步骤都应用贪心原则，选取当前状态下最好的或最优的 选择(局部最有利的选择)，并以此希望最后堆叠出的结果也是最好或最优的解。贪婪法的每次 决策都以当前情况为基础并根据某个最优原则进行选择，不从整体上考虑其他各种可能的情况。 一般来说，这种贪心原则在各种算法模式中都会体现，单独作为一种方法来说明，是因为贪婪法 对于特定的问题是非常有效的方法。</p>
<p>贪婪法和动态规划法以及分治法一样，都需要对问题进行分解，定义最优解的子结构。但是， 贪婪法与其他方法最大的不同在于，贪婪法每一步选择完之后，局部最优解就确定了，不再进行 回溯处理，也就是说，每一个步骤的局部最优解确定以后，就不再修改，直到算法结束。因为不 进行回溯处理，贪婪法只在很少的情况下可以得到真正的最优解，比如最短路径问题、图的最小 生成树问题。大多数情况下，由于选择策略的“短视”，贪婪法会错过真正的最优解，得不到问题的真正答案。但是贪婪法简单高效，省去了为找最优解可能需要的穷举操作，可以得到与最优解比较接近的近似最优解，通常作为其他算法的辅助算法使用。</p>
<ol>
<li>贪婪法的基本思想<br>
贪婪法的基本设计思想有以下三个步骤。</li>
</ol>
<ul>
<li>建立对问题精确描述的数学模型，包括定义最优解的模型;</li>
<li>将问题分解为一系列子问题，同时定义子问题的最优解结构;</li>
<li>应用贪心原则确定每个子问题的局部最优解，并根据最优解的模型，用子问题的局部最<br>
优解堆叠出全局最优解。</li>
</ul>
<p>定义最优解的模型通常和定义子问题的最优解结构是同时进行的，最优解的模型一般都体现 了最优解子问题的分解结构和堆叠方式。对于子问题的分解有多种方式，有的问题可以按照问题 的求解过程一步一步地进行分解，每一步都在前一步的基础上选择当前最好的解，每做一次选择 就将问题简化为一个规模更小的子问题，当最后一步的求解完成后就得到了全局最优解。还有的 问题可以将问题分解成相对独立的几个子问题，对每个子问题求解完成后再按照一定的规则(比 如某种公式或计算法则)将其组合起来得到全局最优解。</p>
<ol start="2">
<li>贪婪法的例子:0-1背包问题</li>
</ol>
<p><strong>0-1 背包问题:有 N 件物品和一个承重为 C 的背包(也 可定义为体积)，每件物品的重量是 wi，价值是 pi，求解将哪几件物品装入背包可使这些物品在 重量总和不超过 C 的情况下价值总和最大。</strong></p>
<p>背包问题(knapsack problem)是此类组合优化的 NP 完全问题的统称，比如货箱装载问题、货船载物问题等，因问题最初来源于如何选择最合适的物 品装在背包中而得名。这个问题隐含了一个条件，每个物品只有一件，也就是限定每件物品只能选择 0 个或 1 个，因此又被称为 0-1 背包问题。</p>
<p>来看一个具体的例子，有一个背包，最多能承载重量为 C=150 的物品，现在有 7 个物品(物 品不能分割成任意大小)，编号为 1~7，重量分别是 wi=[35,30,60,50,40,10,25]，价值分别是 pi=[10,40,30,50,35,40,30]，现在从这 7 个物品中选择一个或多个装入背包，要求在物品总重量不 超过 C 的前提下，所装入的物品总价值最高。这个问题的子问题可以按照选择物品装入背包的过 程按部就班地一步一步分解，将子问题定义为在被背包容量还有 C’的情况下，选择一个物品装 入背包。C’的初始值就是 150，假如选择了一个重为 35 的物品，则子问题就变成在背包容量 C’ 是 115 的情况下，从剩下的 6 件物品中选择一个物品，这样每选择一个物品就相当于子问题的规 模减小了。</p>
<p>那么如何选择物品呢?这就是贪婪策略的选择问题。对于本题，常见的贪婪策略有三种。第 一种策略是根据物品价值选择，每次都选价值最高的物品。根据这个策略最终选择装入背包的物 品编号依次是 4、2、6、5，此时包中物品总重量是 130，总价值是 165。第二种策略是根据物品 重量选择，每次都选择重量最轻的物品。根据这个策略最终选择装入背包的物品编号依次是 6、 7、2、1、5，此时包中物品总重量是 140，总价值是 155。第三种策略是定义一个价值密度的概 念，每次选择都选价值密度最高的物品。物品的价值密度 si 定义为 pi/wi，这 7 件物品的价值密度 分别为 si=[0.286,1.333,0.5,1.0,0.875,4.0,1.2]。根据这个策略最终选择装入背包的物品编号依次是 6、2、7、4、1，此时包中物品的总重量是 150，总价值是 170。<br>
根据前文的分析结果，我们给出贪婪法解决背包问题的算法实现。首先定义背包问题的数 据结构，根据问题描述，可以直接知道每个物品有两个属性，分别是重量和价值。此外，每个 物品只能被选择一次，因此还需要给每个物品增加一个选择状态的属性，因此物品的数据结构 定义如下:</p>
<pre><code>public class TagObject  implements Comparable&lt;TagObject&gt; {

    private int weight; //重量
    private int price; //价值
    private int unitValue;//单位重量价值

    public TagObject(int weight, int price) {
        this.weight = weight;
        this.price = price;
        this.unitValue = (weight == 0) ? 0 : price / weight;
    }

    @Override
    public int compareTo(TagObject tagObject) {
        int value = tagObject.unitValue;
        if (unitValue &gt; value)
            return 1;
        if (unitValue &lt; value)
            return -1;
        return 0;
    }
}
</code></pre>
<p>需要特别说明的是状态值为 2 的情况，这种情况表示用当前策略选择的物品导致总重量超过 背包承重量，在这种情况下，如果放弃这个物品，按照策略从剩下的物品中再选一个，有可能就 能满足背包承重的要求。因此，设置了一个状态 2，表示当前选择物品不合适，下次选择也不要 再选这个物品了。接下来是背包问题的定义，背包问题包括两个属性，一个是可选物品列表，一 个是背包总的承重量。简单定义背包问题数据结构如下:</p>
<pre><code>public class TagKnapsackProblem {

    // 现有的物品
    private TagObject[] bags;
    // 背包的总承重
    private int totalWeight;
    // 背包最大总价值
    private int bestValue;

    public TagKnapsackProblem(TagObject[] bags, int totalWeight) {
        this.bags = bags;
        this.totalWeight = totalWeight;
        // 对背包按单位重量价值从大到小排序
        Arrays.sort(bags, Collections.reverseOrder());
    }

    public void solve() {
        int tempWeight = totalWeight;

        for (int i = 0; i &lt; bags.length; i++) {
            //判断当前物品是否可以放入背包中，若不能则继续循环，查找下一个物品
            if (tempWeight - bags[i].getWeight() &lt; 0)
                continue;

            tempWeight -= bags[i].getWeight();
            bestValue += bags[i].getPrice();
        }
    }

    public int getBestValue() {
        return bestValue;
    }
}
</code></pre>
<p>最后写一个测试类</p>
<pre><code>public class Test {
    public static void main(String[] args) {

        TagObject[] bags = new TagObject[] { new TagObject(2, 13),
                new TagObject(1, 10), new TagObject(3, 24), new TagObject(2, 15),
                new TagObject(4, 28), new TagObject(5, 33), new TagObject(3, 20),
                new TagObject(1, 8) };
        int totalWeight = 12;

        TagKnapsackProblem problem = new TagKnapsackProblem(bags, totalWeight);
        problem.solve();

        System.out.println(problem.getBestValue()); //结果为85
    }
}

</code></pre>
<p>GreedyAlgo()函数是贪婪算法的主体结构，包括子问题的分解和选择策略的选择都在这个函数中。正如函数所展示的那样，它可以作为此类问题的一个通用解决思路。</p>
<h3 id="分治法">分治法</h3>
<ol>
<li>是</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[有一亿个keys要统计，应该用哪种集合？]]></title>
        <id>https://q456qq520.github.io/post/you-yi-yi-ge-keys-yao-tong-ji-ying-gai-yong-na-chong-ji-he/</id>
        <link href="https://q456qq520.github.io/post/you-yi-yi-ge-keys-yao-tong-ji-ying-gai-yong-na-chong-ji-he/">
        </link>
        <updated>2021-12-30T07:58:31.000Z</updated>
        <content type="html"><![CDATA[<p>通常情况下，我们面临的用户数量以及访问量都是巨大的，比如百万、千万级别的用户数量，或者千万级别、甚至亿级别的访问信息。所以，我们必须要选择能够非常高效地统计大量数据（例如亿级）的集合类型。</p>
<p><strong>要想选择合适的集合，我们就得了解常用的集合统计模式。<strong>集合类型常见的四种统计模式，包括</strong>聚合统计、排序统计、二值状态统计和基数统计</strong>。</p>
<h4 id="聚合统计">聚合统计</h4>
<p>所谓的聚合统计，就是指统计多个集合元素的聚合结果，包括：统计多个集合的共有元素（交集统计）；把两个集合相比，统计其中一个集合独有的元素（差集统计）；统计多个集合的所有元素（并集统计）。</p>
<h4 id="排序统计">排序统计</h4>
<p>在Redis常用的4个集合类型中（List、Hash、Set、Sorted Set），List和Sorted Set就属于有序集合。</p>
<p>List是按照元素进入List的顺序进行排序的，而Sorted Set可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入Sorted Set的时间确定权重值，先插入的元素权重小，后插入的元素权重大。</p>
<h4 id="二值状态统计">二值状态统计</h4>
<p>二值状态统计。这里的二值状态就是指集合元素的取值就只有0和1两种。在签到打卡的场景中，我们只用记录签到（1）或未签到（0），所以它就是非常典型的二值状态，</p>
<h4 id="基数统计">基数统计</h4>
<p>基数统计就是指统计一个集合中不重复的元素个数。</p>
<figure data-type="image" tabindex="1"><img src="https://static001.geekbang.org/resource/image/c0/6e/c0bb35d0d91a62ef4ca1bd939a9b136e.jpg" alt="likecat" title="统计" loading="lazy"></figure>
<p>Set和Sorted Set都支持多种聚合统计，不过，对于差集计算来说，只有Set支持。Bitmap也能做多个Bitmap间的聚合计算，包括与、或和异或操作。</p>
<p>当需要进行排序统计时，List中的元素虽然有序，但是一旦有新元素插入，原来的元素在List中的位置就会移动，那么，按位置读取的排序结果可能就不准确了。而Sorted Set本身是按照集合元素的权重排序，可以准确地按序获取结果</p>
<p>如果记录的数据只有0和1两个值的状态，Bitmap会是一个很好的选择，这主要归功于Bitmap对于一个数据只用1个bit记录，可以节省内存。</p>
<p>对于基数统计来说，如果集合元素量达到亿级别而且不需要精确统计时，建议使用HyperLogLog。</p>
]]></content>
    </entry>
</feed>