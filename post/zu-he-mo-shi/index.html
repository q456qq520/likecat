<!DOCTYPE html>
<html lang="zh-CN">
	<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="initial-scale=1.0,user-scalable=no,minimal-ui" />
    <title>组合模式 | LIKE CAT</title>
<link rel='stylesheet' id='puma-css'  href='https://q456qq520.github.io/styles/main.css' type='text/css' media='screen' />
<link rel='stylesheet' id='puma-css'  href='https://at.alicdn.com/t/font_1306644_jwtuc2zzbrd.css' media='screen' />
 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<script type='text/javascript' src='https://q456qq520.github.io/media/scripts/jquery.js'></script>
<script type='text/javascript' src='https://q456qq520.github.io/media/scripts/jquery-migrate.min.js'></script>
        <script src="https://cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script>
         <script >hljs.initHighlightingOnLoad();</script>
         
</head>
<body class="single single-post postid-3788 single-format-standard">
	<!--加入跟随滑动的顶部-->
	<header id="masthead" class="site-header" role="banner">
		<div class="site-branding">
			<h1 class="site-title">
				<a href="https://q456qq520.github.io" title="LIKE CAT">LIKE CAT</a>
			</h1>
		</div>

		<a class="primary-nav-trigger" href="javascript:void(0)">
			<span class="menu-icon"></span>
		</a>
		
	</header>
		<div class="site-navigation-wrapper">
		<nav id="site-navigation" class="main-navigation" role="navigation">
			<ul class="primary-nav">
                    
				<li id="menu-item-30" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-30"><a title="首页" href="/">首页</a></li>
                
				<li id="menu-item-30" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-30"><a title="归档" href="/archives">归档</a></li>
                
				<li id="menu-item-30" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-30"><a title="标签" href="/tags">标签</a></li>
                
				<li id="menu-item-30" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-30"><a title="关于" href="/post/about">关于</a></li>
                
				<li id="menu-item-30" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-30"><a title="设计模式" href="/post/yuan-xing-mo-shi">设计模式</a></li>
                
				<li id="menu-item-30" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-30"><a title="分布式" href="/fenbushi">分布式</a></li>
                
	
			</ul>
		</nav>			
	</div>
	<!--跟随滑动的顶部结束-->
	<div class="surface-content">    <main class="main-content">
        <section class="section-body">
                            <header class="section-header u-textAlignCenter">
                    <h2 class="grap--h2">组合模式</h2>
                    <div class="block-postMetaWrap">
                        <time>2022-01-12</time>
                    </div>
                </header>
                <div class="grap">
					
					<h2 id="意图">意图</h2>
<p><strong>组合模式</strong>是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。</p>
<h2 id="问题">问题</h2>
<p>如果应用的核心模型能用树状结构表示， 在应用中使用组合模式才有价值。</p>
<p>例如， 你有两类对象： ​ 产品和 盒子 。 一个盒子中可以包含多个 产品或者几个较小的 盒子 。 这些小 盒子中同样可以包含一些 产品或更小的 盒子 ， 以此类推。</p>
<p>假设你希望在这些类的基础上开发一个定购系统。 订单中可以包含无包装的简单产品， 也可以包含装满产品的盒子……以及其他盒子。 此时你会如何计算每张订单的总价格呢？</p>
<p><img src="https://refactoringguru.cn/images/patterns/diagrams/composite/problem-zh-2x.png" alt="likecat" loading="lazy"><br>
订单中可能包括各种产品， 这些产品放置在盒子中， 然后又被放入一层又一层更大的盒子中。 整个结构看上去像是一棵倒过来的树。</p>
<p>你可以尝试直接计算： 打开所有盒子， 找到每件产品， 然后计算总价。 这在真实世界中或许可行， 但在程序中， 你并不能简单地使用循环语句来完成该工作。 你必须事先知道所有 产品和 盒子的类别， 所有盒子的嵌套层数以及其他繁杂的细节信息。 因此， 直接计算极不方便， 甚至完全不可行。</p>
<h2 id="解决方案">解决方案</h2>
<p>组合模式建议使用一个通用接口来与 产品和 盒子进行交互， 并且在该接口中声明一个计算总价的方法。</p>
<p>那么方法该如何设计呢？ 对于一个产品， 该方法直接返回其价格； 对于一个盒子， 该方法遍历盒子中的所有项目， 询问每个项目的价格， 然后返回该盒子的总价格。 如果其中某个项目是小一号的盒子， 那么当前盒子也会遍历其中的所有项目， 以此类推， 直到计算出所有内部组成部分的价格。 你甚至可以在盒子的最终价格中增加额外费用， 作为该盒子的包装费用。</p>
<p><img src="https://refactoringguru.cn/images/patterns/content/composite/composite-comic-1-zh-2x.png" alt="likecat" loading="lazy"><br>
组合模式以递归方式处理对象树中的所有项目</p>
<p>该方式的最大优点在于你无需了解构成树状结构的对象的具体类。 你也无需了解对象是简单的产品还是复杂的盒子。 你只需调用通用接口以相同的方式对其进行处理即可。 当你调用该方法后， 对象会将请求沿着树结构传递下去。</p>
<h2 id="组合模式结构">组合模式结构</h2>
<figure data-type="image" tabindex="1"><img src="https://refactoringguru.cn/images/patterns/diagrams/composite/structure-zh-2x.png" alt="likecat" loading="lazy"></figure>
<ol>
<li><strong>组件 （Component）</strong> 接口描述了树中简单项目和复杂项目所共有的操作。</li>
<li><strong>叶节点 （Leaf）</strong> 是树的基本结构， 它不包含子项目。<br>
一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。</li>
<li><strong>容器 （Container）</strong>——又名 “<strong>组合 （Composite）</strong>”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。<br>
容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。</li>
<li><strong>客户端 （Client）</strong> 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。</li>
</ol>
<h2 id="伪代码">伪代码</h2>
<p>简单和复合图形</p>
<p>本例展示了如何利用较为简单的形状来组成复杂图形， 以及如何统一处理简单和复杂图形。</p>
<ol>
<li>通用形状接口</li>
</ol>
<pre><code>package com.composite;

import java.awt.*;

/**
 * 通用形状接口
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 09:26
 */
public interface Shape {
    int getX();
    int getY();
    int getWidth();
    int getHeight();
    void move(int x, int y);
    boolean isInsideBounds(int x, int y);
    void select();
    void unSelect();
    boolean isSelected();
    void paint(Graphics graphics);
}

</code></pre>
<ol start="2">
<li>提供基本功能的抽象形状</li>
</ol>
<pre><code>package com.composite;

import java.awt.*;

/**
 * 提供基本功能的抽象形状
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 10:48
 */
abstract class BaseShape implements Shape{
    public int x;
    public int y;
    public Color color;
    private boolean selected = false;

    BaseShape(int x, int y, Color color) {
        this.x = x;
        this.y = y;
        this.color = color;
    }

    @Override
    public int getX() {
        return x;
    }

    @Override
    public int getY() {
        return y;
    }

    @Override
    public int getWidth() {
        return 0;
    }

    @Override
    public int getHeight() {
        return 0;
    }

    @Override
    public void move(int x, int y) {
        this.x += x;
        this.y += y;
    }

    @Override
    public boolean isInsideBounds(int x, int y) {
        return x &gt; getX() &amp;&amp; x &lt; (getX() + getWidth()) &amp;&amp;
                y &gt; getY() &amp;&amp; y &lt; (getY() + getHeight());
    }

    @Override
    public void select() {
        selected = true;
    }

    @Override
    public void unSelect() {
        selected = false;
    }

    @Override
    public boolean isSelected() {
        return selected;
    }

    void enableSelectionStyle(Graphics graphics) {
        graphics.setColor(Color.LIGHT_GRAY);

        Graphics2D g2 = (Graphics2D) graphics;
        float dash1[] = {2.0f};
        g2.setStroke(new BasicStroke(1.0f,
                BasicStroke.CAP_BUTT,
                BasicStroke.JOIN_MITER,
                2.0f, dash1, 0.0f));
    }

    void disableSelectionStyle(Graphics graphics) {
        graphics.setColor(color);
        Graphics2D g2 = (Graphics2D) graphics;
        g2.setStroke(new BasicStroke());
    }


    @Override
    public void paint(Graphics graphics) {
        if (isSelected()) {
            enableSelectionStyle(graphics);
        }
        else {
            disableSelectionStyle(graphics);
        }

        // ...
    }
}

</code></pre>
<ol start="3">
<li>点</li>
</ol>
<pre><code>package com.composite;

import java.awt.*;

/**
 * 点
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 10:49
 */
public class Dot extends BaseShape {
    private final int DOT_SIZE = 3;

    public Dot(int x, int y, Color color) {
        super(x, y, color);
    }

    @Override
    public int getWidth() {
        return DOT_SIZE;
    }

    @Override
    public int getHeight() {
        return DOT_SIZE;
    }

    @Override
    public void paint(Graphics graphics) {
        super.paint(graphics);
        graphics.fillRect(x - 1, y - 1, getWidth(), getHeight());
    }
}

</code></pre>
<ol start="4">
<li>圆</li>
</ol>
<pre><code>package com.composite;

import java.awt.*;

/**
 * 圆
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 10:50
 */
public class Circle extends BaseShape{
    public int radius;

    public Circle(int x, int y, int radius, Color color) {
        super(x, y, color);
        this.radius = radius;
    }

    @Override
    public int getWidth() {
        return radius * 2;
    }

    @Override
    public int getHeight() {
        return radius * 2;
    }

    public void paint(Graphics graphics) {
        super.paint(graphics);
        graphics.drawOval(x, y, getWidth() - 1, getHeight() - 1);
    }
}

</code></pre>
<ol start="5">
<li>三角形</li>
</ol>
<pre><code>package com.composite;

import java.awt.*;

/**
 * 三角形
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 10:50
 */
public class Rectangle extends BaseShape{
    public int width;
    public int height;

    public Rectangle(int x, int y, int width, int height, Color color) {
        super(x, y, color);
        this.width = width;
        this.height = height;
    }

    @Override
    public int getWidth() {
        return width;
    }

    @Override
    public int getHeight() {
        return height;
    }

    @Override
    public void paint(Graphics graphics) {
        super.paint(graphics);
        graphics.drawRect(x, y, getWidth() - 1, getHeight() - 1);
    }
}

</code></pre>
<ol start="6">
<li>由其他形状对象组成的复合形状</li>
</ol>
<pre><code>package com.composite;

import java.awt.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * 由其他形状对象组成的复合形状
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 10:51
 */
public class CompoundShape extends BaseShape{
    protected List&lt;Shape&gt; children = new ArrayList&lt;&gt;();

    public CompoundShape(Shape... components) {
        super(0, 0, Color.BLACK);
        add(components);
    }

    public void add(Shape component) {
        children.add(component);
    }

    public void add(Shape... components) {
        children.addAll(Arrays.asList(components));
    }

    public void remove(Shape child) {
        children.remove(child);
    }

    public void remove(Shape... components) {
        children.removeAll(Arrays.asList(components));
    }

    public void clear() {
        children.clear();
    }

    @Override
    public int getX() {
        if (children.size() == 0) {
            return 0;
        }
        int x = children.get(0).getX();
        for (Shape child : children) {
            if (child.getX() &lt; x) {
                x = child.getX();
            }
        }
        return x;
    }

    @Override
    public int getY() {
        if (children.size() == 0) {
            return 0;
        }
        int y = children.get(0).getY();
        for (Shape child : children) {
            if (child.getY() &lt; y) {
                y = child.getY();
            }
        }
        return y;
    }

    @Override
    public int getWidth() {
        int maxWidth = 0;
        int x = getX();
        for (Shape child : children) {
            int childsRelativeX = child.getX() - x;
            int childWidth = childsRelativeX + child.getWidth();
            if (childWidth &gt; maxWidth) {
                maxWidth = childWidth;
            }
        }
        return maxWidth;
    }

    @Override
    public int getHeight() {
        int maxHeight = 0;
        int y = getY();
        for (Shape child : children) {
            int childsRelativeY = child.getY() - y;
            int childHeight = childsRelativeY + child.getHeight();
            if (childHeight &gt; maxHeight) {
                maxHeight = childHeight;
            }
        }
        return maxHeight;
    }

    @Override
    public void move(int x, int y) {
        for (Shape child : children) {
            child.move(x, y);
        }
    }

    @Override
    public boolean isInsideBounds(int x, int y) {
        for (Shape child : children) {
            if (child.isInsideBounds(x, y)) {
                return true;
            }
        }
        return false;
    }

    @Override
    public void unSelect() {
        super.unSelect();
        for (Shape child : children) {
            child.unSelect();
        }
    }

    public boolean selectChildAt(int x, int y) {
        for (Shape child : children) {
            if (child.isInsideBounds(x, y)) {
                child.select();
                return true;
            }
        }
        return false;
    }

    @Override
    public void paint(Graphics graphics) {
        if (isSelected()) {
            enableSelectionStyle(graphics);
            graphics.drawRect(getX() - 1, getY() - 1, getWidth() + 1, getHeight() + 1);
            disableSelectionStyle(graphics);
        }

        for (Shape child : children) {
            child.paint(graphics);
        }
    }
}

</code></pre>
<ol start="7">
<li>形状编辑器</li>
</ol>
<pre><code>package com.composite;

import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

/**
 * 形状编辑器
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 10:53
 */
public class ImageEditor {
    private EditorCanvas canvas;
    private CompoundShape allShapes = new CompoundShape();

    public ImageEditor() {
        canvas = new EditorCanvas();
    }

    public void loadShapes(Shape... shapes) {
        allShapes.clear();
        allShapes.add(shapes);
        canvas.refresh();
    }

    private class EditorCanvas extends Canvas {
        JFrame frame;

        private static final int PADDING = 10;

        EditorCanvas() {
            createFrame();
            refresh();
            addMouseListener(new MouseAdapter() {
                @Override
                public void mousePressed(MouseEvent e) {
                    allShapes.unSelect();
                    allShapes.selectChildAt(e.getX(), e.getY());
                    e.getComponent().repaint();
                }
            });
        }

        void createFrame() {
            frame = new JFrame();
            frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
            frame.setLocationRelativeTo(null);

            JPanel contentPanel = new JPanel();
            Border padding = BorderFactory.createEmptyBorder(PADDING, PADDING, PADDING, PADDING);
            contentPanel.setBorder(padding);
            frame.setContentPane(contentPanel);

            frame.add(this);
            frame.setVisible(true);
            frame.getContentPane().setBackground(Color.LIGHT_GRAY);
        }

        public int getWidth() {
            return allShapes.getX() + allShapes.getWidth() + PADDING;
        }

        public int getHeight() {
            return allShapes.getY() + allShapes.getHeight() + PADDING;
        }

        void refresh() {
            this.setSize(getWidth(), getHeight());
            frame.pack();
        }

        public void paint(Graphics graphics) {
            allShapes.paint(graphics);
        }
    }
}

</code></pre>
<ol start="8">
<li>客户端代码</li>
</ol>
<pre><code>package com.composite;

import java.awt.*;

/**
 * 客户端代码
 * @author TZP
 * @version 1.0
 * @date 2022/1/14 10:54
 */
public class Demo {
    public static void main(String[] args) {
        ImageEditor editor = new ImageEditor();

        editor.loadShapes(
                new Circle(10, 10, 10, Color.BLUE),

                new CompoundShape(
                        new Circle(110, 110, 50, Color.RED),
                        new Dot(160, 160, Color.RED)
                ),

                new CompoundShape(
                        new Rectangle(250, 250, 100, 100, Color.GREEN),
                        new Dot(240, 240, Color.GREEN),
                        new Dot(240, 360, Color.GREEN),
                        new Dot(360, 360, Color.GREEN),
                        new Dot(360, 240, Color.GREEN)
                )
        );
    }
}

</code></pre>
<h2 id="组合模式适合应用场景">组合模式适合应用场景</h2>
<ol>
<li>
<p>如果你需要实现树状对象结构， 可以使用组合模式。</p>
<p>组合模式为你提供了两种共享公共接口的基本元素类型： 简单叶节点和复杂容器。 容器中可以包含叶节点和其他容器。 这使得你可以构建树状嵌套递归对象结构。</p>
</li>
<li>
<p>如果你希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。</p>
<p>组合模式中定义的所有元素共用同一个接口。 在这一接口的帮助下， 客户端不必在意其所使用的对象的具体类。</p>
</li>
</ol>
<h2 id="实现方式">实现方式</h2>
<ol>
<li>
<p>确保应用的核心模型能够以树状结构表示。 尝试将其分解为简单元素和容器。 记住， 容器必须能够同时包含简单元素和其他容器。</p>
</li>
<li>
<p>声明组件接口及其一系列方法， 这些方法对简单和复杂元素都有意义。</p>
</li>
<li>
<p>创建一个叶节点类表示简单元素。 程序中可以有多个不同的叶节点类。</p>
</li>
<li>
<p>创建一个容器类表示复杂元素。 在该类中， 创建一个数组成员变量来存储对于其子元素的引用。 该数组必须能够同时保存叶节点和容器， 因此请确保将其声明为组合接口类型。</p>
<p>实现组件接口方法时， 记住容器应该将大部分工作交给其子元素来完成。</p>
</li>
<li>
<p>最后， 在容器中定义添加和删除子元素的方法。</p>
</li>
</ol>
<p>记住， 这些操作可在组件接口中声明。 这将会违反<strong>接口隔离原则</strong>， 因为叶节点类中的这些方法为空。 但是， 这可以让客户端无差别地访问所有元素， 即使是组成树状结构的元素。</p>
<h2 id="组合模式优缺点">组合模式优缺点</h2>
<table>
<thead>
<tr>
<th>优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>你可以利用多态和递归机制更方便地使用复杂树结构。</td>
<td style="text-align:center">对于功能差异较大的类， 提供公共接口或许会有困难。 在特定情况下， 你需要过度一般化组件接口， 使其变得令人难以理解。</td>
</tr>
<tr>
<td>开闭原则。 无需更改现有代码， 你就可以在应用中添加新元素， 使其成为对象树的一部分。</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="与其他模式的关系">与其他模式的关系</h2>
<ol>
<li>
<p><strong>桥接模式</strong>、 <strong>状态模式</strong>和<strong>策略模式</strong> （在某种程度上包括<strong>适配器模式</strong>） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p>
</li>
<li>
<p>你可以在创建复杂<strong>组合树</strong>时使用<strong>生成器模式</strong>， 因为这可使其构造步骤以递归的方式运行。</p>
</li>
<li>
<p><strong>责任链模式</strong>通常和<strong>组合模式</strong>结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。</p>
</li>
<li>
<p>你可以使用<strong>迭代器模式</strong>来遍历组合树。</p>
</li>
<li>
<p>你可以使用<strong>访问者模式</strong>对整个<strong>组合树</strong>执行操作。</p>
</li>
<li>
<p>你可以使用<strong>享元模式</strong>实现组合树的共享叶节点以节省内存。</p>
</li>
<li>
<p><strong>组合</strong>和<strong>装饰模式</strong>的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。</p>
<p>装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。</p>
<p>但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。</p>
</li>
<li>
<p>大量使用<strong>组合</strong>和<strong>装饰</strong>的设计通常可从对于<strong>原型模式</strong>的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</p>
</li>
</ol>

                </div>

                <div class="post--keywords" itemprop="keywords">
					 <a href="https://q456qq520.github.io/tag/CH4G4OVER/" class="post--keyword" data-title="设计模式" data-type="post_tag" data-term-id="39">设计模式</a>           </div>



        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '1e61bc4630cf7e3c0b8e',
    clientSecret: 'd1728142222f511a472443c6e499356387ab3b96',
    repo: 'q456qq520.github.io',
    owner: 'q456qq520',
    admin: ['q456qq520'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
                      </section>
    </main>
</div>
	<footer class="site-footer u-textAlignCenter">
    	<div class="footer-branding">
            <a href="https://q456qq520.github.io" title="LIKE CAT">LIKE CAT</a>
									<p class="site-description">FOR CODE</p>
			         </div>
		 <hr />
		 <div class="social-links">
		                       
                            
                           
                            
                           
                            	
			<span class="social-link"><a href="https://github.com/" target="_blank"><i class="iconfont icon-github"></i></a></span>	
			                         
                           
                            
                           
                            
                           
                            
                           
                            
                           
                            
                           
                            
                           
                            
                           
                            
                           
                            
                           
				</div>
        <div class="footer-copy">
                Powered by <a href="https://blog.csdn.net/weixin_42652031" target="_blank">一条小咸鱼</a>
        </div>

    </footer>
	<div class="back-to-top u-hide" onclick="backToTop();"><i class="iconfont icon-xiangshang"></i></div>

<script type='text/javascript' src='https://q456qq520.github.io/media/scripts/main.js'></script>
</body>
</html>